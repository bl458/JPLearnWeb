import { createElement, Fragment, Component } from 'react';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

// Based on http://en.wikipedia.org/wiki/Ky%C5%8Diku_kanji
var kyoikuKanji = {
  "grade1": ["一", "二", "三", "四", "五", "六", "七", "八", "九", "十", "百", "千", "上", "下", "左", "右", "中", "大", "小", "月", "日", "年", "早", "木", "林", "山", "川", "土", "空", "田", "天", "生", "花", "草", "虫", "犬", "人", "名", "女", "男", "子", "目", "耳", "口", "手", "足", "見", "音", "力", "気", "円", "入", "出", "立", "休", "先", "夕", "本", "文", "字", "学", "校", "村", "町", "森", "正", "水", "火", "玉", "王", "石", "竹", "糸", "貝", "車", "金", "雨", "赤", "青", "白"],
  "grade2": ["数", "多", "少", "万", "半", "形", "太", "細", "広", "長", "点", "丸", "交", "光", "角", "計", "直", "線", "矢", "弱", "強", "高", "同", "親", "母", "父", "姉", "兄", "弟", "妹", "自", "友", "体", "毛", "頭", "顔", "首", "心", "時", "曜", "朝", "昼", "夜", "分", "週", "春", "夏", "秋", "冬", "今", "新", "古", "間", "方", "北", "南", "東", "西", "遠", "近", "前", "後", "内", "外", "場", "地", "国", "園", "谷", "野", "原", "里", "市", "京", "風", "雪", "雲", "池", "海", "岩", "星", "室", "戸", "家", "寺", "通", "門", "道", "話", "言", "答", "声", "聞", "語", "読", "書", "記", "紙", "画", "絵", "図", "工", "教", "晴", "思", "考", "知", "才", "理", "算", "作", "元", "食", "肉", "馬", "牛", "魚", "鳥", "羽", "鳴", "麦", "米", "茶", "色", "黄", "黒", "来", "行", "帰", "歩", "走", "止", "活", "店", "買", "売", "午", "汽", "弓", "回", "会", "組", "船", "明", "社", "切", "電", "毎", "合", "当", "台", "楽", "公", "引", "科", "歌", "刀", "番", "用", "何"],
  "grade3": ["丁", "世", "両", "主", "乗", "予", "事", "仕", "他", "代", "住", "使", "係", "倍", "全", "具", "写", "列", "助", "勉", "動", "勝", "化", "区", "医", "去", "反", "取", "受", "号", "向", "君", "味", "命", "和", "品", "員", "商", "問", "坂", "央", "始", "委", "守", "安", "定", "実", "客", "宮", "宿", "寒", "対", "局", "屋", "岸", "島", "州", "帳", "平", "幸", "度", "庫", "庭", "式", "役", "待", "急", "息", "悪", "悲", "想", "意", "感", "所", "打", "投", "拾", "持", "指", "放", "整", "旅", "族", "昔", "昭", "暑", "暗", "曲", "有", "服", "期", "板", "柱", "根", "植", "業", "様", "横", "橋", "次", "歯", "死", "氷", "決", "油", "波", "注", "泳", "洋", "流", "消", "深", "温", "港", "湖", "湯", "漢", "炭", "物", "球", "由", "申", "界", "畑", "病", "発", "登", "皮", "皿", "相", "県", "真", "着", "短", "研", "礼", "神", "祭", "福", "秒", "究", "章", "童", "笛", "第", "筆", "等", "箱", "級", "終", "緑", "練", "羊", "美", "習", "者", "育", "苦", "荷", "落", "葉", "薬", "血", "表", "詩", "調", "談", "豆", "負", "起", "路", "身", "転", "軽", "農", "返", "追", "送", "速", "進", "遊", "運", "部", "都", "配", "酒", "重", "鉄", "銀", "開", "院", "陽", "階", "集", "面", "題", "飲", "館", "駅", "鼻"],
  "grade4": ["不", "争", "付", "令", "以", "仲", "伝", "位", "低", "例", "便", "信", "倉", "候", "借", "停", "健", "側", "働", "億", "兆", "児", "共", "兵", "典", "冷", "初", "別", "利", "刷", "副", "功", "加", "努", "労", "勇", "包", "卒", "協", "単", "博", "印", "参", "史", "司", "各", "告", "周", "唱", "喜", "器", "囲", "固", "型", "堂", "塩", "士", "変", "夫", "失", "好", "季", "孫", "完", "官", "害", "察", "巣", "差", "希", "席", "帯", "底", "府", "康", "建", "径", "徒", "得", "必", "念", "愛", "成", "戦", "折", "挙", "改", "救", "敗", "散", "料", "旗", "昨", "景", "最", "望", "未", "末", "札", "材", "束", "松", "果", "栄", "案", "梅", "械", "極", "標", "機", "欠", "歴", "残", "殺", "毒", "氏", "民", "求", "治", "法", "泣", "浅", "浴", "清", "満", "漁", "灯", "無", "然", "焼", "照", "熱", "牧", "特", "産", "的", "省", "祝", "票", "種", "積", "競", "笑", "管", "節", "粉", "紀", "約", "結", "給", "続", "置", "老", "胃", "脈", "腸", "臣", "航", "良", "芸", "芽", "英", "菜", "街", "衣", "要", "覚", "観", "訓", "試", "説", "課", "議", "象", "貨", "貯", "費", "賞", "軍", "輪", "辞", "辺", "連", "達", "選", "郡", "量", "録", "鏡", "関", "陸", "隊", "静", "順", "願", "類", "飛", "飯", "養", "験"],
  "grade5": ["久", "仏", "仮", "件", "任", "似", "余", "価", "保", "修", "俵", "個", "備", "像", "再", "刊", "判", "制", "券", "則", "効", "務", "勢", "厚", "句", "可", "営", "因", "団", "圧", "在", "均", "基", "報", "境", "墓", "増", "夢", "妻", "婦", "容", "寄", "富", "導", "居", "属", "布", "師", "常", "幹", "序", "弁", "張", "往", "復", "徳", "志", "応", "快", "性", "恩", "情", "態", "慣", "承", "技", "招", "授", "採", "接", "提", "損", "支", "政", "故", "敵", "断", "旧", "易", "暴", "条", "枝", "査", "格", "桜", "検", "構", "武", "比", "永", "河", "液", "混", "減", "測", "準", "演", "潔", "災", "燃", "版", "犯", "状", "独", "率", "現", "留", "略", "益", "眼", "破", "確", "示", "祖", "禁", "移", "程", "税", "築", "精", "素", "経", "統", "絶", "綿", "総", "編", "績", "織", "罪", "群", "義", "耕", "職", "肥", "能", "興", "舌", "舎", "術", "衛", "製", "複", "規", "解", "設", "許", "証", "評", "講", "謝", "識", "護", "豊", "財", "貧", "責", "貸", "貿", "賀", "資", "賛", "質", "輸", "述", "迷", "退", "逆", "造", "過", "適", "酸", "鉱", "銅", "銭", "防", "限", "険", "際", "雑", "非", "預", "領", "額", "飼"],
  "grade6": ["並", "乱", "乳", "亡", "仁", "供", "俳", "値", "傷", "優", "党", "冊", "処", "刻", "割", "創", "劇", "勤", "危", "卵", "厳", "収", "后", "否", "吸", "呼", "善", "困", "垂", "城", "域", "奏", "奮", "姿", "存", "孝", "宅", "宇", "宗", "宙", "宝", "宣", "密", "寸", "専", "射", "将", "尊", "就", "尺", "届", "展", "層", "己", "巻", "幕", "干", "幼", "庁", "座", "延", "律", "従", "忘", "忠", "憲", "我", "批", "担", "拝", "拡", "捨", "探", "推", "揮", "操", "敬", "映", "晩", "暖", "暮", "朗", "机", "枚", "染", "株", "棒", "模", "権", "樹", "欲", "段", "沿", "泉", "洗", "派", "済", "源", "潮", "激", "灰", "熟", "片", "班", "異", "疑", "痛", "皇", "盛", "盟", "看", "砂", "磁", "私", "秘", "穀", "穴", "窓", "筋", "策", "簡", "糖", "系", "紅", "納", "純", "絹", "縦", "縮", "署", "翌", "聖", "肺", "背", "胸", "脳", "腹", "臓", "臨", "至", "若", "著", "蒸", "蔵", "蚕", "衆", "裁", "装", "裏", "補", "視", "覧", "討", "訪", "訳", "詞", "誌", "認", "誕", "誠", "誤", "論", "諸", "警", "貴", "賃", "遺", "郵", "郷", "針", "鋼", "閉", "閣", "降", "陛", "除", "障", "難", "革", "頂", "骨"]
};

// Based on http://x0213.org/joyo-kanji-code/index.en.html
var joyoKanji = {
  "kanji": ["亜", "哀", "挨", "愛", "曖", "悪", "握", "圧", "扱", "宛", "嵐", "安", "案", "暗", "以", "衣", "位", "囲", "医", "依", "委", "威", "為", "畏", "胃", "尉", "異", "移", "萎", "偉", "椅", "彙", "意", "違", "維", "慰", "遺", "緯", "域", "育", "一", "壱", "逸", "茨", "芋", "引", "印", "因", "咽", "姻", "員", "院", "淫", "陰", "飲", "隠", "韻", "右", "宇", "羽", "雨", "唄", "鬱", "畝", "浦", "運", "雲", "永", "泳", "英", "映", "栄", "営", "詠", "影", "鋭", "衛", "易", "疫", "益", "液", "駅", "悦", "越", "謁", "閲", "円", "延", "沿", "炎", "怨", "宴", "媛", "援", "園", "煙", "猿", "遠", "鉛", "塩", "演", "縁", "艶", "汚", "王", "凹", "央", "応", "往", "押", "旺", "欧", "殴", "桜", "翁", "奥", "横", "岡", "屋", "億", "憶", "臆", "虞", "乙", "俺", "卸", "音", "恩", "温", "穏", "下", "化", "火", "加", "可", "仮", "何", "花", "佳", "価", "果", "河", "苛", "科", "架", "夏", "家", "荷", "華", "菓", "貨", "渦", "過", "嫁", "暇", "禍", "靴", "寡", "歌", "箇", "稼", "課", "蚊", "牙", "瓦", "我", "画", "芽", "賀", "雅", "餓", "介", "回", "灰", "会", "快", "戒", "改", "怪", "拐", "悔", "海", "界", "皆", "械", "絵", "開", "階", "塊", "楷", "解", "潰", "壊", "懐", "諧", "貝", "外", "劾", "害", "崖", "涯", "街", "慨", "蓋", "該", "概", "骸", "垣", "柿", "各", "角", "拡", "革", "格", "核", "殻", "郭", "覚", "較", "隔", "閣", "確", "獲", "嚇", "穫", "学", "岳", "楽", "額", "顎", "掛", "潟", "括", "活", "喝", "渇", "割", "葛", "滑", "褐", "轄", "且", "株", "釜", "鎌", "刈", "干", "刊", "甘", "汗", "缶", "完", "肝", "官", "冠", "巻", "看", "陥", "乾", "勘", "患", "貫", "寒", "喚", "堪", "換", "敢", "棺", "款", "間", "閑", "勧", "寛", "幹", "感", "漢", "慣", "管", "関", "歓", "監", "緩", "憾", "還", "館", "環", "簡", "観", "韓", "艦", "鑑", "丸", "含", "岸", "岩", "玩", "眼", "頑", "顔", "願", "企", "伎", "危", "机", "気", "岐", "希", "忌", "汽", "奇", "祈", "季", "紀", "軌", "既", "記", "起", "飢", "鬼", "帰", "基", "寄", "規", "亀", "喜", "幾", "揮", "期", "棋", "貴", "棄", "毀", "旗", "器", "畿", "輝", "機", "騎", "技", "宜", "偽", "欺", "義", "疑", "儀", "戯", "擬", "犠", "議", "菊", "吉", "喫", "詰", "却", "客", "脚", "逆", "虐", "九", "久", "及", "弓", "丘", "旧", "休", "吸", "朽", "臼", "求", "究", "泣", "急", "級", "糾", "宮", "救", "球", "給", "嗅", "窮", "牛", "去", "巨", "居", "拒", "拠", "挙", "虚", "許", "距", "魚", "御", "漁", "凶", "共", "叫", "狂", "京", "享", "供", "協", "況", "峡", "挟", "狭", "恐", "恭", "胸", "脅", "強", "教", "郷", "境", "橋", "矯", "鏡", "競", "響", "驚", "仰", "暁", "業", "凝", "曲", "局", "極", "玉", "巾", "斤", "均", "近", "金", "菌", "勤", "琴", "筋", "僅", "禁", "緊", "錦", "謹", "襟", "吟", "銀", "区", "句", "苦", "駆", "具", "惧", "愚", "空", "偶", "遇", "隅", "串", "屈", "掘", "窟", "熊", "繰", "君", "訓", "勲", "薫", "軍", "郡", "群", "兄", "刑", "形", "系", "径", "茎", "係", "型", "契", "計", "恵", "啓", "掲", "渓", "経", "蛍", "敬", "景", "軽", "傾", "携", "継", "詣", "慶", "憬", "稽", "憩", "警", "鶏", "芸", "迎", "鯨", "隙", "劇", "撃", "激", "桁", "欠", "穴", "血", "決", "結", "傑", "潔", "月", "犬", "件", "見", "券", "肩", "建", "研", "県", "倹", "兼", "剣", "拳", "軒", "健", "険", "圏", "堅", "検", "嫌", "献", "絹", "遣", "権", "憲", "賢", "謙", "鍵", "繭", "顕", "験", "懸", "元", "幻", "玄", "言", "弦", "限", "原", "現", "舷", "減", "源", "厳", "己", "戸", "古", "呼", "固", "股", "虎", "孤", "弧", "故", "枯", "個", "庫", "湖", "雇", "誇", "鼓", "錮", "顧", "五", "互", "午", "呉", "後", "娯", "悟", "碁", "語", "誤", "護", "口", "工", "公", "勾", "孔", "功", "巧", "広", "甲", "交", "光", "向", "后", "好", "江", "考", "行", "坑", "孝", "抗", "攻", "更", "効", "幸", "拘", "肯", "侯", "厚", "恒", "洪", "皇", "紅", "荒", "郊", "香", "候", "校", "耕", "航", "貢", "降", "高", "康", "控", "梗", "黄", "喉", "慌", "港", "硬", "絞", "項", "溝", "鉱", "構", "綱", "酵", "稿", "興", "衡", "鋼", "講", "購", "乞", "号", "合", "拷", "剛", "傲", "豪", "克", "告", "谷", "刻", "国", "黒", "穀", "酷", "獄", "骨", "駒", "込", "頃", "今", "困", "昆", "恨", "根", "婚", "混", "痕", "紺", "魂", "墾", "懇", "左", "佐", "沙", "査", "砂", "唆", "差", "詐", "鎖", "座", "挫", "才", "再", "災", "妻", "采", "砕", "宰", "栽", "彩", "採", "済", "祭", "斎", "細", "菜", "最", "裁", "債", "催", "塞", "歳", "載", "際", "埼", "在", "材", "剤", "財", "罪", "崎", "作", "削", "昨", "柵", "索", "策", "酢", "搾", "錯", "咲", "冊", "札", "刷", "刹", "拶", "殺", "察", "撮", "擦", "雑", "皿", "三", "山", "参", "桟", "蚕", "惨", "産", "傘", "散", "算", "酸", "賛", "残", "斬", "暫", "士", "子", "支", "止", "氏", "仕", "史", "司", "四", "市", "矢", "旨", "死", "糸", "至", "伺", "志", "私", "使", "刺", "始", "姉", "枝", "祉", "肢", "姿", "思", "指", "施", "師", "恣", "紙", "脂", "視", "紫", "詞", "歯", "嗣", "試", "詩", "資", "飼", "誌", "雌", "摯", "賜", "諮", "示", "字", "寺", "次", "耳", "自", "似", "児", "事", "侍", "治", "持", "時", "滋", "慈", "辞", "磁", "餌", "璽", "鹿", "式", "識", "軸", "七", "𠮟", "失", "室", "疾", "執", "湿", "嫉", "漆", "質", "実", "芝", "写", "社", "車", "舎", "者", "射", "捨", "赦", "斜", "煮", "遮", "謝", "邪", "蛇", "尺", "借", "酌", "釈", "爵", "若", "弱", "寂", "手", "主", "守", "朱", "取", "狩", "首", "殊", "珠", "酒", "腫", "種", "趣", "寿", "受", "呪", "授", "需", "儒", "樹", "収", "囚", "州", "舟", "秀", "周", "宗", "拾", "秋", "臭", "修", "袖", "終", "羞", "習", "週", "就", "衆", "集", "愁", "酬", "醜", "蹴", "襲", "十", "汁", "充", "住", "柔", "重", "従", "渋", "銃", "獣", "縦", "叔", "祝", "宿", "淑", "粛", "縮", "塾", "熟", "出", "述", "術", "俊", "春", "瞬", "旬", "巡", "盾", "准", "殉", "純", "循", "順", "準", "潤", "遵", "処", "初", "所", "書", "庶", "暑", "署", "緒", "諸", "女", "如", "助", "序", "叙", "徐", "除", "小", "升", "少", "召", "匠", "床", "抄", "肖", "尚", "招", "承", "昇", "松", "沼", "昭", "宵", "将", "消", "症", "祥", "称", "笑", "唱", "商", "渉", "章", "紹", "訟", "勝", "掌", "晶", "焼", "焦", "硝", "粧", "詔", "証", "象", "傷", "奨", "照", "詳", "彰", "障", "憧", "衝", "賞", "償", "礁", "鐘", "上", "丈", "冗", "条", "状", "乗", "城", "浄", "剰", "常", "情", "場", "畳", "蒸", "縄", "壌", "嬢", "錠", "譲", "醸", "色", "拭", "食", "植", "殖", "飾", "触", "嘱", "織", "職", "辱", "尻", "心", "申", "伸", "臣", "芯", "身", "辛", "侵", "信", "津", "神", "唇", "娠", "振", "浸", "真", "針", "深", "紳", "進", "森", "診", "寝", "慎", "新", "審", "震", "薪", "親", "人", "刃", "仁", "尽", "迅", "甚", "陣", "尋", "腎", "須", "図", "水", "吹", "垂", "炊", "帥", "粋", "衰", "推", "酔", "遂", "睡", "穂", "随", "髄", "枢", "崇", "数", "据", "杉", "裾", "寸", "瀬", "是", "井", "世", "正", "生", "成", "西", "声", "制", "姓", "征", "性", "青", "斉", "政", "星", "牲", "省", "凄", "逝", "清", "盛", "婿", "晴", "勢", "聖", "誠", "精", "製", "誓", "静", "請", "整", "醒", "税", "夕", "斥", "石", "赤", "昔", "析", "席", "脊", "隻", "惜", "戚", "責", "跡", "積", "績", "籍", "切", "折", "拙", "窃", "接", "設", "雪", "摂", "節", "説", "舌", "絶", "千", "川", "仙", "占", "先", "宣", "専", "泉", "浅", "洗", "染", "扇", "栓", "旋", "船", "戦", "煎", "羨", "腺", "詮", "践", "箋", "銭", "潜", "線", "遷", "選", "薦", "繊", "鮮", "全", "前", "善", "然", "禅", "漸", "膳", "繕", "狙", "阻", "祖", "租", "素", "措", "粗", "組", "疎", "訴", "塑", "遡", "礎", "双", "壮", "早", "争", "走", "奏", "相", "荘", "草", "送", "倉", "捜", "挿", "桑", "巣", "掃", "曹", "曽", "爽", "窓", "創", "喪", "痩", "葬", "装", "僧", "想", "層", "総", "遭", "槽", "踪", "操", "燥", "霜", "騒", "藻", "造", "像", "増", "憎", "蔵", "贈", "臓", "即", "束", "足", "促", "則", "息", "捉", "速", "側", "測", "俗", "族", "属", "賊", "続", "卒", "率", "存", "村", "孫", "尊", "損", "遜", "他", "多", "汰", "打", "妥", "唾", "堕", "惰", "駄", "太", "対", "体", "耐", "待", "怠", "胎", "退", "帯", "泰", "堆", "袋", "逮", "替", "貸", "隊", "滞", "態", "戴", "大", "代", "台", "第", "題", "滝", "宅", "択", "沢", "卓", "拓", "託", "濯", "諾", "濁", "但", "達", "脱", "奪", "棚", "誰", "丹", "旦", "担", "単", "炭", "胆", "探", "淡", "短", "嘆", "端", "綻", "誕", "鍛", "団", "男", "段", "断", "弾", "暖", "談", "壇", "地", "池", "知", "値", "恥", "致", "遅", "痴", "稚", "置", "緻", "竹", "畜", "逐", "蓄", "築", "秩", "窒", "茶", "着", "嫡", "中", "仲", "虫", "沖", "宙", "忠", "抽", "注", "昼", "柱", "衷", "酎", "鋳", "駐", "著", "貯", "丁", "弔", "庁", "兆", "町", "長", "挑", "帳", "張", "彫", "眺", "釣", "頂", "鳥", "朝", "貼", "超", "腸", "跳", "徴", "嘲", "潮", "澄", "調", "聴", "懲", "直", "勅", "捗", "沈", "珍", "朕", "陳", "賃", "鎮", "追", "椎", "墜", "通", "痛", "塚", "漬", "坪", "爪", "鶴", "低", "呈", "廷", "弟", "定", "底", "抵", "邸", "亭", "貞", "帝", "訂", "庭", "逓", "停", "偵", "堤", "提", "程", "艇", "締", "諦", "泥", "的", "笛", "摘", "滴", "適", "敵", "溺", "迭", "哲", "鉄", "徹", "撤", "天", "典", "店", "点", "展", "添", "転", "塡", "田", "伝", "殿", "電", "斗", "吐", "妬", "徒", "途", "都", "渡", "塗", "賭", "土", "奴", "努", "度", "怒", "刀", "冬", "灯", "当", "投", "豆", "東", "到", "逃", "倒", "凍", "唐", "島", "桃", "討", "透", "党", "悼", "盗", "陶", "塔", "搭", "棟", "湯", "痘", "登", "答", "等", "筒", "統", "稲", "踏", "糖", "頭", "謄", "藤", "闘", "騰", "同", "洞", "胴", "動", "堂", "童", "道", "働", "銅", "導", "瞳", "峠", "匿", "特", "得", "督", "徳", "篤", "毒", "独", "読", "栃", "凸", "突", "届", "屯", "豚", "頓", "貪", "鈍", "曇", "丼", "那", "奈", "内", "梨", "謎", "鍋", "南", "軟", "難", "二", "尼", "弐", "匂", "肉", "虹", "日", "入", "乳", "尿", "任", "妊", "忍", "認", "寧", "熱", "年", "念", "捻", "粘", "燃", "悩", "納", "能", "脳", "農", "濃", "把", "波", "派", "破", "覇", "馬", "婆", "罵", "拝", "杯", "背", "肺", "俳", "配", "排", "敗", "廃", "輩", "売", "倍", "梅", "培", "陪", "媒", "買", "賠", "白", "伯", "拍", "泊", "迫", "剝", "舶", "博", "薄", "麦", "漠", "縛", "爆", "箱", "箸", "畑", "肌", "八", "鉢", "発", "髪", "伐", "抜", "罰", "閥", "反", "半", "氾", "犯", "帆", "汎", "伴", "判", "坂", "阪", "板", "版", "班", "畔", "般", "販", "斑", "飯", "搬", "煩", "頒", "範", "繁", "藩", "晩", "番", "蛮", "盤", "比", "皮", "妃", "否", "批", "彼", "披", "肥", "非", "卑", "飛", "疲", "秘", "被", "悲", "扉", "費", "碑", "罷", "避", "尾", "眉", "美", "備", "微", "鼻", "膝", "肘", "匹", "必", "泌", "筆", "姫", "百", "氷", "表", "俵", "票", "評", "漂", "標", "苗", "秒", "病", "描", "猫", "品", "浜", "貧", "賓", "頻", "敏", "瓶", "不", "夫", "父", "付", "布", "扶", "府", "怖", "阜", "附", "訃", "負", "赴", "浮", "婦", "符", "富", "普", "腐", "敷", "膚", "賦", "譜", "侮", "武", "部", "舞", "封", "風", "伏", "服", "副", "幅", "復", "福", "腹", "複", "覆", "払", "沸", "仏", "物", "粉", "紛", "雰", "噴", "墳", "憤", "奮", "分", "文", "聞", "丙", "平", "兵", "併", "並", "柄", "陛", "閉", "塀", "幣", "弊", "蔽", "餅", "米", "壁", "璧", "癖", "別", "蔑", "片", "辺", "返", "変", "偏", "遍", "編", "弁", "便", "勉", "歩", "保", "哺", "捕", "補", "舗", "母", "募", "墓", "慕", "暮", "簿", "方", "包", "芳", "邦", "奉", "宝", "抱", "放", "法", "泡", "胞", "俸", "倣", "峰", "砲", "崩", "訪", "報", "蜂", "豊", "飽", "褒", "縫", "亡", "乏", "忙", "坊", "妨", "忘", "防", "房", "肪", "某", "冒", "剖", "紡", "望", "傍", "帽", "棒", "貿", "貌", "暴", "膨", "謀", "頰", "北", "木", "朴", "牧", "睦", "僕", "墨", "撲", "没", "勃", "堀", "本", "奔", "翻", "凡", "盆", "麻", "摩", "磨", "魔", "毎", "妹", "枚", "昧", "埋", "幕", "膜", "枕", "又", "末", "抹", "万", "満", "慢", "漫", "未", "味", "魅", "岬", "密", "蜜", "脈", "妙", "民", "眠", "矛", "務", "無", "夢", "霧", "娘", "名", "命", "明", "迷", "冥", "盟", "銘", "鳴", "滅", "免", "面", "綿", "麺", "茂", "模", "毛", "妄", "盲", "耗", "猛", "網", "目", "黙", "門", "紋", "問", "冶", "夜", "野", "弥", "厄", "役", "約", "訳", "薬", "躍", "闇", "由", "油", "喩", "愉", "諭", "輸", "癒", "唯", "友", "有", "勇", "幽", "悠", "郵", "湧", "猶", "裕", "遊", "雄", "誘", "憂", "融", "優", "与", "予", "余", "誉", "預", "幼", "用", "羊", "妖", "洋", "要", "容", "庸", "揚", "揺", "葉", "陽", "溶", "腰", "様", "瘍", "踊", "窯", "養", "擁", "謡", "曜", "抑", "沃", "浴", "欲", "翌", "翼", "拉", "裸", "羅", "来", "雷", "頼", "絡", "落", "酪", "辣", "乱", "卵", "覧", "濫", "藍", "欄", "吏", "利", "里", "理", "痢", "裏", "履", "璃", "離", "陸", "立", "律", "慄", "略", "柳", "流", "留", "竜", "粒", "隆", "硫", "侶", "旅", "虜", "慮", "了", "両", "良", "料", "涼", "猟", "陵", "量", "僚", "領", "寮", "療", "瞭", "糧", "力", "緑", "林", "厘", "倫", "輪", "隣", "臨", "瑠", "涙", "累", "塁", "類", "令", "礼", "冷", "励", "戻", "例", "鈴", "零", "霊", "隷", "齢", "麗", "暦", "歴", "列", "劣", "烈", "裂", "恋", "連", "廉", "練", "錬", "呂", "炉", "賂", "路", "露", "老", "労", "弄", "郎", "朗", "浪", "廊", "楼", "漏", "籠", "六", "録", "麓", "論", "和", "話", "賄", "脇", "惑", "枠", "湾", "腕"]
};

// Author: Darren Lester

function isKanji(ch) {
	return (ch >= "\u4e00" && ch <= "\u9faf") ||
	(ch >= "\u3400" && ch <= "\u4dbf") ||
	ch === "𠮟";
}

var iskanji = isKanji;

var toStr = Object.prototype.toString;

var isArguments = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr$1 = Object.prototype.toString;
	var isArgs = isArguments; // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr$1.call(object) === '[object Function]';
		var isArguments$$1 = isArgs(object);
		var isString = isObject && toStr$1.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments$$1) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments$$1 && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
var implementation = keysShim;

var slice = Array.prototype.slice;


var origKeys = Object.keys;
var keysShim$1 = origKeys ? function keys(o) { return origKeys(o); } : implementation;

var originalKeys = Object.keys;

keysShim$1.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArguments(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim$1;
	}
	return Object.keys || keysShim$1;
};

var objectKeys = keysShim$1;

var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr$2 = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr$2.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		origDefineProperty(obj, 'x', { enumerable: false, value: obj });
		// eslint-disable-next-line no-unused-vars, no-restricted-syntax
		for (var _ in obj) { // jscs:ignore disallowUnusedVariables
			return false;
		}
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		origDefineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = objectKeys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

var defineProperties_1 = defineProperties;

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice$1 = Array.prototype.slice;
var toStr$3 = Object.prototype.toString;
var funcType = '[object Function]';

var implementation$1 = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr$3.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice$1.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice$1.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice$1.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

var functionBind = Function.prototype.bind || implementation$1;

var src = functionBind.call(Function.call, Object.prototype.hasOwnProperty);

var isPrimitive = function isPrimitive(value) {
	return value === null || (typeof value !== 'function' && typeof value !== 'object');
};

var fnToStr = Function.prototype.toString;

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr$4 = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

var isCallable = function isCallable(value) {
	if (!value) { return false; }
	if (typeof value !== 'function' && typeof value !== 'object') { return false; }
	if (typeof value === 'function' && !value.prototype) { return true; }
	if (hasToStringTag) { return tryFunctionObject(value); }
	if (isES6ClassFn(value)) { return false; }
	var strClass = toStr$4.call(value);
	return strClass === fnClass || strClass === genClass;
};

var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateObject(value) {
	try {
		getDay.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr$5 = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag$1 = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

var isDateObject = function isDateObject(value) {
	if (typeof value !== 'object' || value === null) { return false; }
	return hasToStringTag$1 ? tryDateObject(value) : toStr$5.call(value) === dateClass;
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

/* eslint complexity: [2, 17], max-statements: [2, 33] */
var shams = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

var origSymbol = commonjsGlobal.Symbol;


var hasSymbols$1 = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return shams();
};

var isSymbol = createCommonjsModule(function (module) {

var toStr = Object.prototype.toString;
var hasSymbols = hasSymbols$1();

if (hasSymbols) {
	var symToStr = Symbol.prototype.toString;
	var symStringRegex = /^Symbol\(.*\)$/;
	var isSymbolObject = function isRealSymbolObject(value) {
		if (typeof value.valueOf() !== 'symbol') {
			return false;
		}
		return symStringRegex.test(symToStr.call(value));
	};

	module.exports = function isSymbol(value) {
		if (typeof value === 'symbol') {
			return true;
		}
		if (toStr.call(value) !== '[object Symbol]') {
			return false;
		}
		try {
			return isSymbolObject(value);
		} catch (e) {
			return false;
		}
	};
} else {

	module.exports = function isSymbol(value) {
		// this environment does not support Symbols.
		return false;
	};
}
});

var hasSymbols$2 = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';






var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
	if (typeof O === 'undefined' || O === null) {
		throw new TypeError('Cannot call method on ' + O);
	}
	if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
		throw new TypeError('hint must be "string" or "number"');
	}
	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
	var method, result, i;
	for (i = 0; i < methodNames.length; ++i) {
		method = O[methodNames[i]];
		if (isCallable(method)) {
			result = method.call(O);
			if (isPrimitive(result)) {
				return result;
			}
		}
	}
	throw new TypeError('No default value');
};

var GetMethod = function GetMethod(O, P) {
	var func = O[P];
	if (func !== null && typeof func !== 'undefined') {
		if (!isCallable(func)) {
			throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
		}
		return func;
	}
	return void 0;
};

// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive
var es2015 = function ToPrimitive(input) {
	if (isPrimitive(input)) {
		return input;
	}
	var hint = 'default';
	if (arguments.length > 1) {
		if (arguments[1] === String) {
			hint = 'string';
		} else if (arguments[1] === Number) {
			hint = 'number';
		}
	}

	var exoticToPrim;
	if (hasSymbols$2) {
		if (Symbol.toPrimitive) {
			exoticToPrim = GetMethod(input, Symbol.toPrimitive);
		} else if (isSymbol(input)) {
			exoticToPrim = Symbol.prototype.valueOf;
		}
	}
	if (typeof exoticToPrim !== 'undefined') {
		var result = exoticToPrim.call(input, hint);
		if (isPrimitive(result)) {
			return result;
		}
		throw new TypeError('unable to convert exotic object to primitive');
	}
	if (hint === 'default' && (isDateObject(input) || isSymbol(input))) {
		hint = 'string';
	}
	return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
};

var es6 = es2015;

/* globals
	Set,
	Map,
	WeakSet,
	WeakMap,

	Promise,

	Symbol,
	Proxy,

	Atomics,
	SharedArrayBuffer,

	ArrayBuffer,
	DataView,
	Uint8Array,
	Float32Array,
	Float64Array,
	Int8Array,
	Int16Array,
	Int32Array,
	Uint8ClampedArray,
	Uint16Array,
	Uint32Array,
*/

var undefined$1; // eslint-disable-line no-shadow-restricted-names

var ThrowTypeError = Object.getOwnPropertyDescriptor
	? (function () { return Object.getOwnPropertyDescriptor(arguments, 'callee').get; }())
	: function () { throw new TypeError(); };

var hasSymbols$3 = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto
var generatorFunction = undefined$1;
var asyncFunction = undefined$1;
var asyncGenFunction = undefined$1;

var TypedArray = typeof Uint8Array === 'undefined' ? undefined$1 : getProto(Uint8Array);

var INTRINSICS = {
	'$ %Array%': Array,
	'$ %ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
	'$ %ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer.prototype,
	'$ %ArrayIteratorPrototype%': hasSymbols$3 ? getProto([][Symbol.iterator]()) : undefined$1,
	'$ %ArrayPrototype%': Array.prototype,
	'$ %ArrayProto_entries%': Array.prototype.entries,
	'$ %ArrayProto_forEach%': Array.prototype.forEach,
	'$ %ArrayProto_keys%': Array.prototype.keys,
	'$ %ArrayProto_values%': Array.prototype.values,
	'$ %AsyncFromSyncIteratorPrototype%': undefined$1,
	'$ %AsyncFunction%': asyncFunction,
	'$ %AsyncFunctionPrototype%': undefined$1,
	'$ %AsyncGenerator%': undefined$1,
	'$ %AsyncGeneratorFunction%': asyncGenFunction,
	'$ %AsyncGeneratorPrototype%': undefined$1,
	'$ %AsyncIteratorPrototype%': undefined$1,
	'$ %Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
	'$ %Boolean%': Boolean,
	'$ %BooleanPrototype%': Boolean.prototype,
	'$ %DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
	'$ %DataViewPrototype%': typeof DataView === 'undefined' ? undefined$1 : DataView.prototype,
	'$ %Date%': Date,
	'$ %DatePrototype%': Date.prototype,
	'$ %decodeURI%': decodeURI,
	'$ %decodeURIComponent%': decodeURIComponent,
	'$ %encodeURI%': encodeURI,
	'$ %encodeURIComponent%': encodeURIComponent,
	'$ %Error%': Error,
	'$ %ErrorPrototype%': Error.prototype,
	'$ %eval%': eval, // eslint-disable-line no-eval
	'$ %EvalError%': EvalError,
	'$ %EvalErrorPrototype%': EvalError.prototype,
	'$ %Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
	'$ %Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array.prototype,
	'$ %Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
	'$ %Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array.prototype,
	'$ %Function%': Function,
	'$ %FunctionPrototype%': Function.prototype,
	'$ %Generator%': undefined$1,
	'$ %GeneratorFunction%': generatorFunction,
	'$ %GeneratorPrototype%': undefined$1,
	'$ %Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
	'$ %Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array.prototype,
	'$ %Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
	'$ %Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined$1 : Int8Array.prototype,
	'$ %Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
	'$ %Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array.prototype,
	'$ %isFinite%': isFinite,
	'$ %isNaN%': isNaN,
	'$ %IteratorPrototype%': hasSymbols$3 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
	'$ %JSON%': JSON,
	'$ %JSONParse%': JSON.parse,
	'$ %Map%': typeof Map === 'undefined' ? undefined$1 : Map,
	'$ %MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols$3 ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
	'$ %MapPrototype%': typeof Map === 'undefined' ? undefined$1 : Map.prototype,
	'$ %Math%': Math,
	'$ %Number%': Number,
	'$ %NumberPrototype%': Number.prototype,
	'$ %Object%': Object,
	'$ %ObjectPrototype%': Object.prototype,
	'$ %ObjProto_toString%': Object.prototype.toString,
	'$ %ObjProto_valueOf%': Object.prototype.valueOf,
	'$ %parseFloat%': parseFloat,
	'$ %parseInt%': parseInt,
	'$ %Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
	'$ %PromisePrototype%': typeof Promise === 'undefined' ? undefined$1 : Promise.prototype,
	'$ %PromiseProto_then%': typeof Promise === 'undefined' ? undefined$1 : Promise.prototype.then,
	'$ %Promise_all%': typeof Promise === 'undefined' ? undefined$1 : Promise.all,
	'$ %Promise_reject%': typeof Promise === 'undefined' ? undefined$1 : Promise.reject,
	'$ %Promise_resolve%': typeof Promise === 'undefined' ? undefined$1 : Promise.resolve,
	'$ %Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
	'$ %RangeError%': RangeError,
	'$ %RangeErrorPrototype%': RangeError.prototype,
	'$ %ReferenceError%': ReferenceError,
	'$ %ReferenceErrorPrototype%': ReferenceError.prototype,
	'$ %Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
	'$ %RegExp%': RegExp,
	'$ %RegExpPrototype%': RegExp.prototype,
	'$ %Set%': typeof Set === 'undefined' ? undefined$1 : Set,
	'$ %SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols$3 ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
	'$ %SetPrototype%': typeof Set === 'undefined' ? undefined$1 : Set.prototype,
	'$ %SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
	'$ %SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer.prototype,
	'$ %String%': String,
	'$ %StringIteratorPrototype%': hasSymbols$3 ? getProto(''[Symbol.iterator]()) : undefined$1,
	'$ %StringPrototype%': String.prototype,
	'$ %Symbol%': hasSymbols$3 ? Symbol : undefined$1,
	'$ %SymbolPrototype%': hasSymbols$3 ? Symbol.prototype : undefined$1,
	'$ %SyntaxError%': SyntaxError,
	'$ %SyntaxErrorPrototype%': SyntaxError.prototype,
	'$ %ThrowTypeError%': ThrowTypeError,
	'$ %TypedArray%': TypedArray,
	'$ %TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined$1,
	'$ %TypeError%': TypeError,
	'$ %TypeErrorPrototype%': TypeError.prototype,
	'$ %Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
	'$ %Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array.prototype,
	'$ %Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
	'$ %Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray.prototype,
	'$ %Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
	'$ %Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array.prototype,
	'$ %Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
	'$ %Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array.prototype,
	'$ %URIError%': URIError,
	'$ %URIErrorPrototype%': URIError.prototype,
	'$ %WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
	'$ %WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap.prototype,
	'$ %WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet,
	'$ %WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet.prototype
};

var GetIntrinsic = function GetIntrinsic(name, allowMissing) {
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new TypeError('"allowMissing" argument must be a boolean');
	}

	var key = '$ ' + name;
	if (!(key in INTRINSICS)) {
		throw new SyntaxError('intrinsic ' + name + ' does not exist!');
	}

	// istanbul ignore if // hopefully this is impossible to test :-)
	if (typeof INTRINSICS[key] === 'undefined' && !allowMissing) {
		throw new TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
	}
	return INTRINSICS[key];
};

var $TypeError = GetIntrinsic('%TypeError%');
var $SyntaxError = GetIntrinsic('%SyntaxError%');



var predicates = {
  // https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type
  'Property Descriptor': function isPropertyDescriptor(ES, Desc) {
    if (ES.Type(Desc) !== 'Object') {
      return false;
    }
    var allowed = {
      '[[Configurable]]': true,
      '[[Enumerable]]': true,
      '[[Get]]': true,
      '[[Set]]': true,
      '[[Value]]': true,
      '[[Writable]]': true
    };

    for (var key in Desc) { // eslint-disable-line
      if (src(Desc, key) && !allowed[key]) {
        return false;
      }
    }

    var isData = src(Desc, '[[Value]]');
    var IsAccessor = src(Desc, '[[Get]]') || src(Desc, '[[Set]]');
    if (isData && IsAccessor) {
      throw new $TypeError('Property Descriptors may not be both accessor and data descriptors');
    }
    return true;
  }
};

var assertRecord = function assertRecord(ES, recordType, argumentName, value) {
  var predicate = predicates[recordType];
  if (typeof predicate !== 'function') {
    throw new $SyntaxError('unknown record type: ' + recordType);
  }
  if (!predicate(ES, value)) {
    throw new $TypeError(argumentName + ' must be a ' + recordType);
  }
  console.log(predicate(ES, value), value);
};

var _isNaN = Number.isNaN || function isNaN(a) {
	return a !== a;
};

var $isNaN = Number.isNaN || function (a) { return a !== a; };

var _isFinite = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };

var has$1 = functionBind.call(Function.call, Object.prototype.hasOwnProperty);

var $assign = Object.assign;

var assign = function assign(target, source) {
	if ($assign) {
		return $assign(target, source);
	}

	for (var key in source) {
		if (has$1(source, key)) {
			target[key] = source[key];
		}
	}
	return target;
};

var sign = function sign(number) {
	return number >= 0 ? 1 : -1;
};

var mod = function mod(number, modulo) {
	var remain = number % modulo;
	return Math.floor(remain >= 0 ? remain : remain + modulo);
};

var isPrimitive$1 = function isPrimitive(value) {
	return value === null || (typeof value !== 'function' && typeof value !== 'object');
};

var toStr$6 = Object.prototype.toString;





// http://ecma-international.org/ecma-262/5.1/#sec-8.12.8
var ES5internalSlots = {
	'[[DefaultValue]]': function (O) {
		var actualHint;
		if (arguments.length > 1) {
			actualHint = arguments[1];
		} else {
			actualHint = toStr$6.call(O) === '[object Date]' ? String : Number;
		}

		if (actualHint === String || actualHint === Number) {
			var methods = actualHint === String ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
			var value, i;
			for (i = 0; i < methods.length; ++i) {
				if (isCallable(O[methods[i]])) {
					value = O[methods[i]]();
					if (isPrimitive(value)) {
						return value;
					}
				}
			}
			throw new TypeError('No default value');
		}
		throw new TypeError('invalid [[DefaultValue]] hint supplied');
	}
};

// http://ecma-international.org/ecma-262/5.1/#sec-9.1
var es5 = function ToPrimitive(input) {
	if (isPrimitive(input)) {
		return input;
	}
	if (arguments.length > 1) {
		return ES5internalSlots['[[DefaultValue]]'](input, arguments[1]);
	}
	return ES5internalSlots['[[DefaultValue]]'](input);
};

var $Object = GetIntrinsic('%Object%');
var $TypeError$1 = GetIntrinsic('%TypeError%');
var $String = GetIntrinsic('%String%');













// https://es5.github.io/#x9
var ES5 = {
	ToPrimitive: es5,

	ToBoolean: function ToBoolean(value) {
		return !!value;
	},
	ToNumber: function ToNumber(value) {
		return +value; // eslint-disable-line no-implicit-coercion
	},
	ToInteger: function ToInteger(value) {
		var number = this.ToNumber(value);
		if (_isNaN(number)) { return 0; }
		if (number === 0 || !_isFinite(number)) { return number; }
		return sign(number) * Math.floor(Math.abs(number));
	},
	ToInt32: function ToInt32(x) {
		return this.ToNumber(x) >> 0;
	},
	ToUint32: function ToUint32(x) {
		return this.ToNumber(x) >>> 0;
	},
	ToUint16: function ToUint16(value) {
		var number = this.ToNumber(value);
		if (_isNaN(number) || number === 0 || !_isFinite(number)) { return 0; }
		var posInt = sign(number) * Math.floor(Math.abs(number));
		return mod(posInt, 0x10000);
	},
	ToString: function ToString(value) {
		return $String(value);
	},
	ToObject: function ToObject(value) {
		this.CheckObjectCoercible(value);
		return $Object(value);
	},
	CheckObjectCoercible: function CheckObjectCoercible(value, optMessage) {
		/* jshint eqnull:true */
		if (value == null) {
			throw new $TypeError$1(optMessage || 'Cannot call method on ' + value);
		}
		return value;
	},
	IsCallable: isCallable,
	SameValue: function SameValue(x, y) {
		if (x === y) { // 0 === -0, but they are not identical.
			if (x === 0) { return 1 / x === 1 / y; }
			return true;
		}
		return _isNaN(x) && _isNaN(y);
	},

	// https://www.ecma-international.org/ecma-262/5.1/#sec-8
	Type: function Type(x) {
		if (x === null) {
			return 'Null';
		}
		if (typeof x === 'undefined') {
			return 'Undefined';
		}
		if (typeof x === 'function' || typeof x === 'object') {
			return 'Object';
		}
		if (typeof x === 'number') {
			return 'Number';
		}
		if (typeof x === 'boolean') {
			return 'Boolean';
		}
		if (typeof x === 'string') {
			return 'String';
		}
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type
	IsPropertyDescriptor: function IsPropertyDescriptor(Desc) {
		if (this.Type(Desc) !== 'Object') {
			return false;
		}
		var allowed = {
			'[[Configurable]]': true,
			'[[Enumerable]]': true,
			'[[Get]]': true,
			'[[Set]]': true,
			'[[Value]]': true,
			'[[Writable]]': true
		};

		for (var key in Desc) { // eslint-disable-line
			if (src(Desc, key) && !allowed[key]) {
				return false;
			}
		}

		var isData = src(Desc, '[[Value]]');
		var IsAccessor = src(Desc, '[[Get]]') || src(Desc, '[[Set]]');
		if (isData && IsAccessor) {
			throw new $TypeError$1('Property Descriptors may not be both accessor and data descriptors');
		}
		return true;
	},

	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.1
	IsAccessorDescriptor: function IsAccessorDescriptor(Desc) {
		if (typeof Desc === 'undefined') {
			return false;
		}

		assertRecord(this, 'Property Descriptor', 'Desc', Desc);

		if (!src(Desc, '[[Get]]') && !src(Desc, '[[Set]]')) {
			return false;
		}

		return true;
	},

	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.2
	IsDataDescriptor: function IsDataDescriptor(Desc) {
		if (typeof Desc === 'undefined') {
			return false;
		}

		assertRecord(this, 'Property Descriptor', 'Desc', Desc);

		if (!src(Desc, '[[Value]]') && !src(Desc, '[[Writable]]')) {
			return false;
		}

		return true;
	},

	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.3
	IsGenericDescriptor: function IsGenericDescriptor(Desc) {
		if (typeof Desc === 'undefined') {
			return false;
		}

		assertRecord(this, 'Property Descriptor', 'Desc', Desc);

		if (!this.IsAccessorDescriptor(Desc) && !this.IsDataDescriptor(Desc)) {
			return true;
		}

		return false;
	},

	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.4
	FromPropertyDescriptor: function FromPropertyDescriptor(Desc) {
		if (typeof Desc === 'undefined') {
			return Desc;
		}

		assertRecord(this, 'Property Descriptor', 'Desc', Desc);

		if (this.IsDataDescriptor(Desc)) {
			return {
				value: Desc['[[Value]]'],
				writable: !!Desc['[[Writable]]'],
				enumerable: !!Desc['[[Enumerable]]'],
				configurable: !!Desc['[[Configurable]]']
			};
		} else if (this.IsAccessorDescriptor(Desc)) {
			return {
				get: Desc['[[Get]]'],
				set: Desc['[[Set]]'],
				enumerable: !!Desc['[[Enumerable]]'],
				configurable: !!Desc['[[Configurable]]']
			};
		} else {
			throw new $TypeError$1('FromPropertyDescriptor must be called with a fully populated Property Descriptor');
		}
	},

	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.5
	ToPropertyDescriptor: function ToPropertyDescriptor(Obj) {
		if (this.Type(Obj) !== 'Object') {
			throw new $TypeError$1('ToPropertyDescriptor requires an object');
		}

		var desc = {};
		if (src(Obj, 'enumerable')) {
			desc['[[Enumerable]]'] = this.ToBoolean(Obj.enumerable);
		}
		if (src(Obj, 'configurable')) {
			desc['[[Configurable]]'] = this.ToBoolean(Obj.configurable);
		}
		if (src(Obj, 'value')) {
			desc['[[Value]]'] = Obj.value;
		}
		if (src(Obj, 'writable')) {
			desc['[[Writable]]'] = this.ToBoolean(Obj.writable);
		}
		if (src(Obj, 'get')) {
			var getter = Obj.get;
			if (typeof getter !== 'undefined' && !this.IsCallable(getter)) {
				throw new TypeError('getter must be a function');
			}
			desc['[[Get]]'] = getter;
		}
		if (src(Obj, 'set')) {
			var setter = Obj.set;
			if (typeof setter !== 'undefined' && !this.IsCallable(setter)) {
				throw new $TypeError$1('setter must be a function');
			}
			desc['[[Set]]'] = setter;
		}

		if ((src(desc, '[[Get]]') || src(desc, '[[Set]]')) && (src(desc, '[[Value]]') || src(desc, '[[Writable]]'))) {
			throw new $TypeError$1('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
		}
		return desc;
	}
};

var es5$1 = ES5;

var regexExec = RegExp.prototype.exec;
var gOPD = Object.getOwnPropertyDescriptor;

var tryRegexExecCall = function tryRegexExec(value) {
	try {
		var lastIndex = value.lastIndex;
		value.lastIndex = 0;

		regexExec.call(value);
		return true;
	} catch (e) {
		return false;
	} finally {
		value.lastIndex = lastIndex;
	}
};
var toStr$7 = Object.prototype.toString;
var regexClass = '[object RegExp]';
var hasToStringTag$2 = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

var isRegex = function isRegex(value) {
	if (!value || typeof value !== 'object') {
		return false;
	}
	if (!hasToStringTag$2) {
		return toStr$7.call(value) === regexClass;
	}

	var descriptor = gOPD(value, 'lastIndex');
	var hasLastIndexDataProperty = descriptor && src(descriptor, 'value');
	if (!hasLastIndexDataProperty) {
		return false;
	}

	return tryRegexExecCall(value);
};

var $TypeError$2 = GetIntrinsic('%TypeError%');
var $SyntaxError$1 = GetIntrinsic('%SyntaxError%');
var $Array = GetIntrinsic('%Array%');
var $String$1 = GetIntrinsic('%String%');
var $Object$1 = GetIntrinsic('%Object%');
var $Number = GetIntrinsic('%Number%');
var $Symbol = GetIntrinsic('%Symbol%', true);
var $RegExp = GetIntrinsic('%RegExp%');

var hasSymbols$4 = !!$Symbol;




var MAX_SAFE_INTEGER = $Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;





var parseInteger = parseInt;

var arraySlice = functionBind.call(Function.call, $Array.prototype.slice);
var strSlice = functionBind.call(Function.call, $String$1.prototype.slice);
var isBinary = functionBind.call(Function.call, $RegExp.prototype.test, /^0b[01]+$/i);
var isOctal = functionBind.call(Function.call, $RegExp.prototype.test, /^0o[0-7]+$/i);
var regexExec$1 = functionBind.call(Function.call, $RegExp.prototype.exec);
var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
var hasNonWS = functionBind.call(Function.call, $RegExp.prototype.test, nonWSregex);
var invalidHexLiteral = /^[-+]0x[0-9a-f]+$/i;
var isInvalidHexLiteral = functionBind.call(Function.call, $RegExp.prototype.test, invalidHexLiteral);
var $charCodeAt = functionBind.call(Function.call, $String$1.prototype.charCodeAt);

var toStr$8 = functionBind.call(Function.call, Object.prototype.toString);

var $NumberValueOf = functionBind.call(Function.call, GetIntrinsic('%NumberPrototype%').valueOf);
var $BooleanValueOf = functionBind.call(Function.call, GetIntrinsic('%BooleanPrototype%').valueOf);
var $StringValueOf = functionBind.call(Function.call, GetIntrinsic('%StringPrototype%').valueOf);
var $DateValueOf = functionBind.call(Function.call, GetIntrinsic('%DatePrototype%').valueOf);

var $floor = Math.floor;
var $abs = Math.abs;

var $ObjectCreate = Object.create;
var $gOPD = $Object$1.getOwnPropertyDescriptor;

var $isExtensible = $Object$1.isExtensible;

var $defineProperty = $Object$1.defineProperty;

// whitespace from: http://es5.github.io/#x15.5.4.20
// implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
var ws = [
	'\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
	'\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
	'\u2029\uFEFF'
].join('');
var trimRegex = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
var replace = functionBind.call(Function.call, $String$1.prototype.replace);
var trim = function (value) {
	return replace(value, trimRegex, '');
};





// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-abstract-operations
var ES6 = assign(assign({}, es5$1), {

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args
	Call: function Call(F, V) {
		var args = arguments.length > 2 ? arguments[2] : [];
		if (!this.IsCallable(F)) {
			throw new $TypeError$2(F + ' is not a function');
		}
		return F.apply(V, args);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toprimitive
	ToPrimitive: es6,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toboolean
	// ToBoolean: ES5.ToBoolean,

	// https://ecma-international.org/ecma-262/6.0/#sec-tonumber
	ToNumber: function ToNumber(argument) {
		var value = isPrimitive$1(argument) ? argument : es6(argument, $Number);
		if (typeof value === 'symbol') {
			throw new $TypeError$2('Cannot convert a Symbol value to a number');
		}
		if (typeof value === 'string') {
			if (isBinary(value)) {
				return this.ToNumber(parseInteger(strSlice(value, 2), 2));
			} else if (isOctal(value)) {
				return this.ToNumber(parseInteger(strSlice(value, 2), 8));
			} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
				return NaN;
			} else {
				var trimmed = trim(value);
				if (trimmed !== value) {
					return this.ToNumber(trimmed);
				}
			}
		}
		return $Number(value);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tointeger
	// ToInteger: ES5.ToNumber,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint32
	// ToInt32: ES5.ToInt32,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint32
	// ToUint32: ES5.ToUint32,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint16
	ToInt16: function ToInt16(argument) {
		var int16bit = this.ToUint16(argument);
		return int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint16
	// ToUint16: ES5.ToUint16,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint8
	ToInt8: function ToInt8(argument) {
		var int8bit = this.ToUint8(argument);
		return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8
	ToUint8: function ToUint8(argument) {
		var number = this.ToNumber(argument);
		if (_isNaN(number) || number === 0 || !_isFinite(number)) { return 0; }
		var posInt = sign(number) * $floor($abs(number));
		return mod(posInt, 0x100);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8clamp
	ToUint8Clamp: function ToUint8Clamp(argument) {
		var number = this.ToNumber(argument);
		if (_isNaN(number) || number <= 0) { return 0; }
		if (number >= 0xFF) { return 0xFF; }
		var f = $floor(argument);
		if (f + 0.5 < number) { return f + 1; }
		if (number < f + 0.5) { return f; }
		if (f % 2 !== 0) { return f + 1; }
		return f;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tostring
	ToString: function ToString(argument) {
		if (typeof argument === 'symbol') {
			throw new $TypeError$2('Cannot convert a Symbol value to a string');
		}
		return $String$1(argument);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toobject
	ToObject: function ToObject(value) {
		this.RequireObjectCoercible(value);
		return $Object$1(value);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-topropertykey
	ToPropertyKey: function ToPropertyKey(argument) {
		var key = this.ToPrimitive(argument, $String$1);
		return typeof key === 'symbol' ? key : this.ToString(key);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	ToLength: function ToLength(argument) {
		var len = this.ToInteger(argument);
		if (len <= 0) { return 0; } // includes converting -0 to +0
		if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
		return len;
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-canonicalnumericindexstring
	CanonicalNumericIndexString: function CanonicalNumericIndexString(argument) {
		if (toStr$8(argument) !== '[object String]') {
			throw new $TypeError$2('must be a string');
		}
		if (argument === '-0') { return -0; }
		var n = this.ToNumber(argument);
		if (this.SameValue(this.ToString(n), argument)) { return n; }
		return void 0;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-requireobjectcoercible
	RequireObjectCoercible: es5$1.CheckObjectCoercible,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isarray
	IsArray: $Array.isArray || function IsArray(argument) {
		return toStr$8(argument) === '[object Array]';
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-iscallable
	// IsCallable: ES5.IsCallable,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isconstructor
	IsConstructor: function IsConstructor(argument) {
		return typeof argument === 'function' && !!argument.prototype; // unfortunately there's no way to truly check this without try/catch `new argument`
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isextensible-o
	IsExtensible: Object.preventExtensions
		? function IsExtensible(obj) {
			if (isPrimitive$1(obj)) {
				return false;
			}
			return $isExtensible(obj);
		}
		: function isExtensible(obj) { return true; }, // eslint-disable-line no-unused-vars

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isinteger
	IsInteger: function IsInteger(argument) {
		if (typeof argument !== 'number' || _isNaN(argument) || !_isFinite(argument)) {
			return false;
		}
		var abs = $abs(argument);
		return $floor(abs) === abs;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ispropertykey
	IsPropertyKey: function IsPropertyKey(argument) {
		return typeof argument === 'string' || typeof argument === 'symbol';
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-isregexp
	IsRegExp: function IsRegExp(argument) {
		if (!argument || typeof argument !== 'object') {
			return false;
		}
		if (hasSymbols$4) {
			var isRegExp = argument[$Symbol.match];
			if (typeof isRegExp !== 'undefined') {
				return es5$1.ToBoolean(isRegExp);
			}
		}
		return isRegex(argument);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevalue
	// SameValue: ES5.SameValue,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero
	SameValueZero: function SameValueZero(x, y) {
		return (x === y) || (_isNaN(x) && _isNaN(y));
	},

	/**
	 * 7.3.2 GetV (V, P)
	 * 1. Assert: IsPropertyKey(P) is true.
	 * 2. Let O be ToObject(V).
	 * 3. ReturnIfAbrupt(O).
	 * 4. Return O.[[Get]](P, V).
	 */
	GetV: function GetV(V, P) {
		// 7.3.2.1
		if (!this.IsPropertyKey(P)) {
			throw new $TypeError$2('Assertion failed: IsPropertyKey(P) is not true');
		}

		// 7.3.2.2-3
		var O = this.ToObject(V);

		// 7.3.2.4
		return O[P];
	},

	/**
	 * 7.3.9 - https://ecma-international.org/ecma-262/6.0/#sec-getmethod
	 * 1. Assert: IsPropertyKey(P) is true.
	 * 2. Let func be GetV(O, P).
	 * 3. ReturnIfAbrupt(func).
	 * 4. If func is either undefined or null, return undefined.
	 * 5. If IsCallable(func) is false, throw a TypeError exception.
	 * 6. Return func.
	 */
	GetMethod: function GetMethod(O, P) {
		// 7.3.9.1
		if (!this.IsPropertyKey(P)) {
			throw new $TypeError$2('Assertion failed: IsPropertyKey(P) is not true');
		}

		// 7.3.9.2
		var func = this.GetV(O, P);

		// 7.3.9.4
		if (func == null) {
			return void 0;
		}

		// 7.3.9.5
		if (!this.IsCallable(func)) {
			throw new $TypeError$2(P + 'is not a function');
		}

		// 7.3.9.6
		return func;
	},

	/**
	 * 7.3.1 Get (O, P) - https://ecma-international.org/ecma-262/6.0/#sec-get-o-p
	 * 1. Assert: Type(O) is Object.
	 * 2. Assert: IsPropertyKey(P) is true.
	 * 3. Return O.[[Get]](P, O).
	 */
	Get: function Get(O, P) {
		// 7.3.1.1
		if (this.Type(O) !== 'Object') {
			throw new $TypeError$2('Assertion failed: Type(O) is not Object');
		}
		// 7.3.1.2
		if (!this.IsPropertyKey(P)) {
			throw new $TypeError$2('Assertion failed: IsPropertyKey(P) is not true');
		}
		// 7.3.1.3
		return O[P];
	},

	Type: function Type(x) {
		if (typeof x === 'symbol') {
			return 'Symbol';
		}
		return es5$1.Type(x);
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-speciesconstructor
	SpeciesConstructor: function SpeciesConstructor(O, defaultConstructor) {
		if (this.Type(O) !== 'Object') {
			throw new $TypeError$2('Assertion failed: Type(O) is not Object');
		}
		var C = O.constructor;
		if (typeof C === 'undefined') {
			return defaultConstructor;
		}
		if (this.Type(C) !== 'Object') {
			throw new $TypeError$2('O.constructor is not an Object');
		}
		var S = hasSymbols$4 && $Symbol.species ? C[$Symbol.species] : void 0;
		if (S == null) {
			return defaultConstructor;
		}
		if (this.IsConstructor(S)) {
			return S;
		}
		throw new $TypeError$2('no constructor found');
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-completepropertydescriptor
	CompletePropertyDescriptor: function CompletePropertyDescriptor(Desc) {
		assertRecord(this, 'Property Descriptor', 'Desc', Desc);

		if (this.IsGenericDescriptor(Desc) || this.IsDataDescriptor(Desc)) {
			if (!src(Desc, '[[Value]]')) {
				Desc['[[Value]]'] = void 0;
			}
			if (!src(Desc, '[[Writable]]')) {
				Desc['[[Writable]]'] = false;
			}
		} else {
			if (!src(Desc, '[[Get]]')) {
				Desc['[[Get]]'] = void 0;
			}
			if (!src(Desc, '[[Set]]')) {
				Desc['[[Set]]'] = void 0;
			}
		}
		if (!src(Desc, '[[Enumerable]]')) {
			Desc['[[Enumerable]]'] = false;
		}
		if (!src(Desc, '[[Configurable]]')) {
			Desc['[[Configurable]]'] = false;
		}
		return Desc;
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-set-o-p-v-throw
	Set: function Set(O, P, V, Throw) {
		if (this.Type(O) !== 'Object') {
			throw new $TypeError$2('O must be an Object');
		}
		if (!this.IsPropertyKey(P)) {
			throw new $TypeError$2('P must be a Property Key');
		}
		if (this.Type(Throw) !== 'Boolean') {
			throw new $TypeError$2('Throw must be a Boolean');
		}
		if (Throw) {
			O[P] = V;
			return true;
		} else {
			try {
				O[P] = V;
			} catch (e) {
				return false;
			}
		}
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-hasownproperty
	HasOwnProperty: function HasOwnProperty(O, P) {
		if (this.Type(O) !== 'Object') {
			throw new $TypeError$2('O must be an Object');
		}
		if (!this.IsPropertyKey(P)) {
			throw new $TypeError$2('P must be a Property Key');
		}
		return src(O, P);
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-hasproperty
	HasProperty: function HasProperty(O, P) {
		if (this.Type(O) !== 'Object') {
			throw new $TypeError$2('O must be an Object');
		}
		if (!this.IsPropertyKey(P)) {
			throw new $TypeError$2('P must be a Property Key');
		}
		return P in O;
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-isconcatspreadable
	IsConcatSpreadable: function IsConcatSpreadable(O) {
		if (this.Type(O) !== 'Object') {
			return false;
		}
		if (hasSymbols$4 && typeof $Symbol.isConcatSpreadable === 'symbol') {
			var spreadable = this.Get(O, Symbol.isConcatSpreadable);
			if (typeof spreadable !== 'undefined') {
				return this.ToBoolean(spreadable);
			}
		}
		return this.IsArray(O);
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-invoke
	Invoke: function Invoke(O, P) {
		if (!this.IsPropertyKey(P)) {
			throw new $TypeError$2('P must be a Property Key');
		}
		var argumentsList = arraySlice(arguments, 2);
		var func = this.GetV(O, P);
		return this.Call(func, O, argumentsList);
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-getiterator
	GetIterator: function GetIterator(obj, method) {
		if (!hasSymbols$4) {
			throw new SyntaxError('ES.GetIterator depends on native iterator support.');
		}

		var actualMethod = method;
		if (arguments.length < 2) {
			actualMethod = this.GetMethod(obj, $Symbol.iterator);
		}
		var iterator = this.Call(actualMethod, obj);
		if (this.Type(iterator) !== 'Object') {
			throw new $TypeError$2('iterator must return an object');
		}

		return iterator;
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-iteratornext
	IteratorNext: function IteratorNext(iterator, value) {
		var result = this.Invoke(iterator, 'next', arguments.length < 2 ? [] : [value]);
		if (this.Type(result) !== 'Object') {
			throw new $TypeError$2('iterator next must return an object');
		}
		return result;
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-iteratorcomplete
	IteratorComplete: function IteratorComplete(iterResult) {
		if (this.Type(iterResult) !== 'Object') {
			throw new $TypeError$2('Assertion failed: Type(iterResult) is not Object');
		}
		return this.ToBoolean(this.Get(iterResult, 'done'));
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-iteratorvalue
	IteratorValue: function IteratorValue(iterResult) {
		if (this.Type(iterResult) !== 'Object') {
			throw new $TypeError$2('Assertion failed: Type(iterResult) is not Object');
		}
		return this.Get(iterResult, 'value');
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-iteratorstep
	IteratorStep: function IteratorStep(iterator) {
		var result = this.IteratorNext(iterator);
		var done = this.IteratorComplete(result);
		return done === true ? false : result;
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-iteratorclose
	IteratorClose: function IteratorClose(iterator, completion) {
		if (this.Type(iterator) !== 'Object') {
			throw new $TypeError$2('Assertion failed: Type(iterator) is not Object');
		}
		if (!this.IsCallable(completion)) {
			throw new $TypeError$2('Assertion failed: completion is not a thunk for a Completion Record');
		}
		var completionThunk = completion;

		var iteratorReturn = this.GetMethod(iterator, 'return');

		if (typeof iteratorReturn === 'undefined') {
			return completionThunk();
		}

		var completionRecord;
		try {
			var innerResult = this.Call(iteratorReturn, iterator, []);
		} catch (e) {
			// if we hit here, then "e" is the innerResult completion that needs re-throwing

			// if the completion is of type "throw", this will throw.
			completionRecord = completionThunk();
			completionThunk = null; // ensure it's not called twice.

			// if not, then return the innerResult completion
			throw e;
		}
		completionRecord = completionThunk(); // if innerResult worked, then throw if the completion does
		completionThunk = null; // ensure it's not called twice.

		if (this.Type(innerResult) !== 'Object') {
			throw new $TypeError$2('iterator .return must return an object');
		}

		return completionRecord;
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-createiterresultobject
	CreateIterResultObject: function CreateIterResultObject(value, done) {
		if (this.Type(done) !== 'Boolean') {
			throw new $TypeError$2('Assertion failed: Type(done) is not Boolean');
		}
		return {
			value: value,
			done: done
		};
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-regexpexec
	RegExpExec: function RegExpExec(R, S) {
		if (this.Type(R) !== 'Object') {
			throw new $TypeError$2('R must be an Object');
		}
		if (this.Type(S) !== 'String') {
			throw new $TypeError$2('S must be a String');
		}
		var exec = this.Get(R, 'exec');
		if (this.IsCallable(exec)) {
			var result = this.Call(exec, R, [S]);
			if (result === null || this.Type(result) === 'Object') {
				return result;
			}
			throw new $TypeError$2('"exec" method must return `null` or an Object');
		}
		return regexExec$1(R, S);
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-arrayspeciescreate
	ArraySpeciesCreate: function ArraySpeciesCreate(originalArray, length) {
		if (!this.IsInteger(length) || length < 0) {
			throw new $TypeError$2('Assertion failed: length must be an integer >= 0');
		}
		var len = length === 0 ? 0 : length;
		var C;
		var isArray = this.IsArray(originalArray);
		if (isArray) {
			C = this.Get(originalArray, 'constructor');
			// TODO: figure out how to make a cross-realm normal Array, a same-realm Array
			// if (this.IsConstructor(C)) {
			// 	if C is another realm's Array, C = undefined
			// 	Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(Array))) === null ?
			// }
			if (this.Type(C) === 'Object' && hasSymbols$4 && $Symbol.species) {
				C = this.Get(C, $Symbol.species);
				if (C === null) {
					C = void 0;
				}
			}
		}
		if (typeof C === 'undefined') {
			return $Array(len);
		}
		if (!this.IsConstructor(C)) {
			throw new $TypeError$2('C must be a constructor');
		}
		return new C(len); // this.Construct(C, len);
	},

	CreateDataProperty: function CreateDataProperty(O, P, V) {
		if (this.Type(O) !== 'Object') {
			throw new $TypeError$2('Assertion failed: Type(O) is not Object');
		}
		if (!this.IsPropertyKey(P)) {
			throw new $TypeError$2('Assertion failed: IsPropertyKey(P) is not true');
		}
		var oldDesc = $gOPD(O, P);
		var extensible = oldDesc || (typeof $isExtensible !== 'function' || $isExtensible(O));
		var immutable = oldDesc && (!oldDesc.writable || !oldDesc.configurable);
		if (immutable || !extensible) {
			return false;
		}
		var newDesc = {
			configurable: true,
			enumerable: true,
			value: V,
			writable: true
		};
		$defineProperty(O, P, newDesc);
		return true;
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-createdatapropertyorthrow
	CreateDataPropertyOrThrow: function CreateDataPropertyOrThrow(O, P, V) {
		if (this.Type(O) !== 'Object') {
			throw new $TypeError$2('Assertion failed: Type(O) is not Object');
		}
		if (!this.IsPropertyKey(P)) {
			throw new $TypeError$2('Assertion failed: IsPropertyKey(P) is not true');
		}
		var success = this.CreateDataProperty(O, P, V);
		if (!success) {
			throw new $TypeError$2('unable to create data property');
		}
		return success;
	},

	// https://www.ecma-international.org/ecma-262/6.0/#sec-objectcreate
	ObjectCreate: function ObjectCreate(proto, internalSlotsList) {
		if (proto !== null && this.Type(proto) !== 'Object') {
			throw new $TypeError$2('Assertion failed: proto must be null or an object');
		}
		var slots = arguments.length < 2 ? [] : internalSlotsList;
		if (slots.length > 0) {
			throw new $SyntaxError$1('es-abstract does not yet support internal slots');
		}

		if (proto === null && !$ObjectCreate) {
			throw new $SyntaxError$1('native Object.create support is required to create null objects');
		}

		return $ObjectCreate(proto);
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-advancestringindex
	AdvanceStringIndex: function AdvanceStringIndex(S, index, unicode) {
		if (this.Type(S) !== 'String') {
			throw new $TypeError$2('S must be a String');
		}
		if (!this.IsInteger(index) || index < 0 || index > MAX_SAFE_INTEGER) {
			throw new $TypeError$2('Assertion failed: length must be an integer >= 0 and <= 2**53');
		}
		if (this.Type(unicode) !== 'Boolean') {
			throw new $TypeError$2('Assertion failed: unicode must be a Boolean');
		}
		if (!unicode) {
			return index + 1;
		}
		var length = S.length;
		if ((index + 1) >= length) {
			return index + 1;
		}

		var first = $charCodeAt(S, index);
		if (first < 0xD800 || first > 0xDBFF) {
			return index + 1;
		}

		var second = $charCodeAt(S, index + 1);
		if (second < 0xDC00 || second > 0xDFFF) {
			return index + 1;
		}

		return index + 2;
	},

	// https://www.ecma-international.org/ecma-262/6.0/#sec-createmethodproperty
	CreateMethodProperty: function CreateMethodProperty(O, P, V) {
		if (this.Type(O) !== 'Object') {
			throw new $TypeError$2('Assertion failed: Type(O) is not Object');
		}

		if (!this.IsPropertyKey(P)) {
			throw new $TypeError$2('Assertion failed: IsPropertyKey(P) is not true');
		}

		var newDesc = {
			configurable: true,
			enumerable: false,
			value: V,
			writable: true
		};
		return !!$defineProperty(O, P, newDesc);
	},

	// https://www.ecma-international.org/ecma-262/6.0/#sec-definepropertyorthrow
	DefinePropertyOrThrow: function DefinePropertyOrThrow(O, P, desc) {
		if (this.Type(O) !== 'Object') {
			throw new $TypeError$2('Assertion failed: Type(O) is not Object');
		}

		if (!this.IsPropertyKey(P)) {
			throw new $TypeError$2('Assertion failed: IsPropertyKey(P) is not true');
		}

		return !!$defineProperty(O, P, desc);
	},

	// https://www.ecma-international.org/ecma-262/6.0/#sec-deletepropertyorthrow
	DeletePropertyOrThrow: function DeletePropertyOrThrow(O, P) {
		if (this.Type(O) !== 'Object') {
			throw new $TypeError$2('Assertion failed: Type(O) is not Object');
		}

		if (!this.IsPropertyKey(P)) {
			throw new $TypeError$2('Assertion failed: IsPropertyKey(P) is not true');
		}

		var success = delete O[P];
		if (!success) {
			throw new TypeError('Attempt to delete property failed.');
		}
		return success;
	},

	// https://www.ecma-international.org/ecma-262/6.0/#sec-enumerableownnames
	EnumerableOwnNames: function EnumerableOwnNames(O) {
		if (this.Type(O) !== 'Object') {
			throw new $TypeError$2('Assertion failed: Type(O) is not Object');
		}

		return objectKeys(O);
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-number-prototype-object
	thisNumberValue: function thisNumberValue(value) {
		if (this.Type(value) === 'Number') {
			return value;
		}

		return $NumberValueOf(value);
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-boolean-prototype-object
	thisBooleanValue: function thisBooleanValue(value) {
		if (this.Type(value) === 'Boolean') {
			return value;
		}

		return $BooleanValueOf(value);
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-string-prototype-object
	thisStringValue: function thisStringValue(value) {
		if (this.Type(value) === 'String') {
			return value;
		}

		return $StringValueOf(value);
	},

	// https://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-date-prototype-object
	thisTimeValue: function thisTimeValue(value) {
		return $DateValueOf(value);
	}
});

delete ES6.CheckObjectCoercible; // renamed in ES6 to RequireObjectCoercible

var es2015$1 = ES6;

var es6$1 = es2015$1;

var $isNaN$1 = Number.isNaN || function isNaN(a) {
	return a !== a;
};
var $isFinite = Number.isFinite || function isFinite(n) {
	return typeof n === 'number' && commonjsGlobal.isFinite(n);
};
var indexOf = Array.prototype.indexOf;

var implementation$2 = function includes(searchElement) {
	var fromIndex = arguments.length > 1 ? es6$1.ToInteger(arguments[1]) : 0;
	if (indexOf && !$isNaN$1(searchElement) && $isFinite(fromIndex) && typeof searchElement !== 'undefined') {
		return indexOf.apply(this, arguments) > -1;
	}

	var O = es6$1.ToObject(this);
	var length = es6$1.ToLength(O.length);
	if (length === 0) {
		return false;
	}
	var k = fromIndex >= 0 ? fromIndex : Math.max(0, length + fromIndex);
	while (k < length) {
		if (es6$1.SameValueZero(searchElement, O[k])) {
			return true;
		}
		k += 1;
	}
	return false;
};

var polyfill = function getPolyfill() {
	return Array.prototype.includes || implementation$2;
};

var shim = function shimArrayPrototypeIncludes() {
	var polyfill$$1 = polyfill();
	defineProperties_1(
		Array.prototype,
		{ includes: polyfill$$1 },
		{ includes: function () { return Array.prototype.includes !== polyfill$$1; } }
	);
	return polyfill$$1;
};

var polyfill$1 = polyfill();


var slice$2 = Array.prototype.slice;

/* eslint-disable no-unused-vars */
var boundIncludesShim = function includes(array, searchElement) {
/* eslint-enable no-unused-vars */
	es6$1.RequireObjectCoercible(array);
	return polyfill$1.apply(array, slice$2.call(arguments, 1));
};
defineProperties_1(boundIncludesShim, {
	getPolyfill: polyfill,
	implementation: implementation$2,
	shim: shim
});

var arrayIncludes = boundIncludesShim;

function some(str, callback) {
	return Array.prototype.some.call(str, callback);
}

var stringSome = some;

const jouyouKanji = joyoKanji.kanji;




//////// CHARACTER ANALYSIS ////////

// determine whether a character is a hiragana character
function isHiragana(ch) {
    return ch >= "\u3040" && ch <= "\u309f";
}

// determine whether a character is a katakana character
function isKatakana(ch) {
    return ch >= "\u30a0" && ch <= "\u30ff";
}

// determine whether a character is a kana character
function isKana(ch) {
    return isHiragana(ch) || isKatakana(ch);
}

// determine whether a character is a Japanese character
function isJapanese(ch) {
    return isKana(ch) || iskanji(ch);
}

// determine whether a character is a kyouiku kanji character
function isKyouikuKanji(ch) {
    return arrayIncludes(kyoikuKanji.grade1, ch) ||
    arrayIncludes(kyoikuKanji.grade2, ch) ||
    arrayIncludes(kyoikuKanji.grade3, ch) ||
    arrayIncludes(kyoikuKanji.grade4, ch) ||
    arrayIncludes(kyoikuKanji.grade5, ch) ||
    arrayIncludes(kyoikuKanji.grade6, ch);
}

// determine whether a character is a jouyou kanji character
function isJouyouKanji(ch) {
    return arrayIncludes(jouyouKanji, ch);
}

// return the grade of a kyouiku kanji
function getKyouikuGrade(ch) {
    let grade;

    if (arrayIncludes(kyoikuKanji.grade1, ch)) {
        grade = 1;
    }
    else if (arrayIncludes(kyoikuKanji.grade2, ch)) {
        grade = 2;
    }
    else if (arrayIncludes(kyoikuKanji.grade3, ch)) {
        grade = 3;
    }
    else if (arrayIncludes(kyoikuKanji.grade4, ch)) {
        grade = 4;
    }
    else if (arrayIncludes(kyoikuKanji.grade5, ch)) {
        grade = 5;
    }
    else if (arrayIncludes(kyoikuKanji.grade6, ch)) {
        grade = 6;
    }

    return grade;
}

//////// SENTENCE ANALYSIS ////////

// determine whether a string contains hiragana characters
function hasHiragana(str) {
    return stringSome(str, isHiragana);
}

// determine whether a string contains katakana characters
function hasKatakana(str) {
    return stringSome(str, isKatakana);
}

// determine whether a string contains kana characters
function hasKana(str) {
    return stringSome(str, isKana);
}

function hasKanji(str) {
    return stringSome(str, iskanji);
}

// determine whether a string contains Japanese characters
function hasJapanese(str) {
    return stringSome(str, isJapanese);
}

// determine whether a string contains hiragana, katakana or kanji characters
function contains(str) {
    return {
        hiragana: hasHiragana(str),
        katakana: hasKatakana(str),
        kanji: hasKanji(str)
    };
}

var analysers = {
    // CHARACTER ANALYSIS
    isHiragana: isHiragana,
    isKatakana: isKatakana,
    isKana: isKana,
    isKanji: iskanji,
    isJapanese: isJapanese,
    isKyouikuKanji: isKyouikuKanji,
    isJouyouKanji: isJouyouKanji,
    getKyouikuGrade: getKyouikuGrade,

    // SENTENCE ANALYSIS
    hasHiragana: hasHiragana,
    hasKatakana: hasKatakana,
    hasKana: hasKana,
    hasKanji: hasKanji,
    hasJapanese: hasJapanese,
    contains: contains
};

// returns an array of all characters in a string that fulfill a condition
function basicParser(str, condition) {
    let result = [];

    for (let i = 0; i < str.length; ++i) {
        if (condition(str[i])) {
            result.push(str[i]);
        }
    }

    return result;
}

// returns an array of all sequences of characters in a string that fulfill
// a condition
function accumulativeParser(str, condition) {
    let accumulations = [];
    let accumulator = "";

    for (let i = 0; i < str.length; ++i) {
        let ch = str[i];

        if (condition(ch)) {
            accumulator += ch;
        } else if (accumulator !== "") {
            accumulations.push(accumulator);
            accumulator = "";
        }
    }

    return accumulations;
}

// return array of all hiragana in a string
function parseHiragana(str) {
    return basicParser(str, analysers.isHiragana);
}

// return array of all katakana in a string
function parseKatakana(str) {
    return basicParser(str, analysers.isKatakana);
}

// return array of all kana in a string
function parseKana(str) {
    return basicParser(str, analysers.isKana);
}

// return array of all kanji in a string
function parseKanji(str) {
    return basicParser(str, analysers.isKanji);
}

// return array of all kanji compounds in a string
function parseKanjiCompounds(str) {
    return accumulativeParser(str, analysers.isKanji);
}

// return an array of all sections of Japanese in a string
function parseJapanese(str) {
    return accumulativeParser(str, analysers.isJapanese);
}

var parsers = {
    parseHiragana: parseHiragana,
    parseKatakana: parseKatakana,
    parseKana: parseKana,
    parseKanji: parseKanji,
    parseKanjiCompounds: parseKanjiCompounds,
    parseJapanese: parseJapanese
};

const nihongo = {
	// Character analysis
	isHiragana: analysers.isHiragana,
	isKatakana: analysers.isKatakana,
	isKana: analysers.isKana,
	isKanji: analysers.isKanji,
	isJapanese: analysers.isJapanese,
	isKyouikuKanji: analysers.isKyouikuKanji,
	isJouyouKanji: analysers.isJouyouKanji,
	getKyouikuGrade: analysers.getKyouikuGrade,

	// Sentence analysis
	hasHiragana: analysers.hasHiragana,
	hasKatakana: analysers.hasKatakana,
	hasKana: analysers.hasKana,
	hasKanji: analysers.hasKanji,
	hasJapanese: analysers.hasJapanese,
	contains: analysers.contains,

	// Parsers
	parseHiragana: parsers.parseHiragana,
	parseKatakana: parsers.parseKatakana,
	parseKana: parsers.parseKana,
	parseKanji: parsers.parseKanji,
	parseKanjiCompounds: parsers.parseKanjiCompounds,
	parseJapanese: parsers.parseJapanese
};

var nihongo_1 = nihongo;

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css = "/* add css styles here (optional) */\n\n.styles_wrapper__3KXDn {\n  display: inline-block;\n  font-size: inherit;\n  margin-top: 1em;\n  position: relative;\n  line-height: 1.6;\n}\n.styles_furigana__2LmT- {\n  position: absolute;\n  top: -42%;\n  font-size: 35%;\n  width: 100%;\n  text-align: center;\n}\n.styles_kanji__mZwvl {}\n.styles_kanjiWrapper__oRTOU {\n  position: relative;\n}\n";
var styles = {"wrapper":"styles_wrapper__3KXDn","furigana":"styles_furigana__2LmT-","kanji":"styles_kanji__mZwvl","kanjiWrapper":"styles_kanjiWrapper__oRTOU"};
styleInject(css);

var Kanji = /** @class */ (function (_super) {
    __extends(Kanji, _super);
    function Kanji() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Kanji.prototype.render = function () {
        var _a = this.props, styles = _a.styles, spacing = _a.spacing, kanji = _a.kanji, furigana = _a.furigana, opacity = _a.opacity;
        var componentClass = "kanji-soshi " + styles.kanjiWrapper;
        var furiganaClassNames = "furigana-tag " + styles.furigana;
        var kanjiClassNames = "kanji-tag " + styles.kanji;
        return (createElement("span", { className: componentClass, style: { padding: spacing.kanji } },
            createElement("sup", { style: { left: spacing.furigana, opacity: opacity }, className: furiganaClassNames }, furigana),
            createElement("span", { className: kanjiClassNames }, kanji)));
    };
    return Kanji;
}(Component));

/**
 * @class ExampleComponent
 */
function getSpacing(kanji, furigana, spacingUnit) {
    if (spacingUnit === void 0) { spacingUnit = 6; }
    var kanjiLength = furigana ? nihongo_1.parseKanji(kanji).length : 0;
    var furiganaLength = furigana ? nihongo_1.parseHiragana(furigana).length : 0;
    var lengthDif = Math.abs(furiganaLength - kanjiLength);
    var spacing = (lengthDif * spacingUnit) / 2;
    return {
        kanji: "0 " + spacing + "px",
        furigana: "0px" //TODO testing of spacing `-${spacing/marginMulti-1}px`
    };
}
var Furigana = /** @class */ (function (_super) {
    __extends(Furigana, _super);
    function Furigana(props) {
        var _this = _super.call(this, props) || this;
        _this.state = {
            furigana: '',
            foundKanji: [],
            renderedString: null
        };
        return _this;
    }
    Furigana.prototype.isText = function (text) {
        return typeof text === 'string';
    };
    Furigana.prototype.buildFuri = function () {
        var parsed = this.parseChild();
        var matched = this.matchKanji(parsed);
        var cutChildren = this.cutChildren();
        var renderString = this.buildRender(cutChildren, matched);
        return renderString;
    };
    Furigana.prototype.parseChild = function () {
        var children = this.props.children;
        if (this.isText(children)) {
            return {
                foundKanji: nihongo_1.parseKanjiCompounds(children),
                furigana: this.props.furigana.split(':')
            };
        }
        else {
            console.error('only text for now');
            return {
                foundKanji: [],
                furigana: []
            };
        }
    };
    Furigana.prototype.matchKanji = function (parsed) {
        var foundKanji = parsed.foundKanji, furigana = parsed.furigana;
        return foundKanji.map(function (kanji, i) {
            //TODO add kanji length here
            return { kanji: kanji, furigana: furigana[i] };
        });
    };
    Furigana.prototype.cutChildren = function () {
        var kanjiList = nihongo_1.parseKanjiCompounds(this.props.children);
        var cleanText = this.props.children;
        kanjiList.map(function (kanji) {
            return cleanText = cleanText.replace(kanji, '#|#');
        });
        return cleanText.split('#|#');
    };
    Furigana.prototype.buildRender = function (cutChildren, matchedKanji) {
        var _this = this;
        return (createElement(Fragment, null, cutChildren.map(function (text, i) {
            var item = matchedKanji[i];
            if (typeof item === 'undefined') {
                return createElement("span", { key: text + i }, text);
            }
            var spacing = getSpacing(item.kanji, item.furigana, _this.props.spacingUnit);
            if (text === "") {
                return (createElement(Kanji, { opacity: _this.props.opacity, key: item.kanji + text + i, spacing: spacing, kanji: item.kanji, furigana: item.furigana, styles: styles }));
            }
            else {
                return (createElement("span", { key: item.kanji + text + i },
                    createElement("span", null, text),
                    createElement(Kanji, { opacity: _this.props.opacity, spacing: spacing, kanji: item.kanji, furigana: item.furigana, styles: styles })));
            }
        })));
    };
    Furigana.prototype.render = function () {
        return (createElement("span", { id: this.props.id, className: styles.wrapper }, this.buildFuri()));
    };
    return Furigana;
}(Component));

export { Furigana };
//# sourceMappingURL=index.es.js.map
