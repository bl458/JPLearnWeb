import React from 'react';
import 'prop-types';
import styled from 'styled-components';

/**
 * Returns detailed type as string (instead of just 'object' for arrays etc)
 * @private
 * @param {any} value js value
 * @returns {String} type of value
 * @example
 * typeOf({}); // 'object'
 * typeOf([]); // 'array'
 * typeOf(function() {}); // 'function'
 * typeOf(/a/); // 'regexp'
 * typeOf(new Date()); // 'date'
 * typeOf(null); // 'null'
 * typeOf(undefined); // 'undefined'
 * typeOf('a'); // 'string'
 * typeOf(1); // 'number'
 * typeOf(true); // 'boolean'
 * typeOf(new Map()); // 'map'
 * typeOf(new Set()); // 'map'
 */
function typeOf(value) {
  if (value === null) {
    return 'null';
  }
  if (value !== Object(value)) {
    return typeof value;
  }
  return {}.toString.call(value).slice(8, -1).toLowerCase();
}

/**
 * Checks if input string is empty
 * @param  {String} input text input
 * @return {Boolean} true if no input
 */
function isEmpty(input) {
  if (typeOf(input) !== 'string') {
    return true;
  }
  return !input.length;
}

/**
 * Takes a character and a unicode range. Returns true if the char is in the range.
 * @param  {String}  char  unicode character
 * @param  {Number}  start unicode start range
 * @param  {Number}  end   unicode end range
 * @return {Boolean}
 */
function isCharInRange(char = '', start, end) {
  if (isEmpty(char)) return false;
  const code = char.charCodeAt(0);
  return start <= code && code <= end;
}

const LOWERCASE_ZENKAKU_START = 0xff41;
const LOWERCASE_ZENKAKU_END = 0xff5a;
const UPPERCASE_ZENKAKU_START = 0xff21;
const UPPERCASE_ZENKAKU_END = 0xff3a;
const HIRAGANA_START = 0x3041;
const HIRAGANA_END = 0x3096;
const KATAKANA_START = 0x30a1;
const KATAKANA_END = 0x30fc;
const KANJI_START = 0x4e00;
const KANJI_END = 0x9faf;
const PROLONGED_SOUND_MARK = 0x30fc;

const ZENKAKU_NUMBERS = [0xff10, 0xff19];
const ZENKAKU_UPPERCASE = [UPPERCASE_ZENKAKU_START, UPPERCASE_ZENKAKU_END];
const ZENKAKU_LOWERCASE = [LOWERCASE_ZENKAKU_START, LOWERCASE_ZENKAKU_END];
const ZENKAKU_PUNCTUATION_1 = [0xff01, 0xff0f];
const ZENKAKU_PUNCTUATION_2 = [0xff1a, 0xff1f];
const ZENKAKU_PUNCTUATION_3 = [0xff3b, 0xff3f];
const ZENKAKU_PUNCTUATION_4 = [0xff5b, 0xff60];
const ZENKAKU_SYMBOLS_CURRENCY = [0xffe0, 0xffee];

const HIRAGANA_CHARS = [0x3040, 0x309f];
const KATAKANA_CHARS = [0x30a0, 0x30ff];
const HANKAKU_KATAKANA = [0xff66, 0xff9f];
const KATAKANA_PUNCTUATION = [0x30fb, 0x30fc];
const KANA_PUNCTUATION = [0xff61, 0xff65];
const CJK_SYMBOLS_PUNCTUATION = [0x3000, 0x303f];
const COMMON_CJK = [0x4e00, 0x9fff];
const RARE_CJK = [0x3400, 0x4dbf];

const KANA_RANGES = [HIRAGANA_CHARS, KATAKANA_CHARS, KANA_PUNCTUATION, HANKAKU_KATAKANA];

const JA_PUNCTUATION_RANGES = [CJK_SYMBOLS_PUNCTUATION, KANA_PUNCTUATION, KATAKANA_PUNCTUATION, ZENKAKU_PUNCTUATION_1, ZENKAKU_PUNCTUATION_2, ZENKAKU_PUNCTUATION_3, ZENKAKU_PUNCTUATION_4, ZENKAKU_SYMBOLS_CURRENCY];

// All Japanese unicode start and end ranges
// Includes kanji, kana, zenkaku latin chars, punctuation, and number ranges.
const JAPANESE_RANGES = [...KANA_RANGES, ...JA_PUNCTUATION_RANGES, ZENKAKU_UPPERCASE, ZENKAKU_LOWERCASE, ZENKAKU_NUMBERS, COMMON_CJK, RARE_CJK];

const MODERN_ENGLISH = [0x0000, 0x007f];
const HEPBURN_MACRON_RANGES = [[0x0100, 0x0101], // Ā ā
[0x0112, 0x0113], // Ē ē
[0x012a, 0x012b], // Ī ī
[0x014c, 0x014d], // Ō ō
[0x016a, 0x016b]];
const SMART_QUOTE_RANGES = [[0x2018, 0x2019], // ‘ ’
[0x201c, 0x201d]];

const ROMAJI_RANGES = [MODERN_ENGLISH, ...HEPBURN_MACRON_RANGES];

const EN_PUNCTUATION_RANGES = [[0x20, 0x2f], [0x3a, 0x3f], [0x5b, 0x60], [0x7b, 0x7e], ...SMART_QUOTE_RANGES];

/**
 * Tests a character. Returns true if the character is [Katakana](https://en.wikipedia.org/wiki/Katakana).
 * @param  {String} char character string to test
 * @return {Boolean}
 */
function isCharJapanese(char = '') {
  return JAPANESE_RANGES.some(([start, end]) => isCharInRange(char, start, end));
}

/**
 * Test if `input` only includes [Kanji](https://en.wikipedia.org/wiki/Kanji), [Kana](https://en.wikipedia.org/wiki/Kana), zenkaku numbers, and JA punctuation/symbols.”
 * @param  {String} [input=''] text
 * @param  {Regexp} [allowed] additional test allowed to pass for each char
 * @return {Boolean} true if passes checks
 * @example
 * isJapanese('泣き虫')
 * // => true
 * isJapanese('あア')
 * // => true
 * isJapanese('２月') // Zenkaku numbers allowed
 * // => true
 * isJapanese('泣き虫。！〜＄') // Zenkaku/JA punctuation
 * // => true
 * isJapanese('泣き虫.!~$') // Latin punctuation fails
 * // => false
 * isJapanese('A泣き虫')
 * // => false
 * isJapanese('≪偽括弧≫', /[≪≫]/);
 * // => true
 */
function isJapanese(input = '', allowed) {
  const augmented = typeOf(allowed) === 'regexp';
  return isEmpty(input) ? false : [...input].every(char => {
    const isJa = isCharJapanese(char);
    return !augmented ? isJa : isJa || allowed.test(char);
  });
}

/**
 * Returns true if char is 'ー'
 * @param  {String} char to test
 * @return {Boolean}
 */
function isCharLongDash(char = '') {
  if (isEmpty(char)) return false;
  return char.charCodeAt(0) === PROLONGED_SOUND_MARK;
}

/**
 * Tests a character. Returns true if the character is [Hiragana](https://en.wikipedia.org/wiki/Hiragana).
 * @param  {String} char character string to test
 * @return {Boolean}
 */
function isCharHiragana(char = '') {
  if (isEmpty(char)) return false;
  if (isCharLongDash(char)) return true;
  return isCharInRange(char, HIRAGANA_START, HIRAGANA_END);
}

/**
 * Tests a character. Returns true if the character is [Katakana](https://en.wikipedia.org/wiki/Katakana).
 * @param  {String} char character string to test
 * @return {Boolean}
 */
function isCharKatakana(char = '') {
  return isCharInRange(char, KATAKANA_START, KATAKANA_END);
}

/**
 * Tests a character. Returns true if the character is [Hiragana](https://en.wikipedia.org/wiki/Hiragana) or [Katakana](https://en.wikipedia.org/wiki/Katakana).
 * @param  {String} char character string to test
 * @return {Boolean}
 */
function isCharKana(char = '') {
  if (isEmpty(char)) return false;
  return isCharHiragana(char) || isCharKatakana(char);
}

/**
 * Test if `input` is [Kana](https://en.wikipedia.org/wiki/Kana) ([Katakana](https://en.wikipedia.org/wiki/Katakana) and/or [Hiragana](https://en.wikipedia.org/wiki/Hiragana))
 * @param  {String} [input=''] text
 * @return {Boolean} true if all [Kana](https://en.wikipedia.org/wiki/Kana)
 * @example
 * isKana('あ')
 * // => true
 * isKana('ア')
 * // => true
 * isKana('あーア')
 * // => true
 * isKana('A')
 * // => false
 * isKana('あAア')
 * // => false
 */
function isKana(input = '') {
  if (isEmpty(input)) return false;
  return [...input].every(isCharKana);
}

/**
 * Tests a character. Returns true if the character is a CJK ideograph (kanji).
 * @param  {String} char character string to test
 * @return {Boolean}
 */
function isCharKanji(char = '') {
  return isCharInRange(char, KANJI_START, KANJI_END);
}

/**
 * Tests if `input` is [Kanji](https://en.wikipedia.org/wiki/Kanji) ([Japanese CJK ideographs](https://en.wikipedia.org/wiki/CJK_Unified_Ideographs))
 * @param  {String} [input=''] text
 * @return {Boolean} true if all [Kanji](https://en.wikipedia.org/wiki/Kanji)
 * @example
 * isKanji('刀')
 * // => true
 * isKanji('切腹')
 * // => true
 * isKanji('勢い')
 * // => false
 * isKanji('あAア')
 * // => false
 * isKanji('🐸')
 * // => false
 */
function isKanji(input = '') {
  if (isEmpty(input)) return false;
  return [...input].every(isCharKanji);
}

/**
 * Tests a character. Returns true if the character is considered English punctuation.
 * @param  {String} char character string to test
 * @return {Boolean}
 */
function isCharEnglishPunctuation(char = '') {
  if (isEmpty(char)) return false;
  return EN_PUNCTUATION_RANGES.some(([start, end]) => isCharInRange(char, start, end));
}

/**
 * Tests a character. Returns true if the character is considered English punctuation.
 * @param  {String} char character string to test
 * @return {Boolean}
 */
function isCharJapanesePunctuation(char = '') {
  if (isEmpty(char)) return false;
  return JA_PUNCTUATION_RANGES.some(([start, end]) => isCharInRange(char, start, end));
}

/**
 * Tests a character. Returns true if the character is [Romaji](https://en.wikipedia.org/wiki/Romaji) (allowing [Hepburn romanisation](https://en.wikipedia.org/wiki/Hepburn_romanization))
 * @param  {String} char character string to test
 * @return {Boolean}
 */
function isCharRomaji(char = '') {
  if (isEmpty(char)) return false;
  return ROMAJI_RANGES.some(([start, end]) => isCharInRange(char, start, end));
}

const isCharEnSpace = x => x === ' ';
const isCharJaSpace = x => x === '　';
const isCharJaNum = x => /[０-９]/.test(x);
const isCharEnNum = x => /[0-9]/.test(x);

const TOKEN_TYPES = {
  EN: 'en',
  JA: 'ja',
  EN_NUM: 'englishNumeral',
  JA_NUM: 'japaneseNumeral',
  EN_PUNC: 'englishPunctuation',
  JA_PUNC: 'japanesePunctuation',
  KANJI: 'kanji',
  HIRAGANA: 'hiragana',
  KATAKANA: 'katakana',
  SPACE: 'space',
  OTHER: 'other'
};

// prettier-ignore
function getType(input, compact = false) {
  const {
    EN, JA, EN_NUM, JA_NUM, EN_PUNC, JA_PUNC, KANJI, HIRAGANA, KATAKANA, SPACE, OTHER
  } = TOKEN_TYPES;

  if (compact) {
    switch (true) {
      case isCharJaNum(input):
        return OTHER;
      case isCharEnNum(input):
        return OTHER;
      case isCharEnSpace(input):
        return EN;
      case isCharEnglishPunctuation(input):
        return OTHER;
      case isCharJaSpace(input):
        return JA;
      case isCharJapanesePunctuation(input):
        return OTHER;
      case isCharJapanese(input):
        return JA;
      case isCharRomaji(input):
        return EN;
      default:
        return OTHER;
    }
  } else {
    switch (true) {
      case isCharJaSpace(input):
        return SPACE;
      case isCharEnSpace(input):
        return SPACE;
      case isCharJaNum(input):
        return JA_NUM;
      case isCharEnNum(input):
        return EN_NUM;
      case isCharEnglishPunctuation(input):
        return EN_PUNC;
      case isCharJapanesePunctuation(input):
        return JA_PUNC;
      case isCharKanji(input):
        return KANJI;
      case isCharHiragana(input):
        return HIRAGANA;
      case isCharKatakana(input):
        return KATAKANA;
      case isCharJapanese(input):
        return JA;
      case isCharRomaji(input):
        return EN;
      default:
        return OTHER;
    }
  }
}

/**
 * Splits input into array of strings separated by opinionated token types
 * `'en', 'ja', 'englishNumeral', 'japaneseNumeral','englishPunctuation', 'japanesePunctuation','kanji', 'hiragana', 'katakana', 'space', 'other'`.
 * If `{ compact: true }` then many same-language tokens are combined (spaces + text, kanji + kana, numeral + punctuation).
 * If `{ detailed: true }` then return array will contain `{ type, value }` instead of `'value'`
 * @param  {String} input text
 * @param  {Object} [options={ compact: false, detailed: false}] options to modify output style
 * @return {String|Object[]} text split into tokens containing values, or detailed object
 * @example
 * tokenize('ふふフフ')
 * // ['ふふ', 'フフ']
 *
 * tokenize('感じ')
 * // ['感', 'じ']
 *
 * tokenize('truly 私は悲しい')
 * // ['truly', ' ', '私', 'は', '悲', 'しい']
 *
 * tokenize('truly 私は悲しい', { compact: true })
 * // ['truly ', '私は悲しい']
 *
 * tokenize('5romaji here...!?漢字ひらがな４カタ　カナ「ＳＨＩＯ」。！')
 * // [ '5', 'romaji', ' ', 'here', '...!?', '漢字', 'ひらがな', 'カタ', '　', 'カナ', '４', '「', 'ＳＨＩＯ', '」。！']
 *
 * tokenize('5romaji here...!?漢字ひらがな４カタ　カナ「ＳＨＩＯ」。！', { compact: true })
 * // [ '5', 'romaji here', '...!?', '漢字ひらがなカタ　カナ', '４「', 'ＳＨＩＯ', '」。！']
 *
 * tokenize('5romaji here...!?漢字ひらがなカタ　カナ４「ＳＨＩＯ」。！ لنذهب', { detailed: true })
 * // [
 *  { type: 'englishNumeral', value: '5' },
 *  { type: 'en', value: 'romaji' },
 *  { type: 'space', value: ' ' },
 *  { type: 'en', value: 'here' },
 *  { type: 'englishPunctuation', value: '...!?' },
 *  { type: 'kanji', value: '漢字' },
 *  { type: 'hiragana', value: 'ひらがな' },
 *  { type: 'katakana', value: 'カタ' },
 *  { type: 'space', value: '　' },
 *  { type: 'katakana', value: 'カナ' },
 *  { type: 'japaneseNumeral', value: '４' },
 *  { type: 'japanesePunctuation', value: '「' },
 *  { type: 'ja', value: 'ＳＨＩＯ' },
 *  { type: 'japanesePunctuation', value: '」。！' },
 *  { type: 'space', value: ' ' },
 *  { type: 'other', value: 'لنذهب' },
 * ]
 *
 * tokenize('5romaji here...!?漢字ひらがなカタ　カナ４「ＳＨＩＯ」。！ لنذهب', { compact: true, detailed: true})
 * // [
 *  { type: 'other', value: '5' },
 *  { type: 'en', value: 'romaji here' },
 *  { type: 'other', value: '...!?' },
 *  { type: 'ja', value: '漢字ひらがなカタ　カナ' },
 *  { type: 'other', value: '４「' },
 *  { type: 'ja', value: 'ＳＨＩＯ' },
 *  { type: 'other', value: '」。！' },
 *  { type: 'en', value: ' ' },
 *  { type: 'other', value: 'لنذهب' },
 *]
 */
function tokenize(input, { compact = false, detailed = false } = {}) {
  if (input == null || isEmpty(input)) {
    return [];
  }
  const chars = [...input];
  let initial = chars.shift();
  let prevType = getType(initial, compact);
  initial = detailed ? { type: prevType, value: initial } : initial;

  const result = chars.reduce((tokens, char) => {
    const currType = getType(char, compact);
    const sameType = currType === prevType;
    prevType = currType;
    let newValue = char;

    if (sameType) {
      newValue = (detailed ? tokens.pop().value : tokens.pop()) + newValue;
    }

    return detailed ? tokens.concat({ type: currType, value: newValue }) : tokens.concat(newValue);
  }, [initial]);
  return result;
}

const isLeadingWithoutInitialKana = (input, leading) => leading && !isKana(input[0]);
const isTrailingWithoutFinalKana = (input, leading) => !leading && !isKana(input[input.length - 1]);
const isInvalidMatcher = (input, matchKanji) => matchKanji && ![...matchKanji].some(isKanji) || !matchKanji && isKana(input);

/**
 * Strips [Okurigana](https://en.wikipedia.org/wiki/Okurigana)
 * @param  {String} input text
 * @param  {Object} [options={ leading: false, matchKanji: '' }] optional config
 * @return {String} text with okurigana removed
 * @example
 * stripOkurigana('踏み込む')
 * // => '踏み込'
 * stripOkurigana('お祝い')
 * // => 'お祝'
 * stripOkurigana('お腹', { leading: true });
 * // => '腹'
 * stripOkurigana('ふみこむ', { matchKanji: '踏み込む' });
 * // => 'ふみこ'
 * stripOkurigana('おみまい', { matchKanji: 'お祝い', leading: true });
 * // => 'みまい'
 */
function stripOkurigana(input = '', { leading = false, matchKanji = '' } = {}) {
  if (!isJapanese(input) || isLeadingWithoutInitialKana(input, leading) || isTrailingWithoutFinalKana(input, leading) || isInvalidMatcher(input, matchKanji)) {
    return input;
  }

  const chars = matchKanji || input;
  const okuriganaRegex = new RegExp(leading ? `^${tokenize(chars).shift()}` : `${tokenize(chars).pop()}$`);
  return input.replace(okuriganaRegex, '');
}

/**
 * Test if `input` is [Hiragana](https://en.wikipedia.org/wiki/Hiragana)
 * @param  {String} [input=''] text
 * @return {Boolean} true if all [Hiragana](https://en.wikipedia.org/wiki/Hiragana)
 * @example
 * isHiragana('げーむ')
 * // => true
 * isHiragana('A')
 * // => false
 * isHiragana('あア')
 * // => false
 */
function isHiragana(input = '') {
  if (isEmpty(input)) return false;
  return [...input].every(isCharHiragana);
}

/**
 * Test if `input` is [Katakana](https://en.wikipedia.org/wiki/Katakana)
 * @param  {String} [input=''] text
 * @return {Boolean} true if all [Katakana](https://en.wikipedia.org/wiki/Katakana)
 * @example
 * isKatakana('ゲーム')
 * // => true
 * isKatakana('あ')
 * // => false
 * isKatakana('A')
 * // => false
 * isKatakana('あア')
 * // => false
 */
function isKatakana(input = '') {
  if (isEmpty(input)) return false;
  return [...input].every(isCharKatakana);
}

var justZipIt = zip;

/*
  zip([1, 2, 3]); // [[1], [2], [3]]
  zip([1, 2, 3], ['a', 'b', 'c']); // [[1, 'a'], [2, 'b'], [3, 'c']]
  zip([1, 2], ['a', 'b'], [true, false]); //[[1, 'a', true], [2, 'b', false]]

  zip([1, 2, 3], ['a', 'b'], [true]);
  // [[1, 'a', true], [2, 'b', undefined], [3, undefined, undefined]]

  zip(undefined, {}, false, 1, 'foo'); // throws
  zip([1, 2], ['a', 'b'], undefined, {}, false, 1, 'foo'); // throws
  
*/

function zip() {
  var result = [];
  var args = Array.prototype.slice.call(arguments);
  var argsLen = args.length;
  var maxLen = 0;
  var i, j;

  if (!argsLen) {
    throw new Error('zip requires at least one argument');
  }

  for (i = 0; i < argsLen; i++) {
    if (!Array.isArray(args[i])) {
      throw new Error('all arguments must be arrays');
    }
    var arrLen = args[i].length;
    if (arrLen > maxLen) {
      maxLen = arrLen;
    }
  }

  for (i = 0; i < maxLen; i++) {
    var group = [];
    for (j = 0; j < argsLen; j++) {
      if (!Array.isArray(args[j])) {
        throw new Error('all arguments must be arrays');
      }
      group[j] = args[j][i];
    }
    result[i] = group;
  }

  return result;
}

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var taggedTemplateLiteral = function (strings, raw) {
  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
};

var toArray = function (arr) {
  return Array.isArray(arr) ? arr : Array.from(arr);
};

var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/**
 * Combines furigana with kanji into an array of string pairs.
 * @param  {String} word vocab kanji word
 * @param  {String} reading vocab kana reading
 * @param  {String|Object} furi furigana placement info
 * @return {Array} furigana/kanji pairs
 * @example
 * combineFuri('お世辞', 'おせじ', '1:せ;2:じ')
 * // => [['', 'お'], ['せ', '世'], ['じ', '辞']]
 * combineFuri('大人しい', 'おとなしい') // smart fallbacks
 * // => [['おとな', '大人'], ['', 'しい']]
 * combineFuri('使い方', 'つかいかた') // smart fallbacks
 * // => [['つか', '使'], ['', 'い'], ['かた', '方']]
 *
 * // special compound readings (義訓/熟字訓) are spread across relevant kanji
 * combineFuri('胡座', 'あぐら', '0:あぐら')
 * // => [['あぐら', '胡座']]
 */
function combineFuri() {
  var word = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var reading = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var furi = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

  var furiLocs = parseFuri(furi);
  // 義訓/熟字訓 words with a single furi loc: 今日 "0:きょう"
  var isSpecialReading = furiLocs.length === 1 && [].concat(toConsumableArray(word)).every(isKanji);
  var isKanaWord = [].concat(toConsumableArray(word)).every(isKana);
  var isWanikaniMadness = [].concat(toConsumableArray(reading)).some(isHiragana) && [].concat(toConsumableArray(reading)).some(isKatakana);

  if (word === reading || isKanaWord) {
    return [['', word]];
  }

  if (!furi || isSpecialReading || isWanikaniMadness) {
    return basicFuri(word, reading);
  }

  return generatePairs(word, furiLocs);
}

/**
 * Displays simple furigana by removing redundant kana
 * @param  {String} [word=''] 'お見舞い'
 * @param  {String} [reading=''] 'おみまい'
 * @return {Array} [['', 'お'], ['見舞', 'みま'], ['', 'い']]
 */
function basicFuri() {
  var word = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var reading = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  // early return + guard against words like １日 which are tokenized unfavourably
  if ([].concat(toConsumableArray(word)).every(function (c) {
    return !isKana(c);
  })) {
    return [[reading, word]];
  }

  var _ref = [reading.slice(0, word.length - stripOkurigana(word, { leading: true }).length), reading.slice(stripOkurigana(reading, { matchKanji: word }).length)],
      bikago = _ref[0],
      okurigana = _ref[1];


  var innerWordTokens = tokenize(removeExtraneousKana(word, bikago, okurigana));
  var innerReadingChars = removeExtraneousKana(reading, bikago, okurigana);

  var kanjiOddKanaEvenRegex = RegExp(innerWordTokens.map(function (char) {
    return isKanji(char) ? '(.*)' : '(' + char + ')';
  }).join(''));

  var _ref2 = innerReadingChars.match(kanjiOddKanaEvenRegex) || [];

  var _ref3 = toArray(_ref2);

  innerReadingChars = _ref3.slice(1);


  var ret = justZipIt(innerReadingChars, innerWordTokens).map(skipRedundantReadings);

  if (bikago) {
    ret.unshift(['', bikago]);
  }

  if (okurigana) {
    ret.push(['', okurigana]);
  }

  return ret;
}

function removeExtraneousKana() {
  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var leading = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var trailing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

  return str.replace(RegExp('^' + leading), '').replace(RegExp(trailing + '$'), '');
}

function skipRedundantReadings(_ref4) {
  var _ref5 = slicedToArray(_ref4, 2),
      reading = _ref5[0],
      _ref5$ = _ref5[1],
      word = _ref5$ === undefined ? '' : _ref5$;

  return !reading || reading === word ? ['', word] : [reading, word];
}

function parseFuri(data) {
  return typeof data === 'string' ? parseFuriString(data) : parseFuriObject(data);
}

/**
 * Parses furigana placement object
 * @param  {Object} [locations={}] { 1:'せ', 2:'じ' }
 * @return {Array} [ [[1, 2], 'せ'], [[2, 3], 'じ'] ]
 */
function parseFuriObject() {
  var locations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  return Object.entries(locations).map(function (_ref6) {
    var _ref7 = slicedToArray(_ref6, 2),
        start = _ref7[0],
        content = _ref7[1];

    return [[Number(start), Number(start) + 1], content];
  });
}

/**
 * Parses furigana placement string
 * @param  {String} [locations=''] '1:せ;2:じ'
 * @return {Array} [ [[1, 2], 'せ'], [[2, 3], 'じ'] ]
 */
function parseFuriString() {
  var locations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  return locations.split(';').map(function (entry) {
    var _entry$split = entry.split(':'),
        _entry$split2 = slicedToArray(_entry$split, 2),
        indexes = _entry$split2[0],
        content = _entry$split2[1];

    var _indexes$split$map = indexes.split('-').map(Number),
        _indexes$split$map2 = slicedToArray(_indexes$split$map, 2),
        start = _indexes$split$map2[0],
        end = _indexes$split$map2[1];
    // NOTE: in the JMDict furistring data, the end index is either missing
    // or it is listed as the *start* index of the final char ¯\_(ツ)_/¯
    // so we need to bump it either way to encompass that char


    return [[start, end ? end + 1 : start + 1], content];
  });
}

/**
 * Generates array pairs via furigana location data
 * @param  {String} word 'お世辞'
 * @param  {Array} furiLocs [[[1, 2], 'せ'], [[2, 3], 'じ']]
 * @return {Array} [['', 'お'], ['せ', '世'], ['じ', '辞']]
 */
function generatePairs() {
  var word = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var furiLocs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  var prevCharEnd = 0;

  return furiLocs.reduce(function (pairs, _ref8, index, source) {
    var _ref9 = slicedToArray(_ref8, 2),
        _ref9$ = slicedToArray(_ref9[0], 2),
        start = _ref9$[0],
        end = _ref9$[1],
        furiText = _ref9[1];

    // if no furigana at this index, add intervening chars
    if (start !== prevCharEnd) {
      pairs.push(['', word.slice(prevCharEnd, start)]);
    }

    // add furigana and associated chars
    pairs.push([furiText, word.slice(start, end)]);

    // if no more furigana left, add any remaining chars/okurigana with blank furi
    if (end < word.length && !source[index + 1]) {
      pairs.push(['', word.slice(end)]);
    }

    prevCharEnd = end;
    return pairs;
  }, []);
}

var _templateObject = taggedTemplateLiteral(['\n  display: inline-flex;\n  flex-flow: row wrap;\n  font-family: \'\u30D2\u30E9\u30AE\u30CE\u89D2\u30B4 ProN\', \'Hiragino Kaku Gothic ProN\', \'TakaoP\u30B4\u30B7\u30C3\u30AF\', TakaoPGothic,\n    \'\u6E38\u30B4\u30B7\u30C3\u30AF\', \'\u6E38\u30B4\u30B7\u30C3\u30AF\u4F53\', YuGothic, \'Yu Gothic\', \'\u30E1\u30A4\u30EA\u30AA\', Meiryo, \'\uFF2D\uFF33 \u30B4\u30B7\u30C3\u30AF\',\n    \'MS Gothic\', HiraKakuProN-W3, \'MotoyaLCedar\', \'Droid Sans Japanese\', sans-serif;\n'], ['\n  display: inline-flex;\n  flex-flow: row wrap;\n  font-family: \'\u30D2\u30E9\u30AE\u30CE\u89D2\u30B4 ProN\', \'Hiragino Kaku Gothic ProN\', \'TakaoP\u30B4\u30B7\u30C3\u30AF\', TakaoPGothic,\n    \'\u6E38\u30B4\u30B7\u30C3\u30AF\', \'\u6E38\u30B4\u30B7\u30C3\u30AF\u4F53\', YuGothic, \'Yu Gothic\', \'\u30E1\u30A4\u30EA\u30AA\', Meiryo, \'\uFF2D\uFF33 \u30B4\u30B7\u30C3\u30AF\',\n    \'MS Gothic\', HiraKakuProN-W3, \'MotoyaLCedar\', \'Droid Sans Japanese\', sans-serif;\n']),
    _templateObject2 = taggedTemplateLiteral(['\n  display: inline-flex;\n  font-size: 24px;\n  line-height: 1;\n  flex-flow: column nowrap;\n  justify-content: flex-end;\n  align-items: center;\n  align-self: flex-end;\n'], ['\n  display: inline-flex;\n  font-size: 24px;\n  line-height: 1;\n  flex-flow: column nowrap;\n  justify-content: flex-end;\n  align-items: center;\n  align-self: flex-end;\n']),
    _templateObject3 = taggedTemplateLiteral(['\n  display: block;\n  font-size: 0.5em;\n  letter-spacing: -0.02em;\n  margin: 0 0.1em;\n  padding-top: 0.2em;\n  padding-bottom: 0.1em;\n  user-select: none; /* don\'t interfere with main text selection */\n  opacity: 0.9;\n'], ['\n  display: block;\n  font-size: 0.5em;\n  letter-spacing: -0.02em;\n  margin: 0 0.1em;\n  padding-top: 0.2em;\n  padding-bottom: 0.1em;\n  user-select: none; /* don\'t interfere with main text selection */\n  opacity: 0.9;\n']),
    _templateObject4 = taggedTemplateLiteral(['\n  display: block;\n'], ['\n  display: block;\n']);

var Wrapper = styled.span(_templateObject);

var Pair = styled.span(_templateObject2);

var Furi = styled.span(_templateObject3);

var Text = styled.span(_templateObject4);

function ReactFuri(_ref) {
  var word = _ref.word,
      reading = _ref.reading,
      furi = _ref.furi,
      showFuri = _ref.showFuri,
      render = _ref.render,
      props = objectWithoutProperties(_ref, ['word', 'reading', 'furi', 'showFuri', 'render']);

  var pairs = combineFuri(word, reading, furi);

  return render ? render({ pairs: pairs }) : React.createElement(
    Wrapper,
    _extends({ lang: 'ja' }, props),
    pairs.map(function (_ref2, index) {
      var _ref3 = slicedToArray(_ref2, 2),
          furiText = _ref3[0],
          text = _ref3[1];

      return (
        // "list" is static, index is fine
        // eslint-disable-next-line react/no-array-index-key
        React.createElement(
          Pair,
          { key: index },
          showFuri && React.createElement(
            Furi,
            null,
            furiText
          ),
          React.createElement(
            Text,
            null,
            text
          )
        )
      );
    })
  );
}

ReactFuri.defaultProps = {
  reading: '',
  furi: '',
  showFuri: true
};

ReactFuri.Wrapper = Wrapper;
ReactFuri.Pair = Pair;
ReactFuri.Furi = Furi;
ReactFuri.Text = Text;

export default ReactFuri;
//# sourceMappingURL=index.es.js.map
