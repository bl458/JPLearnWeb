{"ast":null,"code":"import _classCallCheck from \"/home/byungchan/Projects/JapaneseQuiz/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/byungchan/Projects/JapaneseQuiz/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport kuromoji from \"kuromoji\"; // Check where we are\n\nvar isNode = false;\nvar isBrowser = typeof window !== \"undefined\";\n\nif (!isBrowser && typeof module !== \"undefined\" && module.exports) {\n  isNode = true;\n}\n/**\n * Kuromoji based morphological analyzer for kuroshiro\n */\n\n\nvar Analyzer = /*#__PURE__*/function () {\n  /**\n   * Constructor\n   * @param {Object} [options] JSON object which have key-value pairs settings\n   * @param {string} [options.dictPath] Path of the dictionary files\n   */\n  function Analyzer() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        dictPath = _ref.dictPath;\n\n    _classCallCheck(this, Analyzer);\n\n    this._analyzer = null;\n\n    if (!dictPath) {\n      if (isNode) this._dictPath = require.resolve(\"kuromoji\").replace(/src(?!.*src).*/, \"dict/\");else this._dictPath = \"node_modules/kuromoji/dict/\";\n    } else {\n      this._dictPath = dictPath;\n    }\n  }\n  /**\n   * Initialize the analyzer\n   * @returns {Promise} Promise object represents the result of initialization\n   */\n\n\n  _createClass(Analyzer, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        var self = _this;\n\n        if (_this._analyzer == null) {\n          kuromoji.builder({\n            dicPath: _this._dictPath\n          }).build(function (err, newAnalyzer) {\n            if (err) {\n              return reject(err);\n            }\n\n            self._analyzer = newAnalyzer;\n            resolve();\n          });\n        } else {\n          reject(new Error(\"This analyzer has already been initialized.\"));\n        }\n      });\n    }\n    /**\n     * Parse the given string\n     * @param {string} str input string\n     * @returns {Promise} Promise object represents the result of parsing\n     * @example The result of parsing\n     * [{\n     *     \"surface_form\": \"黒白\",    // 表層形\n     *     \"pos\": \"名詞\",               // 品詞 (part of speech)\n     *     \"pos_detail_1\": \"一般\",      // 品詞細分類1\n     *     \"pos_detail_2\": \"*\",        // 品詞細分類2\n     *     \"pos_detail_3\": \"*\",        // 品詞細分類3\n     *     \"conjugated_type\": \"*\",     // 活用型\n     *     \"conjugated_form\": \"*\",     // 活用形\n     *     \"basic_form\": \"黒白\",      // 基本形\n     *     \"reading\": \"クロシロ\",       // 読み\n     *     \"pronunciation\": \"クロシロ\",  // 発音\n     *     \"verbose\": {                 // Other properties\n     *         \"word_id\": 413560,\n     *         \"word_type\": \"KNOWN\",\n     *         \"word_position\": 1\n     *     }\n     * }]\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      var _this2 = this;\n\n      var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      return new Promise(function (resolve, reject) {\n        if (str.trim() === \"\") return resolve([]);\n\n        var result = _this2._analyzer.tokenize(str);\n\n        for (var i = 0; i < result.length; i++) {\n          result[i].verbose = {};\n          result[i].verbose.word_id = result[i].word_id;\n          result[i].verbose.word_type = result[i].word_type;\n          result[i].verbose.word_position = result[i].word_position;\n          delete result[i].word_id;\n          delete result[i].word_type;\n          delete result[i].word_position;\n        }\n\n        resolve(result);\n      });\n    }\n  }]);\n\n  return Analyzer;\n}();\n\nexport default Analyzer;","map":{"version":3,"sources":["/home/byungchan/Projects/JapaneseQuiz/node_modules/kuroshiro-analyzer-kuromoji/src/index.js"],"names":["kuromoji","isNode","isBrowser","window","module","exports","Analyzer","dictPath","_analyzer","_dictPath","require","resolve","replace","Promise","reject","self","builder","dicPath","build","err","newAnalyzer","Error","str","trim","result","tokenize","i","length","verbose","word_id","word_type","word_position"],"mappings":";;AAAA,OAAOA,QAAP,MAAqB,UAArB,C,CAEA;;AACA,IAAIC,MAAM,GAAG,KAAb;AACA,IAAMC,SAAS,GAAI,OAAOC,MAAP,KAAkB,WAArC;;AACA,IAAI,CAACD,SAAD,IAAc,OAAOE,MAAP,KAAkB,WAAhC,IAA+CA,MAAM,CAACC,OAA1D,EAAmE;AAC/DJ,EAAAA,MAAM,GAAG,IAAT;AACH;AAED;;;;;IAGMK,Q;AACF;;;;;AAKA,sBAA+B;AAAA,mFAAJ,EAAI;AAAA,QAAjBC,QAAiB,QAAjBA,QAAiB;;AAAA;;AAC3B,SAAKC,SAAL,GAAiB,IAAjB;;AAEA,QAAI,CAACD,QAAL,EAAe;AACX,UAAIN,MAAJ,EAAY,KAAKQ,SAAL,GAAiBC,OAAO,CAACC,OAAR,CAAgB,UAAhB,EAA4BC,OAA5B,CAAoC,gBAApC,EAAsD,OAAtD,CAAjB,CAAZ,KACK,KAAKH,SAAL,GAAiB,6BAAjB;AACR,KAHD,MAIK;AACD,WAAKA,SAAL,GAAiBF,QAAjB;AACH;AACJ;AAED;;;;;;;;2BAIO;AAAA;;AACH,aAAO,IAAIM,OAAJ,CAAY,UAACF,OAAD,EAAUG,MAAV,EAAqB;AACpC,YAAMC,IAAI,GAAG,KAAb;;AACA,YAAI,KAAI,CAACP,SAAL,IAAkB,IAAtB,EAA4B;AACxBR,UAAAA,QAAQ,CAACgB,OAAT,CAAiB;AAAEC,YAAAA,OAAO,EAAE,KAAI,CAACR;AAAhB,WAAjB,EAA8CS,KAA9C,CAAoD,UAACC,GAAD,EAAMC,WAAN,EAAsB;AACtE,gBAAID,GAAJ,EAAS;AACL,qBAAOL,MAAM,CAACK,GAAD,CAAb;AACH;;AACDJ,YAAAA,IAAI,CAACP,SAAL,GAAiBY,WAAjB;AACAT,YAAAA,OAAO;AACV,WAND;AAOH,SARD,MASK;AACDG,UAAAA,MAAM,CAAC,IAAIO,KAAJ,CAAU,6CAAV,CAAD,CAAN;AACH;AACJ,OAdM,CAAP;AAeH;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;4BAuBgB;AAAA;;AAAA,UAAVC,GAAU,uEAAJ,EAAI;AACZ,aAAO,IAAIT,OAAJ,CAAY,UAACF,OAAD,EAAUG,MAAV,EAAqB;AACpC,YAAIQ,GAAG,CAACC,IAAJ,OAAe,EAAnB,EAAuB,OAAOZ,OAAO,CAAC,EAAD,CAAd;;AACvB,YAAMa,MAAM,GAAG,MAAI,CAAChB,SAAL,CAAeiB,QAAf,CAAwBH,GAAxB,CAAf;;AACA,aAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,MAAM,CAACG,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACpCF,UAAAA,MAAM,CAACE,CAAD,CAAN,CAAUE,OAAV,GAAoB,EAApB;AACAJ,UAAAA,MAAM,CAACE,CAAD,CAAN,CAAUE,OAAV,CAAkBC,OAAlB,GAA4BL,MAAM,CAACE,CAAD,CAAN,CAAUG,OAAtC;AACAL,UAAAA,MAAM,CAACE,CAAD,CAAN,CAAUE,OAAV,CAAkBE,SAAlB,GAA8BN,MAAM,CAACE,CAAD,CAAN,CAAUI,SAAxC;AACAN,UAAAA,MAAM,CAACE,CAAD,CAAN,CAAUE,OAAV,CAAkBG,aAAlB,GAAkCP,MAAM,CAACE,CAAD,CAAN,CAAUK,aAA5C;AACA,iBAAOP,MAAM,CAACE,CAAD,CAAN,CAAUG,OAAjB;AACA,iBAAOL,MAAM,CAACE,CAAD,CAAN,CAAUI,SAAjB;AACA,iBAAON,MAAM,CAACE,CAAD,CAAN,CAAUK,aAAjB;AACH;;AACDpB,QAAAA,OAAO,CAACa,MAAD,CAAP;AACH,OAbM,CAAP;AAcH;;;;;;AAGL,eAAelB,QAAf","sourcesContent":["import kuromoji from \"kuromoji\";\n\n// Check where we are\nlet isNode = false;\nconst isBrowser = (typeof window !== \"undefined\");\nif (!isBrowser && typeof module !== \"undefined\" && module.exports) {\n    isNode = true;\n}\n\n/**\n * Kuromoji based morphological analyzer for kuroshiro\n */\nclass Analyzer {\n    /**\n     * Constructor\n     * @param {Object} [options] JSON object which have key-value pairs settings\n     * @param {string} [options.dictPath] Path of the dictionary files\n     */\n    constructor({ dictPath } = {}) {\n        this._analyzer = null;\n\n        if (!dictPath) {\n            if (isNode) this._dictPath = require.resolve(\"kuromoji\").replace(/src(?!.*src).*/, \"dict/\");\n            else this._dictPath = \"node_modules/kuromoji/dict/\";\n        }\n        else {\n            this._dictPath = dictPath;\n        }\n    }\n\n    /**\n     * Initialize the analyzer\n     * @returns {Promise} Promise object represents the result of initialization\n     */\n    init() {\n        return new Promise((resolve, reject) => {\n            const self = this;\n            if (this._analyzer == null) {\n                kuromoji.builder({ dicPath: this._dictPath }).build((err, newAnalyzer) => {\n                    if (err) {\n                        return reject(err);\n                    }\n                    self._analyzer = newAnalyzer;\n                    resolve();\n                });\n            }\n            else {\n                reject(new Error(\"This analyzer has already been initialized.\"));\n            }\n        });\n    }\n\n    /**\n     * Parse the given string\n     * @param {string} str input string\n     * @returns {Promise} Promise object represents the result of parsing\n     * @example The result of parsing\n     * [{\n     *     \"surface_form\": \"黒白\",    // 表層形\n     *     \"pos\": \"名詞\",               // 品詞 (part of speech)\n     *     \"pos_detail_1\": \"一般\",      // 品詞細分類1\n     *     \"pos_detail_2\": \"*\",        // 品詞細分類2\n     *     \"pos_detail_3\": \"*\",        // 品詞細分類3\n     *     \"conjugated_type\": \"*\",     // 活用型\n     *     \"conjugated_form\": \"*\",     // 活用形\n     *     \"basic_form\": \"黒白\",      // 基本形\n     *     \"reading\": \"クロシロ\",       // 読み\n     *     \"pronunciation\": \"クロシロ\",  // 発音\n     *     \"verbose\": {                 // Other properties\n     *         \"word_id\": 413560,\n     *         \"word_type\": \"KNOWN\",\n     *         \"word_position\": 1\n     *     }\n     * }]\n     */\n    parse(str = \"\") {\n        return new Promise((resolve, reject) => {\n            if (str.trim() === \"\") return resolve([]);\n            const result = this._analyzer.tokenize(str);\n            for (let i = 0; i < result.length; i++) {\n                result[i].verbose = {};\n                result[i].verbose.word_id = result[i].word_id;\n                result[i].verbose.word_type = result[i].word_type;\n                result[i].verbose.word_position = result[i].word_position;\n                delete result[i].word_id;\n                delete result[i].word_type;\n                delete result[i].word_position;\n            }\n            resolve(result);\n        });\n    }\n}\n\nexport default Analyzer;\n"]},"metadata":{},"sourceType":"module"}