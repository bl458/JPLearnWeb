{"ast":null,"code":"/*\n * Copyright 2014 Takuya Asano\n * Copyright 2010-2014 Atilika Inc. and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\n\nvar doublearray = require(\"doublearray\");\n\nvar DynamicDictionaries = require(\"../DynamicDictionaries\");\n\nvar TokenInfoDictionary = require(\"../TokenInfoDictionary\");\n\nvar ConnectionCostsBuilder = require(\"./ConnectionCostsBuilder\");\n\nvar CharacterDefinitionBuilder = require(\"./CharacterDefinitionBuilder\");\n\nvar UnknownDictionary = require(\"../UnknownDictionary\");\n/**\n * Build dictionaries (token info, connection costs)\n *\n * Generates from matrix.def\n * cc.dat: Connection costs\n *\n * Generates from *.csv\n * dat.dat: Double array\n * tid.dat: Token info dictionary\n * tid_map.dat: targetMap\n * tid_pos.dat: posList (part of speech)\n */\n\n\nfunction DictionaryBuilder() {\n  // Array of entries, each entry in Mecab form\n  // (0: surface form, 1: left id, 2: right id, 3: word cost, 4: part of speech id, 5-: other features)\n  this.tid_entries = [];\n  this.unk_entries = [];\n  this.cc_builder = new ConnectionCostsBuilder();\n  this.cd_builder = new CharacterDefinitionBuilder();\n}\n\nDictionaryBuilder.prototype.addTokenInfoDictionary = function (line) {\n  var new_entry = line.split(\",\");\n  this.tid_entries.push(new_entry);\n  return this;\n};\n/**\n * Put one line of \"matrix.def\" file for building ConnectionCosts object\n * @param {string} line is a line of \"matrix.def\"\n */\n\n\nDictionaryBuilder.prototype.putCostMatrixLine = function (line) {\n  this.cc_builder.putLine(line);\n  return this;\n};\n\nDictionaryBuilder.prototype.putCharDefLine = function (line) {\n  this.cd_builder.putLine(line);\n  return this;\n};\n/**\n * Put one line of \"unk.def\" file for building UnknownDictionary object\n * @param {string} line is a line of \"unk.def\"\n */\n\n\nDictionaryBuilder.prototype.putUnkDefLine = function (line) {\n  this.unk_entries.push(line.split(\",\"));\n  return this;\n};\n\nDictionaryBuilder.prototype.build = function () {\n  var dictionaries = this.buildTokenInfoDictionary();\n  var unknown_dictionary = this.buildUnknownDictionary();\n  return new DynamicDictionaries(dictionaries.trie, dictionaries.token_info_dictionary, this.cc_builder.build(), unknown_dictionary);\n};\n/**\n * Build TokenInfoDictionary\n *\n * @returns {{trie: *, token_info_dictionary: *}}\n */\n\n\nDictionaryBuilder.prototype.buildTokenInfoDictionary = function () {\n  var token_info_dictionary = new TokenInfoDictionary(); // using as hashmap, string -> string (word_id -> surface_form) to build dictionary\n\n  var dictionary_entries = token_info_dictionary.buildDictionary(this.tid_entries);\n  var trie = this.buildDoubleArray();\n\n  for (var token_info_id in dictionary_entries) {\n    var surface_form = dictionary_entries[token_info_id];\n    var trie_id = trie.lookup(surface_form); // Assertion\n    // if (trie_id < 0) {\n    //     console.log(\"Not Found:\" + surface_form);\n    // }\n\n    token_info_dictionary.addMapping(trie_id, token_info_id);\n  }\n\n  return {\n    trie: trie,\n    token_info_dictionary: token_info_dictionary\n  };\n};\n\nDictionaryBuilder.prototype.buildUnknownDictionary = function () {\n  var unk_dictionary = new UnknownDictionary(); // using as hashmap, string -> string (word_id -> surface_form) to build dictionary\n\n  var dictionary_entries = unk_dictionary.buildDictionary(this.unk_entries);\n  var char_def = this.cd_builder.build(); // Create CharacterDefinition\n\n  unk_dictionary.characterDefinition(char_def);\n\n  for (var token_info_id in dictionary_entries) {\n    var class_name = dictionary_entries[token_info_id];\n    var class_id = char_def.invoke_definition_map.lookup(class_name); // Assertion\n    // if (trie_id < 0) {\n    //     console.log(\"Not Found:\" + surface_form);\n    // }\n\n    unk_dictionary.addMapping(class_id, token_info_id);\n  }\n\n  return unk_dictionary;\n};\n/**\n * Build double array trie\n *\n * @returns {DoubleArray} Double-Array trie\n */\n\n\nDictionaryBuilder.prototype.buildDoubleArray = function () {\n  var trie_id = 0;\n  var words = this.tid_entries.map(function (entry) {\n    var surface_form = entry[0];\n    return {\n      k: surface_form,\n      v: trie_id++\n    };\n  });\n  var builder = doublearray.builder(1024 * 1024);\n  return builder.build(words);\n};\n\nmodule.exports = DictionaryBuilder;","map":{"version":3,"sources":["/home/byungchan/Projects/JapaneseQuiz/node_modules/kuromoji/src/dict/builder/DictionaryBuilder.js"],"names":["doublearray","require","DynamicDictionaries","TokenInfoDictionary","ConnectionCostsBuilder","CharacterDefinitionBuilder","UnknownDictionary","DictionaryBuilder","tid_entries","unk_entries","cc_builder","cd_builder","prototype","addTokenInfoDictionary","line","new_entry","split","push","putCostMatrixLine","putLine","putCharDefLine","putUnkDefLine","build","dictionaries","buildTokenInfoDictionary","unknown_dictionary","buildUnknownDictionary","trie","token_info_dictionary","dictionary_entries","buildDictionary","buildDoubleArray","token_info_id","surface_form","trie_id","lookup","addMapping","unk_dictionary","char_def","characterDefinition","class_name","class_id","invoke_definition_map","words","map","entry","k","v","builder","module","exports"],"mappings":"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","sourcesContent":["/*\n * Copyright 2014 Takuya Asano\n * Copyright 2010-2014 Atilika Inc. and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\"use strict\";\n\nvar doublearray = require(\"doublearray\");\nvar DynamicDictionaries = require(\"../DynamicDictionaries\");\nvar TokenInfoDictionary = require(\"../TokenInfoDictionary\");\nvar ConnectionCostsBuilder = require(\"./ConnectionCostsBuilder\");\nvar CharacterDefinitionBuilder = require(\"./CharacterDefinitionBuilder\");\nvar UnknownDictionary = require(\"../UnknownDictionary\");\n\n/**\n * Build dictionaries (token info, connection costs)\n *\n * Generates from matrix.def\n * cc.dat: Connection costs\n *\n * Generates from *.csv\n * dat.dat: Double array\n * tid.dat: Token info dictionary\n * tid_map.dat: targetMap\n * tid_pos.dat: posList (part of speech)\n */\nfunction DictionaryBuilder() {\n    // Array of entries, each entry in Mecab form\n    // (0: surface form, 1: left id, 2: right id, 3: word cost, 4: part of speech id, 5-: other features)\n    this.tid_entries = [];\n    this.unk_entries = [];\n    this.cc_builder = new ConnectionCostsBuilder();\n    this.cd_builder = new CharacterDefinitionBuilder();\n}\n\nDictionaryBuilder.prototype.addTokenInfoDictionary = function (line) {\n    var new_entry = line.split(\",\");\n    this.tid_entries.push(new_entry);\n    return this;\n};\n\n/**\n * Put one line of \"matrix.def\" file for building ConnectionCosts object\n * @param {string} line is a line of \"matrix.def\"\n */\nDictionaryBuilder.prototype.putCostMatrixLine = function (line) {\n    this.cc_builder.putLine(line);\n    return this;\n};\n\nDictionaryBuilder.prototype.putCharDefLine = function (line) {\n    this.cd_builder.putLine(line);\n    return this;\n};\n\n/**\n * Put one line of \"unk.def\" file for building UnknownDictionary object\n * @param {string} line is a line of \"unk.def\"\n */\nDictionaryBuilder.prototype.putUnkDefLine = function (line) {\n    this.unk_entries.push(line.split(\",\"));\n    return this;\n};\n\nDictionaryBuilder.prototype.build = function () {\n    var dictionaries = this.buildTokenInfoDictionary();\n    var unknown_dictionary = this.buildUnknownDictionary();\n\n    return new DynamicDictionaries(dictionaries.trie, dictionaries.token_info_dictionary, this.cc_builder.build(), unknown_dictionary);\n};\n\n/**\n * Build TokenInfoDictionary\n *\n * @returns {{trie: *, token_info_dictionary: *}}\n */\nDictionaryBuilder.prototype.buildTokenInfoDictionary = function () {\n\n    var token_info_dictionary = new TokenInfoDictionary();\n\n    // using as hashmap, string -> string (word_id -> surface_form) to build dictionary\n    var dictionary_entries = token_info_dictionary.buildDictionary(this.tid_entries);\n\n    var trie = this.buildDoubleArray();\n\n    for (var token_info_id in dictionary_entries) {\n        var surface_form = dictionary_entries[token_info_id];\n        var trie_id = trie.lookup(surface_form);\n\n        // Assertion\n        // if (trie_id < 0) {\n        //     console.log(\"Not Found:\" + surface_form);\n        // }\n\n        token_info_dictionary.addMapping(trie_id, token_info_id);\n    }\n\n    return {\n        trie: trie,\n        token_info_dictionary: token_info_dictionary\n    };\n};\n\nDictionaryBuilder.prototype.buildUnknownDictionary = function () {\n\n    var unk_dictionary = new UnknownDictionary();\n\n    // using as hashmap, string -> string (word_id -> surface_form) to build dictionary\n    var dictionary_entries = unk_dictionary.buildDictionary(this.unk_entries);\n\n    var char_def = this.cd_builder.build(); // Create CharacterDefinition\n\n    unk_dictionary.characterDefinition(char_def);\n\n    for (var token_info_id in dictionary_entries) {\n        var class_name = dictionary_entries[token_info_id];\n        var class_id = char_def.invoke_definition_map.lookup(class_name);\n\n        // Assertion\n        // if (trie_id < 0) {\n        //     console.log(\"Not Found:\" + surface_form);\n        // }\n\n        unk_dictionary.addMapping(class_id, token_info_id);\n    }\n\n    return unk_dictionary;\n};\n\n/**\n * Build double array trie\n *\n * @returns {DoubleArray} Double-Array trie\n */\nDictionaryBuilder.prototype.buildDoubleArray = function () {\n    var trie_id = 0;\n    var words = this.tid_entries.map(function (entry) {\n        var surface_form = entry[0];\n        return { k: surface_form, v: trie_id++ };\n    });\n\n    var builder = doublearray.builder(1024 * 1024);\n    return builder.build(words);\n};\n\nmodule.exports = DictionaryBuilder;\n"]},"metadata":{},"sourceType":"script"}