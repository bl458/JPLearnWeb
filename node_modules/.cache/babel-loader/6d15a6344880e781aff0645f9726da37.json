{"ast":null,"code":"\"use strict\"; // Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OAuth2Client = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;\n\nconst querystring = require(\"querystring\");\n\nconst stream = require(\"stream\");\n\nconst formatEcdsa = require(\"ecdsa-sig-formatter\");\n\nconst crypto_1 = require(\"../crypto/crypto\");\n\nconst authclient_1 = require(\"./authclient\");\n\nconst loginticket_1 = require(\"./loginticket\");\n\nvar CodeChallengeMethod;\n\n(function (CodeChallengeMethod) {\n  CodeChallengeMethod[\"Plain\"] = \"plain\";\n  CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));\n\nvar CertificateFormat;\n\n(function (CertificateFormat) {\n  CertificateFormat[\"PEM\"] = \"PEM\";\n  CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));\n\nlet OAuth2Client =\n/** @class */\n(() => {\n  class OAuth2Client extends authclient_1.AuthClient {\n    constructor(optionsOrClientId, clientSecret, redirectUri) {\n      super();\n      this.certificateCache = {};\n      this.certificateExpiry = null;\n      this.certificateCacheFormat = CertificateFormat.PEM;\n      this.refreshTokenPromises = new Map();\n      const opts = optionsOrClientId && typeof optionsOrClientId === 'object' ? optionsOrClientId : {\n        clientId: optionsOrClientId,\n        clientSecret,\n        redirectUri\n      };\n      this._clientId = opts.clientId;\n      this._clientSecret = opts.clientSecret;\n      this.redirectUri = opts.redirectUri;\n      this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n      this.forceRefreshOnFailure = !!opts.forceRefreshOnFailure;\n    }\n    /**\n     * Generates URL for consent page landing.\n     * @param opts Options.\n     * @return URL to consent page.\n     */\n\n\n    generateAuthUrl(opts = {}) {\n      if (opts.code_challenge_method && !opts.code_challenge) {\n        throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\n      }\n\n      opts.response_type = opts.response_type || 'code';\n      opts.client_id = opts.client_id || this._clientId;\n      opts.redirect_uri = opts.redirect_uri || this.redirectUri; // Allow scopes to be passed either as array or a string\n\n      if (opts.scope instanceof Array) {\n        opts.scope = opts.scope.join(' ');\n      }\n\n      const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n      return rootUrl + '?' + querystring.stringify(opts);\n    }\n\n    generateCodeVerifier() {\n      // To make the code compatible with browser SubtleCrypto we need to make\n      // this method async.\n      throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');\n    }\n    /**\n     * Convenience method to automatically generate a code_verifier, and it's\n     * resulting SHA256. If used, this must be paired with a S256\n     * code_challenge_method.\n     *\n     * For a full example see:\n     * https://github.com/googleapis/google-auth-library-nodejs/blob/master/samples/oauth2-codeVerifier.js\n     */\n\n\n    async generateCodeVerifierAsync() {\n      // base64 encoding uses 6 bits per character, and we want to generate128\n      // characters. 6*128/8 = 96.\n      const crypto = crypto_1.createCrypto();\n      const randomString = crypto.randomBytesBase64(96); // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n      // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n      // swapping out a few chars.\n\n      const codeVerifier = randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-'); // Generate the base64 encoded SHA256\n\n      const unencodedCodeChallenge = await crypto.sha256DigestBase64(codeVerifier); // We need to use base64UrlEncoding instead of standard base64\n\n      const codeChallenge = unencodedCodeChallenge.split('=')[0].replace(/\\+/g, '-').replace(/\\//g, '_');\n      return {\n        codeVerifier,\n        codeChallenge\n      };\n    }\n\n    getToken(codeOrOptions, callback) {\n      const options = typeof codeOrOptions === 'string' ? {\n        code: codeOrOptions\n      } : codeOrOptions;\n\n      if (callback) {\n        this.getTokenAsync(options).then(r => callback(null, r.tokens, r.res), e => callback(e, null, e.response));\n      } else {\n        return this.getTokenAsync(options);\n      }\n    }\n\n    async getTokenAsync(options) {\n      const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n      const values = {\n        code: options.code,\n        client_id: options.client_id || this._clientId,\n        client_secret: this._clientSecret,\n        redirect_uri: options.redirect_uri || this.redirectUri,\n        grant_type: 'authorization_code',\n        code_verifier: options.codeVerifier\n      };\n      const res = await this.transporter.request({\n        method: 'POST',\n        url,\n        data: querystring.stringify(values),\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        }\n      });\n      const tokens = res.data;\n\n      if (res.data && res.data.expires_in) {\n        tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n        delete tokens.expires_in;\n      }\n\n      this.emit('tokens', tokens);\n      return {\n        tokens,\n        res\n      };\n    }\n    /**\n     * Refreshes the access token.\n     * @param refresh_token Existing refresh token.\n     * @private\n     */\n\n\n    async refreshToken(refreshToken) {\n      if (!refreshToken) {\n        return this.refreshTokenNoCache(refreshToken);\n      } // If a request to refresh using the same token has started,\n      // return the same promise.\n\n\n      if (this.refreshTokenPromises.has(refreshToken)) {\n        return this.refreshTokenPromises.get(refreshToken);\n      }\n\n      const p = this.refreshTokenNoCache(refreshToken).then(r => {\n        this.refreshTokenPromises.delete(refreshToken);\n        return r;\n      }, e => {\n        this.refreshTokenPromises.delete(refreshToken);\n        throw e;\n      });\n      this.refreshTokenPromises.set(refreshToken, p);\n      return p;\n    }\n\n    async refreshTokenNoCache(refreshToken) {\n      if (!refreshToken) {\n        throw new Error('No refresh token is set.');\n      }\n\n      const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n      const data = {\n        refresh_token: refreshToken,\n        client_id: this._clientId,\n        client_secret: this._clientSecret,\n        grant_type: 'refresh_token'\n      }; // request for new token\n\n      const res = await this.transporter.request({\n        method: 'POST',\n        url,\n        data: querystring.stringify(data),\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        }\n      });\n      const tokens = res.data; // TODO: de-duplicate this code from a few spots\n\n      if (res.data && res.data.expires_in) {\n        tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n        delete tokens.expires_in;\n      }\n\n      this.emit('tokens', tokens);\n      return {\n        tokens,\n        res\n      };\n    }\n\n    refreshAccessToken(callback) {\n      if (callback) {\n        this.refreshAccessTokenAsync().then(r => callback(null, r.credentials, r.res), callback);\n      } else {\n        return this.refreshAccessTokenAsync();\n      }\n    }\n\n    async refreshAccessTokenAsync() {\n      const r = await this.refreshToken(this.credentials.refresh_token);\n      const tokens = r.tokens;\n      tokens.refresh_token = this.credentials.refresh_token;\n      this.credentials = tokens;\n      return {\n        credentials: this.credentials,\n        res: r.res\n      };\n    }\n\n    getAccessToken(callback) {\n      if (callback) {\n        this.getAccessTokenAsync().then(r => callback(null, r.token, r.res), callback);\n      } else {\n        return this.getAccessTokenAsync();\n      }\n    }\n\n    async getAccessTokenAsync() {\n      const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n\n      if (shouldRefresh) {\n        if (!this.credentials.refresh_token) {\n          throw new Error('No refresh token is set.');\n        }\n\n        const r = await this.refreshAccessTokenAsync();\n\n        if (!r.credentials || r.credentials && !r.credentials.access_token) {\n          throw new Error('Could not refresh access token.');\n        }\n\n        return {\n          token: r.credentials.access_token,\n          res: r.res\n        };\n      } else {\n        return {\n          token: this.credentials.access_token\n        };\n      }\n    }\n    /**\n     * The main authentication interface.  It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * In OAuth2Client, the result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     * @param url The optional url being authorized\n     */\n\n\n    async getRequestHeaders(url) {\n      const headers = (await this.getRequestMetadataAsync(url)).headers;\n      return headers;\n    }\n\n    async getRequestMetadataAsync(url) {\n      const thisCreds = this.credentials;\n\n      if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n        throw new Error('No access, refresh token or API key is set.');\n      }\n\n      if (thisCreds.access_token && !this.isTokenExpiring()) {\n        thisCreds.token_type = thisCreds.token_type || 'Bearer';\n        const headers = {\n          Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n        };\n        return {\n          headers\n        };\n      }\n\n      if (this.apiKey) {\n        return {\n          headers: {\n            'X-Goog-Api-Key': this.apiKey\n          }\n        };\n      }\n\n      let r = null;\n      let tokens = null;\n\n      try {\n        r = await this.refreshToken(thisCreds.refresh_token);\n        tokens = r.tokens;\n      } catch (err) {\n        const e = err;\n\n        if (e.response && (e.response.status === 403 || e.response.status === 404)) {\n          e.message = `Could not refresh access token: ${e.message}`;\n        }\n\n        throw e;\n      }\n\n      const credentials = this.credentials;\n      credentials.token_type = credentials.token_type || 'Bearer';\n      tokens.refresh_token = credentials.refresh_token;\n      this.credentials = tokens;\n      const headers = {\n        Authorization: credentials.token_type + ' ' + tokens.access_token\n      };\n      return {\n        headers: this.addSharedMetadataHeaders(headers),\n        res: r.res\n      };\n    }\n    /**\n     * Generates an URL to revoke the given token.\n     * @param token The existing token to be revoked.\n     */\n\n\n    static getRevokeTokenUrl(token) {\n      const parameters = querystring.stringify({\n        token\n      });\n      return `${OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_}?${parameters}`;\n    }\n\n    revokeToken(token, callback) {\n      const opts = {\n        url: OAuth2Client.getRevokeTokenUrl(token),\n        method: 'POST'\n      };\n\n      if (callback) {\n        this.transporter.request(opts).then(r => callback(null, r), callback);\n      } else {\n        return this.transporter.request(opts);\n      }\n    }\n\n    revokeCredentials(callback) {\n      if (callback) {\n        this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n      } else {\n        return this.revokeCredentialsAsync();\n      }\n    }\n\n    async revokeCredentialsAsync() {\n      const token = this.credentials.access_token;\n      this.credentials = {};\n\n      if (token) {\n        return this.revokeToken(token);\n      } else {\n        throw new Error('No access token to revoke.');\n      }\n    }\n\n    request(opts, callback) {\n      if (callback) {\n        this.requestAsync(opts).then(r => callback(null, r), e => {\n          return callback(e, e.response);\n        });\n      } else {\n        return this.requestAsync(opts);\n      }\n    }\n\n    async requestAsync(opts, retry = false) {\n      let r2;\n\n      try {\n        const r = await this.getRequestMetadataAsync(opts.url);\n        opts.headers = opts.headers || {};\n\n        if (r.headers && r.headers['x-goog-user-project']) {\n          opts.headers['x-goog-user-project'] = r.headers['x-goog-user-project'];\n        }\n\n        if (r.headers && r.headers.Authorization) {\n          opts.headers.Authorization = r.headers.Authorization;\n        }\n\n        if (this.apiKey) {\n          opts.headers['X-Goog-Api-Key'] = this.apiKey;\n        }\n\n        r2 = await this.transporter.request(opts);\n      } catch (e) {\n        const res = e.response;\n\n        if (res) {\n          const statusCode = res.status; // Retry the request for metadata if the following criteria are true:\n          // - We haven't already retried.  It only makes sense to retry once.\n          // - The response was a 401 or a 403\n          // - The request didn't send a readableStream\n          // - An access_token and refresh_token were available, but either no\n          //   expiry_date was available or the forceRefreshOnFailure flag is set.\n          //   The absent expiry_date case can happen when developers stash the\n          //   access_token and refresh_token for later use, but the access_token\n          //   fails on the first try because it's expired. Some developers may\n          //   choose to enable forceRefreshOnFailure to mitigate time-related\n          //   errors.\n\n          const mayRequireRefresh = this.credentials && this.credentials.access_token && this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure);\n          const isReadableStream = res.config.data instanceof stream.Readable;\n          const isAuthErr = statusCode === 401 || statusCode === 403;\n\n          if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n            await this.refreshAccessTokenAsync();\n            return this.requestAsync(opts, true);\n          }\n        }\n\n        throw e;\n      }\n\n      return r2;\n    }\n\n    verifyIdToken(options, callback) {\n      // This function used to accept two arguments instead of an options object.\n      // Check the types to help users upgrade with less pain.\n      // This check can be removed after a 2.0 release.\n      if (callback && typeof callback !== 'function') {\n        throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n      }\n\n      if (callback) {\n        this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n      } else {\n        return this.verifyIdTokenAsync(options);\n      }\n    }\n\n    async verifyIdTokenAsync(options) {\n      if (!options.idToken) {\n        throw new Error('The verifyIdToken method requires an ID Token');\n      }\n\n      const response = await this.getFederatedSignonCertsAsync();\n      const login = await this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);\n      return login;\n    }\n    /**\n     * Obtains information about the provisioned access token.  Especially useful\n     * if you want to check the scopes that were provisioned to a given token.\n     *\n     * @param accessToken Required.  The Access Token for which you want to get\n     * user info.\n     */\n\n\n    async getTokenInfo(accessToken) {\n      const {\n        data\n      } = await this.transporter.request({\n        method: 'GET',\n        url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n        params: {\n          access_token: accessToken\n        }\n      });\n      const info = Object.assign({\n        expiry_date: new Date().getTime() + data.expires_in * 1000,\n        scopes: data.scope.split(' ')\n      }, data);\n      delete info.expires_in;\n      delete info.scope;\n      return info;\n    }\n\n    getFederatedSignonCerts(callback) {\n      if (callback) {\n        this.getFederatedSignonCertsAsync().then(r => callback(null, r.certs, r.res), callback);\n      } else {\n        return this.getFederatedSignonCertsAsync();\n      }\n    }\n\n    async getFederatedSignonCertsAsync() {\n      const nowTime = new Date().getTime();\n      const format = crypto_1.hasBrowserCrypto() ? CertificateFormat.JWK : CertificateFormat.PEM;\n\n      if (this.certificateExpiry && nowTime < this.certificateExpiry.getTime() && this.certificateCacheFormat === format) {\n        return {\n          certs: this.certificateCache,\n          format\n        };\n      }\n\n      let res;\n      let url;\n\n      switch (format) {\n        case CertificateFormat.PEM:\n          url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;\n          break;\n\n        case CertificateFormat.JWK:\n          url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;\n          break;\n\n        default:\n          throw new Error(`Unsupported certificate format ${format}`);\n      }\n\n      try {\n        res = await this.transporter.request({\n          url\n        });\n      } catch (e) {\n        e.message = `Failed to retrieve verification certificates: ${e.message}`;\n        throw e;\n      }\n\n      const cacheControl = res ? res.headers['cache-control'] : undefined;\n      let cacheAge = -1;\n\n      if (cacheControl) {\n        const pattern = new RegExp('max-age=([0-9]*)');\n        const regexResult = pattern.exec(cacheControl);\n\n        if (regexResult && regexResult.length === 2) {\n          // Cache results with max-age (in seconds)\n          cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n        }\n      }\n\n      let certificates = {};\n\n      switch (format) {\n        case CertificateFormat.PEM:\n          certificates = res.data;\n          break;\n\n        case CertificateFormat.JWK:\n          for (const key of res.data.keys) {\n            certificates[key.kid] = key;\n          }\n\n          break;\n\n        default:\n          throw new Error(`Unsupported certificate format ${format}`);\n      }\n\n      const now = new Date();\n      this.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n      this.certificateCache = certificates;\n      this.certificateCacheFormat = format;\n      return {\n        certs: certificates,\n        format,\n        res\n      };\n    }\n\n    getIapPublicKeys(callback) {\n      if (callback) {\n        this.getIapPublicKeysAsync().then(r => callback(null, r.pubkeys, r.res), callback);\n      } else {\n        return this.getIapPublicKeysAsync();\n      }\n    }\n\n    async getIapPublicKeysAsync() {\n      const nowTime = new Date().getTime();\n      let res;\n      const url = OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_;\n\n      try {\n        res = await this.transporter.request({\n          url\n        });\n      } catch (e) {\n        e.message = `Failed to retrieve verification certificates: ${e.message}`;\n        throw e;\n      }\n\n      return {\n        pubkeys: res.data,\n        res\n      };\n    }\n\n    verifySignedJwtWithCerts() {\n      // To make the code compatible with browser SubtleCrypto we need to make\n      // this method async.\n      throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');\n    }\n    /**\n     * Verify the id token is signed with the correct certificate\n     * and is from the correct audience.\n     * @param jwt The jwt to verify (The ID Token in this case).\n     * @param certs The array of certs to test the jwt against.\n     * @param requiredAudience The audience to test the jwt against.\n     * @param issuers The allowed issuers of the jwt (Optional).\n     * @param maxExpiry The max expiry the certificate can be (Optional).\n     * @return Returns a promise resolving to LoginTicket on verification.\n     */\n\n\n    async verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {\n      const crypto = crypto_1.createCrypto();\n\n      if (!maxExpiry) {\n        maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n      }\n\n      const segments = jwt.split('.');\n\n      if (segments.length !== 3) {\n        throw new Error('Wrong number of segments in token: ' + jwt);\n      }\n\n      const signed = segments[0] + '.' + segments[1];\n      let signature = segments[2];\n      let envelope;\n      let payload;\n\n      try {\n        envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n      } catch (err) {\n        err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;\n        throw err;\n      }\n\n      if (!envelope) {\n        throw new Error(\"Can't parse token envelope: \" + segments[0]);\n      }\n\n      try {\n        payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n      } catch (err) {\n        err.message = `Can't parse token payload '${segments[0]}`;\n        throw err;\n      }\n\n      if (!payload) {\n        throw new Error(\"Can't parse token payload: \" + segments[1]);\n      }\n\n      if (!Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {\n        // If this is not present, then there's no reason to attempt verification\n        throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n      }\n\n      const cert = certs[envelope.kid];\n\n      if (envelope.alg === 'ES256') {\n        signature = formatEcdsa.joseToDer(signature, 'ES256').toString('base64');\n      }\n\n      const verified = await crypto.verify(cert, signed, signature);\n\n      if (!verified) {\n        throw new Error('Invalid token signature: ' + jwt);\n      }\n\n      if (!payload.iat) {\n        throw new Error('No issue time in token: ' + JSON.stringify(payload));\n      }\n\n      if (!payload.exp) {\n        throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n      }\n\n      const iat = Number(payload.iat);\n      if (isNaN(iat)) throw new Error('iat field using invalid format');\n      const exp = Number(payload.exp);\n      if (isNaN(exp)) throw new Error('exp field using invalid format');\n      const now = new Date().getTime() / 1000;\n\n      if (exp >= now + maxExpiry) {\n        throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n      }\n\n      const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n      const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n      if (now < earliest) {\n        throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' + JSON.stringify(payload));\n      }\n\n      if (now > latest) {\n        throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' + JSON.stringify(payload));\n      }\n\n      if (issuers && issuers.indexOf(payload.iss) < 0) {\n        throw new Error('Invalid issuer, expected one of [' + issuers + '], but got ' + payload.iss);\n      } // Check the audience matches if we have one\n\n\n      if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\n        const aud = payload.aud;\n        let audVerified = false; // If the requiredAudience is an array, check if it contains token\n        // audience\n\n        if (requiredAudience.constructor === Array) {\n          audVerified = requiredAudience.indexOf(aud) > -1;\n        } else {\n          audVerified = aud === requiredAudience;\n        }\n\n        if (!audVerified) {\n          throw new Error('Wrong recipient, payload audience != requiredAudience');\n        }\n      }\n\n      return new loginticket_1.LoginTicket(envelope, payload);\n    }\n    /**\n     * Returns true if a token is expired or will expire within\n     * eagerRefreshThresholdMillismilliseconds.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     */\n\n\n    isTokenExpiring() {\n      const expiryDate = this.credentials.expiry_date;\n      return expiryDate ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis : false;\n    }\n\n  }\n\n  OAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\n  /**\n   * The base URL for auth endpoints.\n   */\n\n  OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';\n  /**\n   * The base endpoint for token retrieval.\n   */\n\n  OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://oauth2.googleapis.com/token';\n  /**\n   * The base endpoint to revoke tokens.\n   */\n\n  OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://oauth2.googleapis.com/revoke';\n  /**\n   * Google Sign on certificates in PEM format.\n   */\n\n  OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\n  /**\n   * Google Sign on certificates in JWK format.\n   */\n\n  OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v3/certs';\n  /**\n   * Google Sign on certificates in JWK format.\n   */\n\n  OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_ = 'https://www.gstatic.com/iap/verify/public_key';\n  /**\n   * Clock skew - five minutes in seconds\n   */\n\n  OAuth2Client.CLOCK_SKEW_SECS_ = 300;\n  /**\n   * Max Token Lifetime is one day in seconds\n   */\n\n  OAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n  /**\n   * The allowed oauth token issuers.\n   */\n\n  OAuth2Client.ISSUERS_ = ['accounts.google.com', 'https://accounts.google.com'];\n  return OAuth2Client;\n})();\n\nexports.OAuth2Client = OAuth2Client;","map":{"version":3,"sources":["/home/byungchan/Projects/JapaneseQuiz/node_modules/google-auth-library/build/src/auth/oauth2client.js"],"names":["Object","defineProperty","exports","value","OAuth2Client","CertificateFormat","CodeChallengeMethod","querystring","require","stream","formatEcdsa","crypto_1","authclient_1","loginticket_1","AuthClient","constructor","optionsOrClientId","clientSecret","redirectUri","certificateCache","certificateExpiry","certificateCacheFormat","PEM","refreshTokenPromises","Map","opts","clientId","_clientId","_clientSecret","eagerRefreshThresholdMillis","forceRefreshOnFailure","generateAuthUrl","code_challenge_method","code_challenge","Error","response_type","client_id","redirect_uri","scope","Array","join","rootUrl","GOOGLE_OAUTH2_AUTH_BASE_URL_","stringify","generateCodeVerifier","generateCodeVerifierAsync","crypto","createCrypto","randomString","randomBytesBase64","codeVerifier","replace","unencodedCodeChallenge","sha256DigestBase64","codeChallenge","split","getToken","codeOrOptions","callback","options","code","getTokenAsync","then","r","tokens","res","e","response","url","GOOGLE_OAUTH2_TOKEN_URL_","values","client_secret","grant_type","code_verifier","transporter","request","method","data","headers","expires_in","expiry_date","Date","getTime","emit","refreshToken","refreshTokenNoCache","has","get","p","delete","set","refresh_token","refreshAccessToken","refreshAccessTokenAsync","credentials","getAccessToken","getAccessTokenAsync","token","shouldRefresh","access_token","isTokenExpiring","getRequestHeaders","getRequestMetadataAsync","thisCreds","apiKey","token_type","Authorization","err","status","message","addSharedMetadataHeaders","getRevokeTokenUrl","parameters","GOOGLE_OAUTH2_REVOKE_URL_","revokeToken","revokeCredentials","revokeCredentialsAsync","requestAsync","retry","r2","statusCode","mayRequireRefresh","isReadableStream","config","Readable","isAuthErr","verifyIdToken","verifyIdTokenAsync","idToken","getFederatedSignonCertsAsync","login","verifySignedJwtWithCertsAsync","certs","audience","ISSUERS_","maxExpiry","getTokenInfo","accessToken","GOOGLE_TOKEN_INFO_URL","params","info","assign","scopes","getFederatedSignonCerts","nowTime","format","hasBrowserCrypto","JWK","GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_","GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_","cacheControl","undefined","cacheAge","pattern","RegExp","regexResult","exec","length","Number","certificates","key","keys","kid","now","getIapPublicKeys","getIapPublicKeysAsync","pubkeys","GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_","verifySignedJwtWithCerts","jwt","requiredAudience","issuers","MAX_TOKEN_LIFETIME_SECS_","segments","signed","signature","envelope","payload","JSON","parse","decodeBase64StringUtf8","prototype","hasOwnProperty","call","cert","alg","joseToDer","toString","verified","verify","iat","exp","isNaN","earliest","CLOCK_SKEW_SECS_","latest","indexOf","iss","aud","audVerified","LoginTicket","expiryDate"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OAuth2Client = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;\nconst querystring = require(\"querystring\");\nconst stream = require(\"stream\");\nconst formatEcdsa = require(\"ecdsa-sig-formatter\");\nconst crypto_1 = require(\"../crypto/crypto\");\nconst authclient_1 = require(\"./authclient\");\nconst loginticket_1 = require(\"./loginticket\");\nvar CodeChallengeMethod;\n(function (CodeChallengeMethod) {\n    CodeChallengeMethod[\"Plain\"] = \"plain\";\n    CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));\nvar CertificateFormat;\n(function (CertificateFormat) {\n    CertificateFormat[\"PEM\"] = \"PEM\";\n    CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = {}));\nlet OAuth2Client = /** @class */ (() => {\n    class OAuth2Client extends authclient_1.AuthClient {\n        constructor(optionsOrClientId, clientSecret, redirectUri) {\n            super();\n            this.certificateCache = {};\n            this.certificateExpiry = null;\n            this.certificateCacheFormat = CertificateFormat.PEM;\n            this.refreshTokenPromises = new Map();\n            const opts = optionsOrClientId && typeof optionsOrClientId === 'object'\n                ? optionsOrClientId\n                : { clientId: optionsOrClientId, clientSecret, redirectUri };\n            this._clientId = opts.clientId;\n            this._clientSecret = opts.clientSecret;\n            this.redirectUri = opts.redirectUri;\n            this.eagerRefreshThresholdMillis =\n                opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n            this.forceRefreshOnFailure = !!opts.forceRefreshOnFailure;\n        }\n        /**\n         * Generates URL for consent page landing.\n         * @param opts Options.\n         * @return URL to consent page.\n         */\n        generateAuthUrl(opts = {}) {\n            if (opts.code_challenge_method && !opts.code_challenge) {\n                throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\n            }\n            opts.response_type = opts.response_type || 'code';\n            opts.client_id = opts.client_id || this._clientId;\n            opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n            // Allow scopes to be passed either as array or a string\n            if (opts.scope instanceof Array) {\n                opts.scope = opts.scope.join(' ');\n            }\n            const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n            return rootUrl + '?' + querystring.stringify(opts);\n        }\n        generateCodeVerifier() {\n            // To make the code compatible with browser SubtleCrypto we need to make\n            // this method async.\n            throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');\n        }\n        /**\n         * Convenience method to automatically generate a code_verifier, and it's\n         * resulting SHA256. If used, this must be paired with a S256\n         * code_challenge_method.\n         *\n         * For a full example see:\n         * https://github.com/googleapis/google-auth-library-nodejs/blob/master/samples/oauth2-codeVerifier.js\n         */\n        async generateCodeVerifierAsync() {\n            // base64 encoding uses 6 bits per character, and we want to generate128\n            // characters. 6*128/8 = 96.\n            const crypto = crypto_1.createCrypto();\n            const randomString = crypto.randomBytesBase64(96);\n            // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n            // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n            // swapping out a few chars.\n            const codeVerifier = randomString\n                .replace(/\\+/g, '~')\n                .replace(/=/g, '_')\n                .replace(/\\//g, '-');\n            // Generate the base64 encoded SHA256\n            const unencodedCodeChallenge = await crypto.sha256DigestBase64(codeVerifier);\n            // We need to use base64UrlEncoding instead of standard base64\n            const codeChallenge = unencodedCodeChallenge\n                .split('=')[0]\n                .replace(/\\+/g, '-')\n                .replace(/\\//g, '_');\n            return { codeVerifier, codeChallenge };\n        }\n        getToken(codeOrOptions, callback) {\n            const options = typeof codeOrOptions === 'string' ? { code: codeOrOptions } : codeOrOptions;\n            if (callback) {\n                this.getTokenAsync(options).then(r => callback(null, r.tokens, r.res), e => callback(e, null, e.response));\n            }\n            else {\n                return this.getTokenAsync(options);\n            }\n        }\n        async getTokenAsync(options) {\n            const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n            const values = {\n                code: options.code,\n                client_id: options.client_id || this._clientId,\n                client_secret: this._clientSecret,\n                redirect_uri: options.redirect_uri || this.redirectUri,\n                grant_type: 'authorization_code',\n                code_verifier: options.codeVerifier,\n            };\n            const res = await this.transporter.request({\n                method: 'POST',\n                url,\n                data: querystring.stringify(values),\n                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n            });\n            const tokens = res.data;\n            if (res.data && res.data.expires_in) {\n                tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n                delete tokens.expires_in;\n            }\n            this.emit('tokens', tokens);\n            return { tokens, res };\n        }\n        /**\n         * Refreshes the access token.\n         * @param refresh_token Existing refresh token.\n         * @private\n         */\n        async refreshToken(refreshToken) {\n            if (!refreshToken) {\n                return this.refreshTokenNoCache(refreshToken);\n            }\n            // If a request to refresh using the same token has started,\n            // return the same promise.\n            if (this.refreshTokenPromises.has(refreshToken)) {\n                return this.refreshTokenPromises.get(refreshToken);\n            }\n            const p = this.refreshTokenNoCache(refreshToken).then(r => {\n                this.refreshTokenPromises.delete(refreshToken);\n                return r;\n            }, e => {\n                this.refreshTokenPromises.delete(refreshToken);\n                throw e;\n            });\n            this.refreshTokenPromises.set(refreshToken, p);\n            return p;\n        }\n        async refreshTokenNoCache(refreshToken) {\n            if (!refreshToken) {\n                throw new Error('No refresh token is set.');\n            }\n            const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n            const data = {\n                refresh_token: refreshToken,\n                client_id: this._clientId,\n                client_secret: this._clientSecret,\n                grant_type: 'refresh_token',\n            };\n            // request for new token\n            const res = await this.transporter.request({\n                method: 'POST',\n                url,\n                data: querystring.stringify(data),\n                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n            });\n            const tokens = res.data;\n            // TODO: de-duplicate this code from a few spots\n            if (res.data && res.data.expires_in) {\n                tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n                delete tokens.expires_in;\n            }\n            this.emit('tokens', tokens);\n            return { tokens, res };\n        }\n        refreshAccessToken(callback) {\n            if (callback) {\n                this.refreshAccessTokenAsync().then(r => callback(null, r.credentials, r.res), callback);\n            }\n            else {\n                return this.refreshAccessTokenAsync();\n            }\n        }\n        async refreshAccessTokenAsync() {\n            const r = await this.refreshToken(this.credentials.refresh_token);\n            const tokens = r.tokens;\n            tokens.refresh_token = this.credentials.refresh_token;\n            this.credentials = tokens;\n            return { credentials: this.credentials, res: r.res };\n        }\n        getAccessToken(callback) {\n            if (callback) {\n                this.getAccessTokenAsync().then(r => callback(null, r.token, r.res), callback);\n            }\n            else {\n                return this.getAccessTokenAsync();\n            }\n        }\n        async getAccessTokenAsync() {\n            const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n            if (shouldRefresh) {\n                if (!this.credentials.refresh_token) {\n                    throw new Error('No refresh token is set.');\n                }\n                const r = await this.refreshAccessTokenAsync();\n                if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n                    throw new Error('Could not refresh access token.');\n                }\n                return { token: r.credentials.access_token, res: r.res };\n            }\n            else {\n                return { token: this.credentials.access_token };\n            }\n        }\n        /**\n         * The main authentication interface.  It takes an optional url which when\n         * present is the endpoint being accessed, and returns a Promise which\n         * resolves with authorization header fields.\n         *\n         * In OAuth2Client, the result has the form:\n         * { Authorization: 'Bearer <access_token_value>' }\n         * @param url The optional url being authorized\n         */\n        async getRequestHeaders(url) {\n            const headers = (await this.getRequestMetadataAsync(url)).headers;\n            return headers;\n        }\n        async getRequestMetadataAsync(url) {\n            const thisCreds = this.credentials;\n            if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n                throw new Error('No access, refresh token or API key is set.');\n            }\n            if (thisCreds.access_token && !this.isTokenExpiring()) {\n                thisCreds.token_type = thisCreds.token_type || 'Bearer';\n                const headers = {\n                    Authorization: thisCreds.token_type + ' ' + thisCreds.access_token,\n                };\n                return { headers };\n            }\n            if (this.apiKey) {\n                return { headers: { 'X-Goog-Api-Key': this.apiKey } };\n            }\n            let r = null;\n            let tokens = null;\n            try {\n                r = await this.refreshToken(thisCreds.refresh_token);\n                tokens = r.tokens;\n            }\n            catch (err) {\n                const e = err;\n                if (e.response &&\n                    (e.response.status === 403 || e.response.status === 404)) {\n                    e.message = `Could not refresh access token: ${e.message}`;\n                }\n                throw e;\n            }\n            const credentials = this.credentials;\n            credentials.token_type = credentials.token_type || 'Bearer';\n            tokens.refresh_token = credentials.refresh_token;\n            this.credentials = tokens;\n            const headers = {\n                Authorization: credentials.token_type + ' ' + tokens.access_token,\n            };\n            return { headers: this.addSharedMetadataHeaders(headers), res: r.res };\n        }\n        /**\n         * Generates an URL to revoke the given token.\n         * @param token The existing token to be revoked.\n         */\n        static getRevokeTokenUrl(token) {\n            const parameters = querystring.stringify({ token });\n            return `${OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_}?${parameters}`;\n        }\n        revokeToken(token, callback) {\n            const opts = {\n                url: OAuth2Client.getRevokeTokenUrl(token),\n                method: 'POST',\n            };\n            if (callback) {\n                this.transporter\n                    .request(opts)\n                    .then(r => callback(null, r), callback);\n            }\n            else {\n                return this.transporter.request(opts);\n            }\n        }\n        revokeCredentials(callback) {\n            if (callback) {\n                this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n            }\n            else {\n                return this.revokeCredentialsAsync();\n            }\n        }\n        async revokeCredentialsAsync() {\n            const token = this.credentials.access_token;\n            this.credentials = {};\n            if (token) {\n                return this.revokeToken(token);\n            }\n            else {\n                throw new Error('No access token to revoke.');\n            }\n        }\n        request(opts, callback) {\n            if (callback) {\n                this.requestAsync(opts).then(r => callback(null, r), e => {\n                    return callback(e, e.response);\n                });\n            }\n            else {\n                return this.requestAsync(opts);\n            }\n        }\n        async requestAsync(opts, retry = false) {\n            let r2;\n            try {\n                const r = await this.getRequestMetadataAsync(opts.url);\n                opts.headers = opts.headers || {};\n                if (r.headers && r.headers['x-goog-user-project']) {\n                    opts.headers['x-goog-user-project'] = r.headers['x-goog-user-project'];\n                }\n                if (r.headers && r.headers.Authorization) {\n                    opts.headers.Authorization = r.headers.Authorization;\n                }\n                if (this.apiKey) {\n                    opts.headers['X-Goog-Api-Key'] = this.apiKey;\n                }\n                r2 = await this.transporter.request(opts);\n            }\n            catch (e) {\n                const res = e.response;\n                if (res) {\n                    const statusCode = res.status;\n                    // Retry the request for metadata if the following criteria are true:\n                    // - We haven't already retried.  It only makes sense to retry once.\n                    // - The response was a 401 or a 403\n                    // - The request didn't send a readableStream\n                    // - An access_token and refresh_token were available, but either no\n                    //   expiry_date was available or the forceRefreshOnFailure flag is set.\n                    //   The absent expiry_date case can happen when developers stash the\n                    //   access_token and refresh_token for later use, but the access_token\n                    //   fails on the first try because it's expired. Some developers may\n                    //   choose to enable forceRefreshOnFailure to mitigate time-related\n                    //   errors.\n                    const mayRequireRefresh = this.credentials &&\n                        this.credentials.access_token &&\n                        this.credentials.refresh_token &&\n                        (!this.credentials.expiry_date || this.forceRefreshOnFailure);\n                    const isReadableStream = res.config.data instanceof stream.Readable;\n                    const isAuthErr = statusCode === 401 || statusCode === 403;\n                    if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n                        await this.refreshAccessTokenAsync();\n                        return this.requestAsync(opts, true);\n                    }\n                }\n                throw e;\n            }\n            return r2;\n        }\n        verifyIdToken(options, callback) {\n            // This function used to accept two arguments instead of an options object.\n            // Check the types to help users upgrade with less pain.\n            // This check can be removed after a 2.0 release.\n            if (callback && typeof callback !== 'function') {\n                throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n            }\n            if (callback) {\n                this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n            }\n            else {\n                return this.verifyIdTokenAsync(options);\n            }\n        }\n        async verifyIdTokenAsync(options) {\n            if (!options.idToken) {\n                throw new Error('The verifyIdToken method requires an ID Token');\n            }\n            const response = await this.getFederatedSignonCertsAsync();\n            const login = await this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);\n            return login;\n        }\n        /**\n         * Obtains information about the provisioned access token.  Especially useful\n         * if you want to check the scopes that were provisioned to a given token.\n         *\n         * @param accessToken Required.  The Access Token for which you want to get\n         * user info.\n         */\n        async getTokenInfo(accessToken) {\n            const { data } = await this.transporter.request({\n                method: 'GET',\n                url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n                params: { access_token: accessToken },\n            });\n            const info = Object.assign({\n                expiry_date: new Date().getTime() + data.expires_in * 1000,\n                scopes: data.scope.split(' '),\n            }, data);\n            delete info.expires_in;\n            delete info.scope;\n            return info;\n        }\n        getFederatedSignonCerts(callback) {\n            if (callback) {\n                this.getFederatedSignonCertsAsync().then(r => callback(null, r.certs, r.res), callback);\n            }\n            else {\n                return this.getFederatedSignonCertsAsync();\n            }\n        }\n        async getFederatedSignonCertsAsync() {\n            const nowTime = new Date().getTime();\n            const format = crypto_1.hasBrowserCrypto()\n                ? CertificateFormat.JWK\n                : CertificateFormat.PEM;\n            if (this.certificateExpiry &&\n                nowTime < this.certificateExpiry.getTime() &&\n                this.certificateCacheFormat === format) {\n                return { certs: this.certificateCache, format };\n            }\n            let res;\n            let url;\n            switch (format) {\n                case CertificateFormat.PEM:\n                    url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;\n                    break;\n                case CertificateFormat.JWK:\n                    url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;\n                    break;\n                default:\n                    throw new Error(`Unsupported certificate format ${format}`);\n            }\n            try {\n                res = await this.transporter.request({ url });\n            }\n            catch (e) {\n                e.message = `Failed to retrieve verification certificates: ${e.message}`;\n                throw e;\n            }\n            const cacheControl = res ? res.headers['cache-control'] : undefined;\n            let cacheAge = -1;\n            if (cacheControl) {\n                const pattern = new RegExp('max-age=([0-9]*)');\n                const regexResult = pattern.exec(cacheControl);\n                if (regexResult && regexResult.length === 2) {\n                    // Cache results with max-age (in seconds)\n                    cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n                }\n            }\n            let certificates = {};\n            switch (format) {\n                case CertificateFormat.PEM:\n                    certificates = res.data;\n                    break;\n                case CertificateFormat.JWK:\n                    for (const key of res.data.keys) {\n                        certificates[key.kid] = key;\n                    }\n                    break;\n                default:\n                    throw new Error(`Unsupported certificate format ${format}`);\n            }\n            const now = new Date();\n            this.certificateExpiry =\n                cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n            this.certificateCache = certificates;\n            this.certificateCacheFormat = format;\n            return { certs: certificates, format, res };\n        }\n        getIapPublicKeys(callback) {\n            if (callback) {\n                this.getIapPublicKeysAsync().then(r => callback(null, r.pubkeys, r.res), callback);\n            }\n            else {\n                return this.getIapPublicKeysAsync();\n            }\n        }\n        async getIapPublicKeysAsync() {\n            const nowTime = new Date().getTime();\n            let res;\n            const url = OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_;\n            try {\n                res = await this.transporter.request({ url });\n            }\n            catch (e) {\n                e.message = `Failed to retrieve verification certificates: ${e.message}`;\n                throw e;\n            }\n            return { pubkeys: res.data, res };\n        }\n        verifySignedJwtWithCerts() {\n            // To make the code compatible with browser SubtleCrypto we need to make\n            // this method async.\n            throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');\n        }\n        /**\n         * Verify the id token is signed with the correct certificate\n         * and is from the correct audience.\n         * @param jwt The jwt to verify (The ID Token in this case).\n         * @param certs The array of certs to test the jwt against.\n         * @param requiredAudience The audience to test the jwt against.\n         * @param issuers The allowed issuers of the jwt (Optional).\n         * @param maxExpiry The max expiry the certificate can be (Optional).\n         * @return Returns a promise resolving to LoginTicket on verification.\n         */\n        async verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {\n            const crypto = crypto_1.createCrypto();\n            if (!maxExpiry) {\n                maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n            }\n            const segments = jwt.split('.');\n            if (segments.length !== 3) {\n                throw new Error('Wrong number of segments in token: ' + jwt);\n            }\n            const signed = segments[0] + '.' + segments[1];\n            let signature = segments[2];\n            let envelope;\n            let payload;\n            try {\n                envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n            }\n            catch (err) {\n                err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;\n                throw err;\n            }\n            if (!envelope) {\n                throw new Error(\"Can't parse token envelope: \" + segments[0]);\n            }\n            try {\n                payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n            }\n            catch (err) {\n                err.message = `Can't parse token payload '${segments[0]}`;\n                throw err;\n            }\n            if (!payload) {\n                throw new Error(\"Can't parse token payload: \" + segments[1]);\n            }\n            if (!Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {\n                // If this is not present, then there's no reason to attempt verification\n                throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n            }\n            const cert = certs[envelope.kid];\n            if (envelope.alg === 'ES256') {\n                signature = formatEcdsa.joseToDer(signature, 'ES256').toString('base64');\n            }\n            const verified = await crypto.verify(cert, signed, signature);\n            if (!verified) {\n                throw new Error('Invalid token signature: ' + jwt);\n            }\n            if (!payload.iat) {\n                throw new Error('No issue time in token: ' + JSON.stringify(payload));\n            }\n            if (!payload.exp) {\n                throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n            }\n            const iat = Number(payload.iat);\n            if (isNaN(iat))\n                throw new Error('iat field using invalid format');\n            const exp = Number(payload.exp);\n            if (isNaN(exp))\n                throw new Error('exp field using invalid format');\n            const now = new Date().getTime() / 1000;\n            if (exp >= now + maxExpiry) {\n                throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n            }\n            const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n            const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n            if (now < earliest) {\n                throw new Error('Token used too early, ' +\n                    now +\n                    ' < ' +\n                    earliest +\n                    ': ' +\n                    JSON.stringify(payload));\n            }\n            if (now > latest) {\n                throw new Error('Token used too late, ' +\n                    now +\n                    ' > ' +\n                    latest +\n                    ': ' +\n                    JSON.stringify(payload));\n            }\n            if (issuers && issuers.indexOf(payload.iss) < 0) {\n                throw new Error('Invalid issuer, expected one of [' +\n                    issuers +\n                    '], but got ' +\n                    payload.iss);\n            }\n            // Check the audience matches if we have one\n            if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\n                const aud = payload.aud;\n                let audVerified = false;\n                // If the requiredAudience is an array, check if it contains token\n                // audience\n                if (requiredAudience.constructor === Array) {\n                    audVerified = requiredAudience.indexOf(aud) > -1;\n                }\n                else {\n                    audVerified = aud === requiredAudience;\n                }\n                if (!audVerified) {\n                    throw new Error('Wrong recipient, payload audience != requiredAudience');\n                }\n            }\n            return new loginticket_1.LoginTicket(envelope, payload);\n        }\n        /**\n         * Returns true if a token is expired or will expire within\n         * eagerRefreshThresholdMillismilliseconds.\n         * If there is no expiry time, assumes the token is not expired or expiring.\n         */\n        isTokenExpiring() {\n            const expiryDate = this.credentials.expiry_date;\n            return expiryDate\n                ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis\n                : false;\n        }\n    }\n    OAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';\n    /**\n     * The base URL for auth endpoints.\n     */\n    OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';\n    /**\n     * The base endpoint for token retrieval.\n     */\n    OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://oauth2.googleapis.com/token';\n    /**\n     * The base endpoint to revoke tokens.\n     */\n    OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://oauth2.googleapis.com/revoke';\n    /**\n     * Google Sign on certificates in PEM format.\n     */\n    OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\n    /**\n     * Google Sign on certificates in JWK format.\n     */\n    OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v3/certs';\n    /**\n     * Google Sign on certificates in JWK format.\n     */\n    OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_ = 'https://www.gstatic.com/iap/verify/public_key';\n    /**\n     * Clock skew - five minutes in seconds\n     */\n    OAuth2Client.CLOCK_SKEW_SECS_ = 300;\n    /**\n     * Max Token Lifetime is one day in seconds\n     */\n    OAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n    /**\n     * The allowed oauth token issuers.\n     */\n    OAuth2Client.ISSUERS_ = [\n        'accounts.google.com',\n        'https://accounts.google.com',\n    ];\n    return OAuth2Client;\n})();\nexports.OAuth2Client = OAuth2Client;\n//# sourceMappingURL=oauth2client.js.map"]},"metadata":{},"sourceType":"script"}