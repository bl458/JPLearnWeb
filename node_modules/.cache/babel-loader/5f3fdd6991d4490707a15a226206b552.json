{"ast":null,"code":"/*\n * Copyright 2014 Takuya Asano\n * Copyright 2010-2014 Atilika Inc. and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\n\nvar InvokeDefinitionMap = require(\"./InvokeDefinitionMap\");\n\nvar CharacterClass = require(\"./CharacterClass\");\n\nvar SurrogateAwareString = require(\"../util/SurrogateAwareString\");\n\nvar DEFAULT_CATEGORY = \"DEFAULT\";\n/**\n * CharacterDefinition represents char.def file and\n * defines behavior of unknown word processing\n * @constructor\n */\n\nfunction CharacterDefinition() {\n  this.character_category_map = new Uint8Array(65536); // for all UCS2 code points\n\n  this.compatible_category_map = new Uint32Array(65536); // for all UCS2 code points\n\n  this.invoke_definition_map = null;\n}\n/**\n * Load CharacterDefinition\n * @param {Uint8Array} cat_map_buffer\n * @param {Uint32Array} compat_cat_map_buffer\n * @param {InvokeDefinitionMap} invoke_def_buffer\n * @returns {CharacterDefinition}\n */\n\n\nCharacterDefinition.load = function (cat_map_buffer, compat_cat_map_buffer, invoke_def_buffer) {\n  var char_def = new CharacterDefinition();\n  char_def.character_category_map = cat_map_buffer;\n  char_def.compatible_category_map = compat_cat_map_buffer;\n  char_def.invoke_definition_map = InvokeDefinitionMap.load(invoke_def_buffer);\n  return char_def;\n};\n\nCharacterDefinition.parseCharCategory = function (class_id, parsed_category_def) {\n  var category = parsed_category_def[1];\n  var invoke = parseInt(parsed_category_def[2]);\n  var grouping = parseInt(parsed_category_def[3]);\n  var max_length = parseInt(parsed_category_def[4]);\n\n  if (!isFinite(invoke) || invoke !== 0 && invoke !== 1) {\n    console.log(\"char.def parse error. INVOKE is 0 or 1 in:\" + invoke);\n    return null;\n  }\n\n  if (!isFinite(grouping) || grouping !== 0 && grouping !== 1) {\n    console.log(\"char.def parse error. GROUP is 0 or 1 in:\" + grouping);\n    return null;\n  }\n\n  if (!isFinite(max_length) || max_length < 0) {\n    console.log(\"char.def parse error. LENGTH is 1 to n:\" + max_length);\n    return null;\n  }\n\n  var is_invoke = invoke === 1;\n  var is_grouping = grouping === 1;\n  return new CharacterClass(class_id, category, is_invoke, is_grouping, max_length);\n};\n\nCharacterDefinition.parseCategoryMapping = function (parsed_category_mapping) {\n  var start = parseInt(parsed_category_mapping[1]);\n  var default_category = parsed_category_mapping[2];\n  var compatible_category = 3 < parsed_category_mapping.length ? parsed_category_mapping.slice(3) : [];\n\n  if (!isFinite(start) || start < 0 || start > 0xFFFF) {\n    console.log(\"char.def parse error. CODE is invalid:\" + start);\n  }\n\n  return {\n    start: start,\n    default: default_category,\n    compatible: compatible_category\n  };\n};\n\nCharacterDefinition.parseRangeCategoryMapping = function (parsed_category_mapping) {\n  var start = parseInt(parsed_category_mapping[1]);\n  var end = parseInt(parsed_category_mapping[2]);\n  var default_category = parsed_category_mapping[3];\n  var compatible_category = 4 < parsed_category_mapping.length ? parsed_category_mapping.slice(4) : [];\n\n  if (!isFinite(start) || start < 0 || start > 0xFFFF) {\n    console.log(\"char.def parse error. CODE is invalid:\" + start);\n  }\n\n  if (!isFinite(end) || end < 0 || end > 0xFFFF) {\n    console.log(\"char.def parse error. CODE is invalid:\" + end);\n  }\n\n  return {\n    start: start,\n    end: end,\n    default: default_category,\n    compatible: compatible_category\n  };\n};\n/**\n * Initializing method\n * @param {Array} category_mapping Array of category mapping\n */\n\n\nCharacterDefinition.prototype.initCategoryMappings = function (category_mapping) {\n  // Initialize map by DEFAULT class\n  var code_point;\n\n  if (category_mapping != null) {\n    for (var i = 0; i < category_mapping.length; i++) {\n      var mapping = category_mapping[i];\n      var end = mapping.end || mapping.start;\n\n      for (code_point = mapping.start; code_point <= end; code_point++) {\n        // Default Category class ID\n        this.character_category_map[code_point] = this.invoke_definition_map.lookup(mapping.default);\n\n        for (var j = 0; j < mapping.compatible.length; j++) {\n          var bitset = this.compatible_category_map[code_point];\n          var compatible_category = mapping.compatible[j];\n\n          if (compatible_category == null) {\n            continue;\n          }\n\n          var class_id = this.invoke_definition_map.lookup(compatible_category); // Default Category\n\n          if (class_id == null) {\n            continue;\n          }\n\n          var class_id_bit = 1 << class_id;\n          bitset = bitset | class_id_bit; // Set a bit of class ID 例えば、class_idが3のとき、3ビット目に1を立てる\n\n          this.compatible_category_map[code_point] = bitset;\n        }\n      }\n    }\n  }\n\n  var default_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n\n  if (default_id == null) {\n    return;\n  }\n\n  for (code_point = 0; code_point < this.character_category_map.length; code_point++) {\n    // 他に何のクラスも定義されていなかったときだけ DEFAULT\n    if (this.character_category_map[code_point] === 0) {\n      // DEFAULT class ID に対応するビットだけ1を立てる\n      this.character_category_map[code_point] = 1 << default_id;\n    }\n  }\n};\n/**\n * Lookup compatible categories for a character (not included 1st category)\n * @param {string} ch UCS2 character (just 1st character is effective)\n * @returns {Array.<CharacterClass>} character classes\n */\n\n\nCharacterDefinition.prototype.lookupCompatibleCategory = function (ch) {\n  var classes = [];\n  /*\n   if (SurrogateAwareString.isSurrogatePair(ch)) {\n   // Surrogate pair character codes can not be defined by char.def\n   return classes;\n   }*/\n\n  var code = ch.charCodeAt(0);\n  var integer;\n\n  if (code < this.compatible_category_map.length) {\n    integer = this.compatible_category_map[code]; // Bitset\n  }\n\n  if (integer == null || integer === 0) {\n    return classes;\n  }\n\n  for (var bit = 0; bit < 32; bit++) {\n    // Treat \"bit\" as a class ID\n    if (integer << 31 - bit >>> 31 === 1) {\n      var character_class = this.invoke_definition_map.getCharacterClass(bit);\n\n      if (character_class == null) {\n        continue;\n      }\n\n      classes.push(character_class);\n    }\n  }\n\n  return classes;\n};\n/**\n * Lookup category for a character\n * @param {string} ch UCS2 character (just 1st character is effective)\n * @returns {CharacterClass} character class\n */\n\n\nCharacterDefinition.prototype.lookup = function (ch) {\n  var class_id;\n  var code = ch.charCodeAt(0);\n\n  if (SurrogateAwareString.isSurrogatePair(ch)) {\n    // Surrogate pair character codes can not be defined by char.def, so set DEFAULT category\n    class_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n  } else if (code < this.character_category_map.length) {\n    class_id = this.character_category_map[code]; // Read as integer value\n  }\n\n  if (class_id == null) {\n    class_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n  }\n\n  return this.invoke_definition_map.getCharacterClass(class_id);\n};\n\nmodule.exports = CharacterDefinition;","map":{"version":3,"sources":["/home/byungchan/Projects/JapaneseQuiz/node_modules/kuromoji/src/dict/CharacterDefinition.js"],"names":["InvokeDefinitionMap","require","CharacterClass","SurrogateAwareString","DEFAULT_CATEGORY","CharacterDefinition","character_category_map","Uint8Array","compatible_category_map","Uint32Array","invoke_definition_map","load","cat_map_buffer","compat_cat_map_buffer","invoke_def_buffer","char_def","parseCharCategory","class_id","parsed_category_def","category","invoke","parseInt","grouping","max_length","isFinite","console","log","is_invoke","is_grouping","parseCategoryMapping","parsed_category_mapping","start","default_category","compatible_category","length","slice","default","compatible","parseRangeCategoryMapping","end","prototype","initCategoryMappings","category_mapping","code_point","i","mapping","lookup","j","bitset","class_id_bit","default_id","lookupCompatibleCategory","ch","classes","code","charCodeAt","integer","bit","character_class","getCharacterClass","push","isSurrogatePair","module","exports"],"mappings":"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","sourcesContent":["/*\n * Copyright 2014 Takuya Asano\n * Copyright 2010-2014 Atilika Inc. and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\"use strict\";\n\nvar InvokeDefinitionMap = require(\"./InvokeDefinitionMap\");\nvar CharacterClass = require(\"./CharacterClass\");\nvar SurrogateAwareString = require(\"../util/SurrogateAwareString\");\n\nvar DEFAULT_CATEGORY = \"DEFAULT\";\n\n/**\n * CharacterDefinition represents char.def file and\n * defines behavior of unknown word processing\n * @constructor\n */\nfunction CharacterDefinition() {\n    this.character_category_map = new Uint8Array(65536);  // for all UCS2 code points\n    this.compatible_category_map = new Uint32Array(65536);  // for all UCS2 code points\n    this.invoke_definition_map = null;\n}\n\n/**\n * Load CharacterDefinition\n * @param {Uint8Array} cat_map_buffer\n * @param {Uint32Array} compat_cat_map_buffer\n * @param {InvokeDefinitionMap} invoke_def_buffer\n * @returns {CharacterDefinition}\n */\nCharacterDefinition.load = function (cat_map_buffer, compat_cat_map_buffer, invoke_def_buffer) {\n    var char_def = new CharacterDefinition();\n    char_def.character_category_map = cat_map_buffer;\n    char_def.compatible_category_map = compat_cat_map_buffer;\n    char_def.invoke_definition_map = InvokeDefinitionMap.load(invoke_def_buffer);\n    return char_def;\n};\n\nCharacterDefinition.parseCharCategory = function (class_id, parsed_category_def) {\n    var category = parsed_category_def[1];\n    var invoke = parseInt(parsed_category_def[2]);\n    var grouping = parseInt(parsed_category_def[3]);\n    var max_length = parseInt(parsed_category_def[4]);\n    if (!isFinite(invoke) || (invoke !== 0 && invoke !== 1)) {\n        console.log(\"char.def parse error. INVOKE is 0 or 1 in:\" + invoke);\n        return null;\n    }\n    if (!isFinite(grouping) || (grouping !== 0 && grouping !== 1)) {\n        console.log(\"char.def parse error. GROUP is 0 or 1 in:\" + grouping);\n        return null;\n    }\n    if (!isFinite(max_length) || max_length < 0) {\n        console.log(\"char.def parse error. LENGTH is 1 to n:\" + max_length);\n        return null;\n    }\n    var is_invoke = (invoke === 1);\n    var is_grouping = (grouping === 1);\n\n    return new CharacterClass(class_id, category, is_invoke, is_grouping, max_length);\n};\n\nCharacterDefinition.parseCategoryMapping = function (parsed_category_mapping) {\n    var start = parseInt(parsed_category_mapping[1]);\n    var default_category = parsed_category_mapping[2];\n    var compatible_category = (3 < parsed_category_mapping.length) ? parsed_category_mapping.slice(3) : [];\n    if (!isFinite(start) || start < 0 || start > 0xFFFF) {\n        console.log(\"char.def parse error. CODE is invalid:\" + start);\n    }\n    return { start: start, default: default_category, compatible: compatible_category};\n};\n\nCharacterDefinition.parseRangeCategoryMapping = function (parsed_category_mapping) {\n    var start = parseInt(parsed_category_mapping[1]);\n    var end = parseInt(parsed_category_mapping[2]);\n    var default_category = parsed_category_mapping[3];\n    var compatible_category = (4 < parsed_category_mapping.length) ? parsed_category_mapping.slice(4) : [];\n    if (!isFinite(start) || start < 0 || start > 0xFFFF) {\n        console.log(\"char.def parse error. CODE is invalid:\" + start);\n    }\n    if (!isFinite(end) || end < 0 || end > 0xFFFF) {\n        console.log(\"char.def parse error. CODE is invalid:\" + end);\n    }\n    return { start: start, end: end, default: default_category, compatible: compatible_category};\n};\n\n/**\n * Initializing method\n * @param {Array} category_mapping Array of category mapping\n */\nCharacterDefinition.prototype.initCategoryMappings = function (category_mapping) {\n    // Initialize map by DEFAULT class\n    var code_point;\n    if (category_mapping != null) {\n        for (var i = 0; i < category_mapping.length; i++) {\n            var mapping = category_mapping[i];\n            var end = mapping.end || mapping.start;\n            for (code_point = mapping.start; code_point <= end; code_point++) {\n\n                // Default Category class ID\n                this.character_category_map[code_point] = this.invoke_definition_map.lookup(mapping.default);\n\n                for (var j = 0; j < mapping.compatible.length; j++) {\n                    var bitset = this.compatible_category_map[code_point];\n                    var compatible_category = mapping.compatible[j];\n                    if (compatible_category == null) {\n                        continue;\n                    }\n                    var class_id = this.invoke_definition_map.lookup(compatible_category);  // Default Category\n                    if (class_id == null) {\n                        continue;\n                    }\n                    var class_id_bit = 1 << class_id;\n                    bitset = bitset | class_id_bit;  // Set a bit of class ID 例えば、class_idが3のとき、3ビット目に1を立てる\n                    this.compatible_category_map[code_point] = bitset;\n                }\n            }\n        }\n    }\n    var default_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n    if (default_id == null) {\n        return;\n    }\n    for (code_point = 0; code_point < this.character_category_map.length; code_point++) {\n        // 他に何のクラスも定義されていなかったときだけ DEFAULT\n        if (this.character_category_map[code_point] === 0) {\n            // DEFAULT class ID に対応するビットだけ1を立てる\n            this.character_category_map[code_point] = 1 << default_id;\n        }\n    }\n};\n\n/**\n * Lookup compatible categories for a character (not included 1st category)\n * @param {string} ch UCS2 character (just 1st character is effective)\n * @returns {Array.<CharacterClass>} character classes\n */\nCharacterDefinition.prototype.lookupCompatibleCategory = function (ch) {\n    var classes = [];\n\n    /*\n     if (SurrogateAwareString.isSurrogatePair(ch)) {\n     // Surrogate pair character codes can not be defined by char.def\n     return classes;\n     }*/\n    var code = ch.charCodeAt(0);\n    var integer;\n    if (code < this.compatible_category_map.length) {\n        integer = this.compatible_category_map[code];  // Bitset\n    }\n\n    if (integer == null || integer === 0) {\n        return classes;\n    }\n\n    for (var bit = 0; bit < 32; bit++) {  // Treat \"bit\" as a class ID\n        if (((integer << (31 - bit)) >>> 31) === 1) {\n            var character_class = this.invoke_definition_map.getCharacterClass(bit);\n            if (character_class == null) {\n                continue;\n            }\n            classes.push(character_class);\n        }\n    }\n    return classes;\n};\n\n\n/**\n * Lookup category for a character\n * @param {string} ch UCS2 character (just 1st character is effective)\n * @returns {CharacterClass} character class\n */\nCharacterDefinition.prototype.lookup = function (ch) {\n\n    var class_id;\n\n    var code = ch.charCodeAt(0);\n    if (SurrogateAwareString.isSurrogatePair(ch)) {\n        // Surrogate pair character codes can not be defined by char.def, so set DEFAULT category\n        class_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n    } else if (code < this.character_category_map.length) {\n        class_id = this.character_category_map[code];  // Read as integer value\n    }\n\n    if (class_id == null) {\n        class_id = this.invoke_definition_map.lookup(DEFAULT_CATEGORY);\n    }\n\n    return this.invoke_definition_map.getCharacterClass(class_id);\n};\n\nmodule.exports = CharacterDefinition;\n"]},"metadata":{},"sourceType":"script"}