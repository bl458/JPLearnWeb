{"ast":null,"code":"import React from 'react';\nimport 'prop-types';\nimport styled from 'styled-components';\n/**\n * Returns detailed type as string (instead of just 'object' for arrays etc)\n * @private\n * @param {any} value js value\n * @returns {String} type of value\n * @example\n * typeOf({}); // 'object'\n * typeOf([]); // 'array'\n * typeOf(function() {}); // 'function'\n * typeOf(/a/); // 'regexp'\n * typeOf(new Date()); // 'date'\n * typeOf(null); // 'null'\n * typeOf(undefined); // 'undefined'\n * typeOf('a'); // 'string'\n * typeOf(1); // 'number'\n * typeOf(true); // 'boolean'\n * typeOf(new Map()); // 'map'\n * typeOf(new Set()); // 'map'\n */\n\nfunction typeOf(value) {\n  if (value === null) {\n    return 'null';\n  }\n\n  if (value !== Object(value)) {\n    return typeof value;\n  }\n\n  return {}.toString.call(value).slice(8, -1).toLowerCase();\n}\n/**\n * Checks if input string is empty\n * @param  {String} input text input\n * @return {Boolean} true if no input\n */\n\n\nfunction isEmpty(input) {\n  if (typeOf(input) !== 'string') {\n    return true;\n  }\n\n  return !input.length;\n}\n/**\n * Takes a character and a unicode range. Returns true if the char is in the range.\n * @param  {String}  char  unicode character\n * @param  {Number}  start unicode start range\n * @param  {Number}  end   unicode end range\n * @return {Boolean}\n */\n\n\nfunction isCharInRange(char = '', start, end) {\n  if (isEmpty(char)) return false;\n  const code = char.charCodeAt(0);\n  return start <= code && code <= end;\n}\n\nconst LOWERCASE_ZENKAKU_START = 0xff41;\nconst LOWERCASE_ZENKAKU_END = 0xff5a;\nconst UPPERCASE_ZENKAKU_START = 0xff21;\nconst UPPERCASE_ZENKAKU_END = 0xff3a;\nconst HIRAGANA_START = 0x3041;\nconst HIRAGANA_END = 0x3096;\nconst KATAKANA_START = 0x30a1;\nconst KATAKANA_END = 0x30fc;\nconst KANJI_START = 0x4e00;\nconst KANJI_END = 0x9faf;\nconst PROLONGED_SOUND_MARK = 0x30fc;\nconst ZENKAKU_NUMBERS = [0xff10, 0xff19];\nconst ZENKAKU_UPPERCASE = [UPPERCASE_ZENKAKU_START, UPPERCASE_ZENKAKU_END];\nconst ZENKAKU_LOWERCASE = [LOWERCASE_ZENKAKU_START, LOWERCASE_ZENKAKU_END];\nconst ZENKAKU_PUNCTUATION_1 = [0xff01, 0xff0f];\nconst ZENKAKU_PUNCTUATION_2 = [0xff1a, 0xff1f];\nconst ZENKAKU_PUNCTUATION_3 = [0xff3b, 0xff3f];\nconst ZENKAKU_PUNCTUATION_4 = [0xff5b, 0xff60];\nconst ZENKAKU_SYMBOLS_CURRENCY = [0xffe0, 0xffee];\nconst HIRAGANA_CHARS = [0x3040, 0x309f];\nconst KATAKANA_CHARS = [0x30a0, 0x30ff];\nconst HANKAKU_KATAKANA = [0xff66, 0xff9f];\nconst KATAKANA_PUNCTUATION = [0x30fb, 0x30fc];\nconst KANA_PUNCTUATION = [0xff61, 0xff65];\nconst CJK_SYMBOLS_PUNCTUATION = [0x3000, 0x303f];\nconst COMMON_CJK = [0x4e00, 0x9fff];\nconst RARE_CJK = [0x3400, 0x4dbf];\nconst KANA_RANGES = [HIRAGANA_CHARS, KATAKANA_CHARS, KANA_PUNCTUATION, HANKAKU_KATAKANA];\nconst JA_PUNCTUATION_RANGES = [CJK_SYMBOLS_PUNCTUATION, KANA_PUNCTUATION, KATAKANA_PUNCTUATION, ZENKAKU_PUNCTUATION_1, ZENKAKU_PUNCTUATION_2, ZENKAKU_PUNCTUATION_3, ZENKAKU_PUNCTUATION_4, ZENKAKU_SYMBOLS_CURRENCY]; // All Japanese unicode start and end ranges\n// Includes kanji, kana, zenkaku latin chars, punctuation, and number ranges.\n\nconst JAPANESE_RANGES = [...KANA_RANGES, ...JA_PUNCTUATION_RANGES, ZENKAKU_UPPERCASE, ZENKAKU_LOWERCASE, ZENKAKU_NUMBERS, COMMON_CJK, RARE_CJK];\nconst MODERN_ENGLISH = [0x0000, 0x007f];\nconst HEPBURN_MACRON_RANGES = [[0x0100, 0x0101], // Ā ā\n[0x0112, 0x0113], // Ē ē\n[0x012a, 0x012b], // Ī ī\n[0x014c, 0x014d], // Ō ō\n[0x016a, 0x016b]];\nconst SMART_QUOTE_RANGES = [[0x2018, 0x2019], // ‘ ’\n[0x201c, 0x201d]];\nconst ROMAJI_RANGES = [MODERN_ENGLISH, ...HEPBURN_MACRON_RANGES];\nconst EN_PUNCTUATION_RANGES = [[0x20, 0x2f], [0x3a, 0x3f], [0x5b, 0x60], [0x7b, 0x7e], ...SMART_QUOTE_RANGES];\n/**\n * Tests a character. Returns true if the character is [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\n\nfunction isCharJapanese(char = '') {\n  return JAPANESE_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n/**\n * Test if `input` only includes [Kanji](https://en.wikipedia.org/wiki/Kanji), [Kana](https://en.wikipedia.org/wiki/Kana), zenkaku numbers, and JA punctuation/symbols.”\n * @param  {String} [input=''] text\n * @param  {Regexp} [allowed] additional test allowed to pass for each char\n * @return {Boolean} true if passes checks\n * @example\n * isJapanese('泣き虫')\n * // => true\n * isJapanese('あア')\n * // => true\n * isJapanese('２月') // Zenkaku numbers allowed\n * // => true\n * isJapanese('泣き虫。！〜＄') // Zenkaku/JA punctuation\n * // => true\n * isJapanese('泣き虫.!~$') // Latin punctuation fails\n * // => false\n * isJapanese('A泣き虫')\n * // => false\n * isJapanese('≪偽括弧≫', /[≪≫]/);\n * // => true\n */\n\n\nfunction isJapanese(input = '', allowed) {\n  const augmented = typeOf(allowed) === 'regexp';\n  return isEmpty(input) ? false : [...input].every(char => {\n    const isJa = isCharJapanese(char);\n    return !augmented ? isJa : isJa || allowed.test(char);\n  });\n}\n/**\n * Returns true if char is 'ー'\n * @param  {String} char to test\n * @return {Boolean}\n */\n\n\nfunction isCharLongDash(char = '') {\n  if (isEmpty(char)) return false;\n  return char.charCodeAt(0) === PROLONGED_SOUND_MARK;\n}\n/**\n * Tests a character. Returns true if the character is [Hiragana](https://en.wikipedia.org/wiki/Hiragana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\n\n\nfunction isCharHiragana(char = '') {\n  if (isEmpty(char)) return false;\n  if (isCharLongDash(char)) return true;\n  return isCharInRange(char, HIRAGANA_START, HIRAGANA_END);\n}\n/**\n * Tests a character. Returns true if the character is [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\n\n\nfunction isCharKatakana(char = '') {\n  return isCharInRange(char, KATAKANA_START, KATAKANA_END);\n}\n/**\n * Tests a character. Returns true if the character is [Hiragana](https://en.wikipedia.org/wiki/Hiragana) or [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\n\n\nfunction isCharKana(char = '') {\n  if (isEmpty(char)) return false;\n  return isCharHiragana(char) || isCharKatakana(char);\n}\n/**\n * Test if `input` is [Kana](https://en.wikipedia.org/wiki/Kana) ([Katakana](https://en.wikipedia.org/wiki/Katakana) and/or [Hiragana](https://en.wikipedia.org/wiki/Hiragana))\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Kana](https://en.wikipedia.org/wiki/Kana)\n * @example\n * isKana('あ')\n * // => true\n * isKana('ア')\n * // => true\n * isKana('あーア')\n * // => true\n * isKana('A')\n * // => false\n * isKana('あAア')\n * // => false\n */\n\n\nfunction isKana(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharKana);\n}\n/**\n * Tests a character. Returns true if the character is a CJK ideograph (kanji).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\n\n\nfunction isCharKanji(char = '') {\n  return isCharInRange(char, KANJI_START, KANJI_END);\n}\n/**\n * Tests if `input` is [Kanji](https://en.wikipedia.org/wiki/Kanji) ([Japanese CJK ideographs](https://en.wikipedia.org/wiki/CJK_Unified_Ideographs))\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Kanji](https://en.wikipedia.org/wiki/Kanji)\n * @example\n * isKanji('刀')\n * // => true\n * isKanji('切腹')\n * // => true\n * isKanji('勢い')\n * // => false\n * isKanji('あAア')\n * // => false\n * isKanji('🐸')\n * // => false\n */\n\n\nfunction isKanji(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharKanji);\n}\n/**\n * Tests a character. Returns true if the character is considered English punctuation.\n * @param  {String} char character string to test\n * @return {Boolean}\n */\n\n\nfunction isCharEnglishPunctuation(char = '') {\n  if (isEmpty(char)) return false;\n  return EN_PUNCTUATION_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n/**\n * Tests a character. Returns true if the character is considered English punctuation.\n * @param  {String} char character string to test\n * @return {Boolean}\n */\n\n\nfunction isCharJapanesePunctuation(char = '') {\n  if (isEmpty(char)) return false;\n  return JA_PUNCTUATION_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n/**\n * Tests a character. Returns true if the character is [Romaji](https://en.wikipedia.org/wiki/Romaji) (allowing [Hepburn romanisation](https://en.wikipedia.org/wiki/Hepburn_romanization))\n * @param  {String} char character string to test\n * @return {Boolean}\n */\n\n\nfunction isCharRomaji(char = '') {\n  if (isEmpty(char)) return false;\n  return ROMAJI_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n\nconst isCharEnSpace = x => x === ' ';\n\nconst isCharJaSpace = x => x === '　';\n\nconst isCharJaNum = x => /[０-９]/.test(x);\n\nconst isCharEnNum = x => /[0-9]/.test(x);\n\nconst TOKEN_TYPES = {\n  EN: 'en',\n  JA: 'ja',\n  EN_NUM: 'englishNumeral',\n  JA_NUM: 'japaneseNumeral',\n  EN_PUNC: 'englishPunctuation',\n  JA_PUNC: 'japanesePunctuation',\n  KANJI: 'kanji',\n  HIRAGANA: 'hiragana',\n  KATAKANA: 'katakana',\n  SPACE: 'space',\n  OTHER: 'other'\n}; // prettier-ignore\n\nfunction getType(input, compact = false) {\n  const {\n    EN,\n    JA,\n    EN_NUM,\n    JA_NUM,\n    EN_PUNC,\n    JA_PUNC,\n    KANJI,\n    HIRAGANA,\n    KATAKANA,\n    SPACE,\n    OTHER\n  } = TOKEN_TYPES;\n\n  if (compact) {\n    switch (true) {\n      case isCharJaNum(input):\n        return OTHER;\n\n      case isCharEnNum(input):\n        return OTHER;\n\n      case isCharEnSpace(input):\n        return EN;\n\n      case isCharEnglishPunctuation(input):\n        return OTHER;\n\n      case isCharJaSpace(input):\n        return JA;\n\n      case isCharJapanesePunctuation(input):\n        return OTHER;\n\n      case isCharJapanese(input):\n        return JA;\n\n      case isCharRomaji(input):\n        return EN;\n\n      default:\n        return OTHER;\n    }\n  } else {\n    switch (true) {\n      case isCharJaSpace(input):\n        return SPACE;\n\n      case isCharEnSpace(input):\n        return SPACE;\n\n      case isCharJaNum(input):\n        return JA_NUM;\n\n      case isCharEnNum(input):\n        return EN_NUM;\n\n      case isCharEnglishPunctuation(input):\n        return EN_PUNC;\n\n      case isCharJapanesePunctuation(input):\n        return JA_PUNC;\n\n      case isCharKanji(input):\n        return KANJI;\n\n      case isCharHiragana(input):\n        return HIRAGANA;\n\n      case isCharKatakana(input):\n        return KATAKANA;\n\n      case isCharJapanese(input):\n        return JA;\n\n      case isCharRomaji(input):\n        return EN;\n\n      default:\n        return OTHER;\n    }\n  }\n}\n/**\n * Splits input into array of strings separated by opinionated token types\n * `'en', 'ja', 'englishNumeral', 'japaneseNumeral','englishPunctuation', 'japanesePunctuation','kanji', 'hiragana', 'katakana', 'space', 'other'`.\n * If `{ compact: true }` then many same-language tokens are combined (spaces + text, kanji + kana, numeral + punctuation).\n * If `{ detailed: true }` then return array will contain `{ type, value }` instead of `'value'`\n * @param  {String} input text\n * @param  {Object} [options={ compact: false, detailed: false}] options to modify output style\n * @return {String|Object[]} text split into tokens containing values, or detailed object\n * @example\n * tokenize('ふふフフ')\n * // ['ふふ', 'フフ']\n *\n * tokenize('感じ')\n * // ['感', 'じ']\n *\n * tokenize('truly 私は悲しい')\n * // ['truly', ' ', '私', 'は', '悲', 'しい']\n *\n * tokenize('truly 私は悲しい', { compact: true })\n * // ['truly ', '私は悲しい']\n *\n * tokenize('5romaji here...!?漢字ひらがな４カタ　カナ「ＳＨＩＯ」。！')\n * // [ '5', 'romaji', ' ', 'here', '...!?', '漢字', 'ひらがな', 'カタ', '　', 'カナ', '４', '「', 'ＳＨＩＯ', '」。！']\n *\n * tokenize('5romaji here...!?漢字ひらがな４カタ　カナ「ＳＨＩＯ」。！', { compact: true })\n * // [ '5', 'romaji here', '...!?', '漢字ひらがなカタ　カナ', '４「', 'ＳＨＩＯ', '」。！']\n *\n * tokenize('5romaji here...!?漢字ひらがなカタ　カナ４「ＳＨＩＯ」。！ لنذهب', { detailed: true })\n * // [\n *  { type: 'englishNumeral', value: '5' },\n *  { type: 'en', value: 'romaji' },\n *  { type: 'space', value: ' ' },\n *  { type: 'en', value: 'here' },\n *  { type: 'englishPunctuation', value: '...!?' },\n *  { type: 'kanji', value: '漢字' },\n *  { type: 'hiragana', value: 'ひらがな' },\n *  { type: 'katakana', value: 'カタ' },\n *  { type: 'space', value: '　' },\n *  { type: 'katakana', value: 'カナ' },\n *  { type: 'japaneseNumeral', value: '４' },\n *  { type: 'japanesePunctuation', value: '「' },\n *  { type: 'ja', value: 'ＳＨＩＯ' },\n *  { type: 'japanesePunctuation', value: '」。！' },\n *  { type: 'space', value: ' ' },\n *  { type: 'other', value: 'لنذهب' },\n * ]\n *\n * tokenize('5romaji here...!?漢字ひらがなカタ　カナ４「ＳＨＩＯ」。！ لنذهب', { compact: true, detailed: true})\n * // [\n *  { type: 'other', value: '5' },\n *  { type: 'en', value: 'romaji here' },\n *  { type: 'other', value: '...!?' },\n *  { type: 'ja', value: '漢字ひらがなカタ　カナ' },\n *  { type: 'other', value: '４「' },\n *  { type: 'ja', value: 'ＳＨＩＯ' },\n *  { type: 'other', value: '」。！' },\n *  { type: 'en', value: ' ' },\n *  { type: 'other', value: 'لنذهب' },\n *]\n */\n\n\nfunction tokenize(input, {\n  compact = false,\n  detailed = false\n} = {}) {\n  if (input == null || isEmpty(input)) {\n    return [];\n  }\n\n  const chars = [...input];\n  let initial = chars.shift();\n  let prevType = getType(initial, compact);\n  initial = detailed ? {\n    type: prevType,\n    value: initial\n  } : initial;\n  const result = chars.reduce((tokens, char) => {\n    const currType = getType(char, compact);\n    const sameType = currType === prevType;\n    prevType = currType;\n    let newValue = char;\n\n    if (sameType) {\n      newValue = (detailed ? tokens.pop().value : tokens.pop()) + newValue;\n    }\n\n    return detailed ? tokens.concat({\n      type: currType,\n      value: newValue\n    }) : tokens.concat(newValue);\n  }, [initial]);\n  return result;\n}\n\nconst isLeadingWithoutInitialKana = (input, leading) => leading && !isKana(input[0]);\n\nconst isTrailingWithoutFinalKana = (input, leading) => !leading && !isKana(input[input.length - 1]);\n\nconst isInvalidMatcher = (input, matchKanji) => matchKanji && ![...matchKanji].some(isKanji) || !matchKanji && isKana(input);\n/**\n * Strips [Okurigana](https://en.wikipedia.org/wiki/Okurigana)\n * @param  {String} input text\n * @param  {Object} [options={ leading: false, matchKanji: '' }] optional config\n * @return {String} text with okurigana removed\n * @example\n * stripOkurigana('踏み込む')\n * // => '踏み込'\n * stripOkurigana('お祝い')\n * // => 'お祝'\n * stripOkurigana('お腹', { leading: true });\n * // => '腹'\n * stripOkurigana('ふみこむ', { matchKanji: '踏み込む' });\n * // => 'ふみこ'\n * stripOkurigana('おみまい', { matchKanji: 'お祝い', leading: true });\n * // => 'みまい'\n */\n\n\nfunction stripOkurigana(input = '', {\n  leading = false,\n  matchKanji = ''\n} = {}) {\n  if (!isJapanese(input) || isLeadingWithoutInitialKana(input, leading) || isTrailingWithoutFinalKana(input, leading) || isInvalidMatcher(input, matchKanji)) {\n    return input;\n  }\n\n  const chars = matchKanji || input;\n  const okuriganaRegex = new RegExp(leading ? `^${tokenize(chars).shift()}` : `${tokenize(chars).pop()}$`);\n  return input.replace(okuriganaRegex, '');\n}\n/**\n * Test if `input` is [Hiragana](https://en.wikipedia.org/wiki/Hiragana)\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Hiragana](https://en.wikipedia.org/wiki/Hiragana)\n * @example\n * isHiragana('げーむ')\n * // => true\n * isHiragana('A')\n * // => false\n * isHiragana('あア')\n * // => false\n */\n\n\nfunction isHiragana(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharHiragana);\n}\n/**\n * Test if `input` is [Katakana](https://en.wikipedia.org/wiki/Katakana)\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Katakana](https://en.wikipedia.org/wiki/Katakana)\n * @example\n * isKatakana('ゲーム')\n * // => true\n * isKatakana('あ')\n * // => false\n * isKatakana('A')\n * // => false\n * isKatakana('あア')\n * // => false\n */\n\n\nfunction isKatakana(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharKatakana);\n}\n\nvar justZipIt = zip;\n/*\n  zip([1, 2, 3]); // [[1], [2], [3]]\n  zip([1, 2, 3], ['a', 'b', 'c']); // [[1, 'a'], [2, 'b'], [3, 'c']]\n  zip([1, 2], ['a', 'b'], [true, false]); //[[1, 'a', true], [2, 'b', false]]\n\n  zip([1, 2, 3], ['a', 'b'], [true]);\n  // [[1, 'a', true], [2, 'b', undefined], [3, undefined, undefined]]\n\n  zip(undefined, {}, false, 1, 'foo'); // throws\n  zip([1, 2], ['a', 'b'], undefined, {}, false, 1, 'foo'); // throws\n  \n*/\n\nfunction zip() {\n  var result = [];\n  var args = Array.prototype.slice.call(arguments);\n  var argsLen = args.length;\n  var maxLen = 0;\n  var i, j;\n\n  if (!argsLen) {\n    throw new Error('zip requires at least one argument');\n  }\n\n  for (i = 0; i < argsLen; i++) {\n    if (!Array.isArray(args[i])) {\n      throw new Error('all arguments must be arrays');\n    }\n\n    var arrLen = args[i].length;\n\n    if (arrLen > maxLen) {\n      maxLen = arrLen;\n    }\n  }\n\n  for (i = 0; i < maxLen; i++) {\n    var group = [];\n\n    for (j = 0; j < argsLen; j++) {\n      if (!Array.isArray(args[j])) {\n        throw new Error('all arguments must be arrays');\n      }\n\n      group[j] = args[j][i];\n    }\n\n    result[i] = group;\n  }\n\n  return result;\n}\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar taggedTemplateLiteral = function (strings, raw) {\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n};\n\nvar toArray = function (arr) {\n  return Array.isArray(arr) ? arr : Array.from(arr);\n};\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n/**\n * Combines furigana with kanji into an array of string pairs.\n * @param  {String} word vocab kanji word\n * @param  {String} reading vocab kana reading\n * @param  {String|Object} furi furigana placement info\n * @return {Array} furigana/kanji pairs\n * @example\n * combineFuri('お世辞', 'おせじ', '1:せ;2:じ')\n * // => [['', 'お'], ['せ', '世'], ['じ', '辞']]\n * combineFuri('大人しい', 'おとなしい') // smart fallbacks\n * // => [['おとな', '大人'], ['', 'しい']]\n * combineFuri('使い方', 'つかいかた') // smart fallbacks\n * // => [['つか', '使'], ['', 'い'], ['かた', '方']]\n *\n * // special compound readings (義訓/熟字訓) are spread across relevant kanji\n * combineFuri('胡座', 'あぐら', '0:あぐら')\n * // => [['あぐら', '胡座']]\n */\n\n\nfunction combineFuri() {\n  var word = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var reading = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var furi = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var furiLocs = parseFuri(furi); // 義訓/熟字訓 words with a single furi loc: 今日 \"0:きょう\"\n\n  var isSpecialReading = furiLocs.length === 1 && [].concat(toConsumableArray(word)).every(isKanji);\n  var isKanaWord = [].concat(toConsumableArray(word)).every(isKana);\n  var isWanikaniMadness = [].concat(toConsumableArray(reading)).some(isHiragana) && [].concat(toConsumableArray(reading)).some(isKatakana);\n\n  if (word === reading || isKanaWord) {\n    return [['', word]];\n  }\n\n  if (!furi || isSpecialReading || isWanikaniMadness) {\n    return basicFuri(word, reading);\n  }\n\n  return generatePairs(word, furiLocs);\n}\n/**\n * Displays simple furigana by removing redundant kana\n * @param  {String} [word=''] 'お見舞い'\n * @param  {String} [reading=''] 'おみまい'\n * @return {Array} [['', 'お'], ['見舞', 'みま'], ['', 'い']]\n */\n\n\nfunction basicFuri() {\n  var word = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var reading = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ''; // early return + guard against words like １日 which are tokenized unfavourably\n\n  if ([].concat(toConsumableArray(word)).every(function (c) {\n    return !isKana(c);\n  })) {\n    return [[reading, word]];\n  }\n\n  var _ref = [reading.slice(0, word.length - stripOkurigana(word, {\n    leading: true\n  }).length), reading.slice(stripOkurigana(reading, {\n    matchKanji: word\n  }).length)],\n      bikago = _ref[0],\n      okurigana = _ref[1];\n  var innerWordTokens = tokenize(removeExtraneousKana(word, bikago, okurigana));\n  var innerReadingChars = removeExtraneousKana(reading, bikago, okurigana);\n  var kanjiOddKanaEvenRegex = RegExp(innerWordTokens.map(function (char) {\n    return isKanji(char) ? '(.*)' : '(' + char + ')';\n  }).join(''));\n\n  var _ref2 = innerReadingChars.match(kanjiOddKanaEvenRegex) || [];\n\n  var _ref3 = toArray(_ref2);\n\n  innerReadingChars = _ref3.slice(1);\n  var ret = justZipIt(innerReadingChars, innerWordTokens).map(skipRedundantReadings);\n\n  if (bikago) {\n    ret.unshift(['', bikago]);\n  }\n\n  if (okurigana) {\n    ret.push(['', okurigana]);\n  }\n\n  return ret;\n}\n\nfunction removeExtraneousKana() {\n  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var leading = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var trailing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  return str.replace(RegExp('^' + leading), '').replace(RegExp(trailing + '$'), '');\n}\n\nfunction skipRedundantReadings(_ref4) {\n  var _ref5 = slicedToArray(_ref4, 2),\n      reading = _ref5[0],\n      _ref5$ = _ref5[1],\n      word = _ref5$ === undefined ? '' : _ref5$;\n\n  return !reading || reading === word ? ['', word] : [reading, word];\n}\n\nfunction parseFuri(data) {\n  return typeof data === 'string' ? parseFuriString(data) : parseFuriObject(data);\n}\n/**\n * Parses furigana placement object\n * @param  {Object} [locations={}] { 1:'せ', 2:'じ' }\n * @return {Array} [ [[1, 2], 'せ'], [[2, 3], 'じ'] ]\n */\n\n\nfunction parseFuriObject() {\n  var locations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return Object.entries(locations).map(function (_ref6) {\n    var _ref7 = slicedToArray(_ref6, 2),\n        start = _ref7[0],\n        content = _ref7[1];\n\n    return [[Number(start), Number(start) + 1], content];\n  });\n}\n/**\n * Parses furigana placement string\n * @param  {String} [locations=''] '1:せ;2:じ'\n * @return {Array} [ [[1, 2], 'せ'], [[2, 3], 'じ'] ]\n */\n\n\nfunction parseFuriString() {\n  var locations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return locations.split(';').map(function (entry) {\n    var _entry$split = entry.split(':'),\n        _entry$split2 = slicedToArray(_entry$split, 2),\n        indexes = _entry$split2[0],\n        content = _entry$split2[1];\n\n    var _indexes$split$map = indexes.split('-').map(Number),\n        _indexes$split$map2 = slicedToArray(_indexes$split$map, 2),\n        start = _indexes$split$map2[0],\n        end = _indexes$split$map2[1]; // NOTE: in the JMDict furistring data, the end index is either missing\n    // or it is listed as the *start* index of the final char ¯\\_(ツ)_/¯\n    // so we need to bump it either way to encompass that char\n\n\n    return [[start, end ? end + 1 : start + 1], content];\n  });\n}\n/**\n * Generates array pairs via furigana location data\n * @param  {String} word 'お世辞'\n * @param  {Array} furiLocs [[[1, 2], 'せ'], [[2, 3], 'じ']]\n * @return {Array} [['', 'お'], ['せ', '世'], ['じ', '辞']]\n */\n\n\nfunction generatePairs() {\n  var word = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var furiLocs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var prevCharEnd = 0;\n  return furiLocs.reduce(function (pairs, _ref8, index, source) {\n    var _ref9 = slicedToArray(_ref8, 2),\n        _ref9$ = slicedToArray(_ref9[0], 2),\n        start = _ref9$[0],\n        end = _ref9$[1],\n        furiText = _ref9[1]; // if no furigana at this index, add intervening chars\n\n\n    if (start !== prevCharEnd) {\n      pairs.push(['', word.slice(prevCharEnd, start)]);\n    } // add furigana and associated chars\n\n\n    pairs.push([furiText, word.slice(start, end)]); // if no more furigana left, add any remaining chars/okurigana with blank furi\n\n    if (end < word.length && !source[index + 1]) {\n      pairs.push(['', word.slice(end)]);\n    }\n\n    prevCharEnd = end;\n    return pairs;\n  }, []);\n}\n\nvar _templateObject = taggedTemplateLiteral(['\\n  display: inline-flex;\\n  flex-flow: row wrap;\\n  font-family: \\'\\u30D2\\u30E9\\u30AE\\u30CE\\u89D2\\u30B4 ProN\\', \\'Hiragino Kaku Gothic ProN\\', \\'TakaoP\\u30B4\\u30B7\\u30C3\\u30AF\\', TakaoPGothic,\\n    \\'\\u6E38\\u30B4\\u30B7\\u30C3\\u30AF\\', \\'\\u6E38\\u30B4\\u30B7\\u30C3\\u30AF\\u4F53\\', YuGothic, \\'Yu Gothic\\', \\'\\u30E1\\u30A4\\u30EA\\u30AA\\', Meiryo, \\'\\uFF2D\\uFF33 \\u30B4\\u30B7\\u30C3\\u30AF\\',\\n    \\'MS Gothic\\', HiraKakuProN-W3, \\'MotoyaLCedar\\', \\'Droid Sans Japanese\\', sans-serif;\\n'], ['\\n  display: inline-flex;\\n  flex-flow: row wrap;\\n  font-family: \\'\\u30D2\\u30E9\\u30AE\\u30CE\\u89D2\\u30B4 ProN\\', \\'Hiragino Kaku Gothic ProN\\', \\'TakaoP\\u30B4\\u30B7\\u30C3\\u30AF\\', TakaoPGothic,\\n    \\'\\u6E38\\u30B4\\u30B7\\u30C3\\u30AF\\', \\'\\u6E38\\u30B4\\u30B7\\u30C3\\u30AF\\u4F53\\', YuGothic, \\'Yu Gothic\\', \\'\\u30E1\\u30A4\\u30EA\\u30AA\\', Meiryo, \\'\\uFF2D\\uFF33 \\u30B4\\u30B7\\u30C3\\u30AF\\',\\n    \\'MS Gothic\\', HiraKakuProN-W3, \\'MotoyaLCedar\\', \\'Droid Sans Japanese\\', sans-serif;\\n']),\n    _templateObject2 = taggedTemplateLiteral(['\\n  display: inline-flex;\\n  font-size: 24px;\\n  line-height: 1;\\n  flex-flow: column nowrap;\\n  justify-content: flex-end;\\n  align-items: center;\\n  align-self: flex-end;\\n'], ['\\n  display: inline-flex;\\n  font-size: 24px;\\n  line-height: 1;\\n  flex-flow: column nowrap;\\n  justify-content: flex-end;\\n  align-items: center;\\n  align-self: flex-end;\\n']),\n    _templateObject3 = taggedTemplateLiteral(['\\n  display: block;\\n  font-size: 0.5em;\\n  letter-spacing: -0.02em;\\n  margin: 0 0.1em;\\n  padding-top: 0.2em;\\n  padding-bottom: 0.1em;\\n  user-select: none; /* don\\'t interfere with main text selection */\\n  opacity: 0.9;\\n'], ['\\n  display: block;\\n  font-size: 0.5em;\\n  letter-spacing: -0.02em;\\n  margin: 0 0.1em;\\n  padding-top: 0.2em;\\n  padding-bottom: 0.1em;\\n  user-select: none; /* don\\'t interfere with main text selection */\\n  opacity: 0.9;\\n']),\n    _templateObject4 = taggedTemplateLiteral(['\\n  display: block;\\n'], ['\\n  display: block;\\n']);\n\nvar Wrapper = styled.span(_templateObject);\nvar Pair = styled.span(_templateObject2);\nvar Furi = styled.span(_templateObject3);\nvar Text = styled.span(_templateObject4);\n\nfunction ReactFuri(_ref) {\n  var word = _ref.word,\n      reading = _ref.reading,\n      furi = _ref.furi,\n      showFuri = _ref.showFuri,\n      render = _ref.render,\n      props = objectWithoutProperties(_ref, ['word', 'reading', 'furi', 'showFuri', 'render']);\n  var pairs = combineFuri(word, reading, furi);\n  return render ? render({\n    pairs: pairs\n  }) : React.createElement(Wrapper, _extends({\n    lang: 'ja'\n  }, props), pairs.map(function (_ref2, index) {\n    var _ref3 = slicedToArray(_ref2, 2),\n        furiText = _ref3[0],\n        text = _ref3[1];\n\n    return (// \"list\" is static, index is fine\n      // eslint-disable-next-line react/no-array-index-key\n      React.createElement(Pair, {\n        key: index\n      }, showFuri && React.createElement(Furi, null, furiText), React.createElement(Text, null, text))\n    );\n  }));\n}\n\nReactFuri.defaultProps = {\n  reading: '',\n  furi: '',\n  showFuri: true\n};\nReactFuri.Wrapper = Wrapper;\nReactFuri.Pair = Pair;\nReactFuri.Furi = Furi;\nReactFuri.Text = Text;\nexport default ReactFuri;","map":{"version":3,"sources":["../node_modules/wanakana/es/utils/typeOf.js","../node_modules/wanakana/es/utils/isEmpty.js","../node_modules/wanakana/es/utils/isCharInRange.js","../node_modules/wanakana/es/constants.js","../node_modules/wanakana/es/utils/isCharJapanese.js","../node_modules/wanakana/es/isJapanese.js","../node_modules/wanakana/es/utils/isCharLongDash.js","../node_modules/wanakana/es/utils/isCharHiragana.js","../node_modules/wanakana/es/utils/isCharKatakana.js","../node_modules/wanakana/es/utils/isCharKana.js","../node_modules/wanakana/es/isKana.js","../node_modules/wanakana/es/utils/isCharKanji.js","../node_modules/wanakana/es/isKanji.js","../node_modules/wanakana/es/utils/isCharEnglishPunctuation.js","../node_modules/wanakana/es/utils/isCharJapanesePunctuation.js","../node_modules/wanakana/es/utils/isCharRomaji.js","../node_modules/wanakana/es/tokenize.js","../node_modules/wanakana/es/stripOkurigana.js","../node_modules/wanakana/es/isHiragana.js","../node_modules/wanakana/es/isKatakana.js","../node_modules/just-zip-it/index.js","../src/utils.js","../src/index.js"],"names":["word","reading","furi","furiLocs","parseFuri","isSpecialReading","isKanaWord","isWanikaniMadness","basicFuri","generatePairs","isKana","bikago","okurigana","stripOkurigana","leading","matchKanji","innerWordTokens","tokenize","removeExtraneousKana","innerReadingChars","kanjiOddKanaEvenRegex","isKanji","ret","zip","str","trailing","RegExp","parseFuriString","parseFuriObject","locations","start","content","Number","indexes","entry","end","prevCharEnd","furiText","source","index","Wrapper","styled","Pair","Furi","Text","showFuri","render","props","pairs","combineFuri","text","ReactFuri"],"mappings":";;;AAAA;;;;;;;;;;;;;;;;;;;;AAmBA,SAAS,MAAT,CAAgB,KAAhB,EAAuB;AACrB,MAAI,KAAK,KAAK,IAAd,EAAoB;AAClB,WAAO,MAAP;AACD;;AACD,MAAI,KAAK,KAAK,MAAM,CAAC,KAAD,CAApB,EAA6B;AAC3B,WAAO,OAAO,KAAd;AACD;;AACD,SAAO,GAAG,QAAH,CAAY,IAAZ,CAAiB,KAAjB,EAAwB,KAAxB,CAA8B,CAA9B,EAAiC,CAAC,CAAlC,EAAqC,WAArC,EAAP;AACD;AC1BD;;;;;;;AAKA,SAAS,OAAT,CAAiB,KAAjB,EAAwB;AACtB,MAAI,MAAM,CAAC,KAAD,CAAN,KAAkB,QAAtB,EAAgC;AAC9B,WAAO,IAAP;AACD;;AACD,SAAO,CAAC,KAAK,CAAC,MAAd;AACD;ACTD;;;;;;;;;AAOA,SAAS,aAAT,CAAuB,IAAI,GAAG,EAA9B,EAAkC,KAAlC,EAAyC,GAAzC,EAA8C;AAC5C,MAAI,OAAO,CAAC,IAAD,CAAX,EAAmB,OAAO,KAAP;AACnB,QAAM,IAAI,GAAG,IAAI,CAAC,UAAL,CAAgB,CAAhB,CAAb;AACA,SAAO,KAAK,IAAI,IAAT,IAAiB,IAAI,IAAI,GAAhC;AACD;;AC0CM,MAAM,uBAAuB,GAAG,MAAhC;AACA,MAAM,qBAAqB,GAAG,MAA9B;AACA,MAAM,uBAAuB,GAAG,MAAhC;AACA,MAAM,qBAAqB,GAAG,MAA9B;AACA,MAAM,cAAc,GAAG,MAAvB;AACA,MAAM,YAAY,GAAG,MAArB;AACA,MAAM,cAAc,GAAG,MAAvB;AACA,MAAM,YAAY,GAAG,MAArB;AACA,MAAM,WAAW,GAAG,MAApB;AACA,MAAM,SAAS,GAAG,MAAlB;AACA,MAAM,oBAAoB,GAAG,MAA7B;AAGP,MAAM,eAAe,GAAG,CAAC,MAAD,EAAS,MAAT,CAAxB;AACA,MAAM,iBAAiB,GAAG,CAAC,uBAAD,EAA0B,qBAA1B,CAA1B;AACA,MAAM,iBAAiB,GAAG,CAAC,uBAAD,EAA0B,qBAA1B,CAA1B;AACA,MAAM,qBAAqB,GAAG,CAAC,MAAD,EAAS,MAAT,CAA9B;AACA,MAAM,qBAAqB,GAAG,CAAC,MAAD,EAAS,MAAT,CAA9B;AACA,MAAM,qBAAqB,GAAG,CAAC,MAAD,EAAS,MAAT,CAA9B;AACA,MAAM,qBAAqB,GAAG,CAAC,MAAD,EAAS,MAAT,CAA9B;AACA,MAAM,wBAAwB,GAAG,CAAC,MAAD,EAAS,MAAT,CAAjC;AAEA,MAAM,cAAc,GAAG,CAAC,MAAD,EAAS,MAAT,CAAvB;AACA,MAAM,cAAc,GAAG,CAAC,MAAD,EAAS,MAAT,CAAvB;AACA,MAAM,gBAAgB,GAAG,CAAC,MAAD,EAAS,MAAT,CAAzB;AACA,MAAM,oBAAoB,GAAG,CAAC,MAAD,EAAS,MAAT,CAA7B;AACA,MAAM,gBAAgB,GAAG,CAAC,MAAD,EAAS,MAAT,CAAzB;AACA,MAAM,uBAAuB,GAAG,CAAC,MAAD,EAAS,MAAT,CAAhC;AACA,MAAM,UAAU,GAAG,CAAC,MAAD,EAAS,MAAT,CAAnB;AACA,MAAM,QAAQ,GAAG,CAAC,MAAD,EAAS,MAAT,CAAjB;AAEO,MAAM,WAAW,GAAG,CAAC,cAAD,EAAiB,cAAjB,EAAiC,gBAAjC,EAAmD,gBAAnD,CAApB;AAEA,MAAM,qBAAqB,GAAG,CAAC,uBAAD,EAA0B,gBAA1B,EAA4C,oBAA5C,EAAkE,qBAAlE,EAAyF,qBAAzF,EAAgH,qBAAhH,EAAuI,qBAAvI,EAA8J,wBAA9J,CAA9B,C;;;AAIA,MAAM,eAAe,GAAG,CAAC,GAAG,WAAJ,EAAiB,GAAG,qBAApB,EAA2C,iBAA3C,EAA8D,iBAA9D,EAAiF,eAAjF,EAAkG,UAAlG,EAA8G,QAA9G,CAAxB;AAEP,MAAM,cAAc,GAAG,CAAC,MAAD,EAAS,MAAT,CAAvB;AACA,MAAM,qBAAqB,GAAG,CAAC,CAAC,MAAD,EAAS,MAAT,CAAD,EAAiB;AAC/C,CAAC,MAAD,EAAS,MAAT,CAD8B,EACd;AAChB,CAAC,MAAD,EAAS,MAAT,CAF8B,EAEd;AAChB,CAAC,MAAD,EAAS,MAAT,CAH8B,EAGd;AAChB,CAAC,MAAD,EAAS,MAAT,CAJ8B,CAA9B;AAKA,MAAM,kBAAkB,GAAG,CAAC,CAAC,MAAD,EAAS,MAAT,CAAD,EAAiB;AAC5C,CAAC,MAAD,EAAS,MAAT,CAD2B,CAA3B;AAGO,MAAM,aAAa,GAAG,CAAC,cAAD,EAAiB,GAAG,qBAApB,CAAtB;AAEA,MAAM,qBAAqB,GAAG,CAAC,CAAC,IAAD,EAAO,IAAP,CAAD,EAAe,CAAC,IAAD,EAAO,IAAP,CAAf,EAA6B,CAAC,IAAD,EAAO,IAAP,CAA7B,EAA2C,CAAC,IAAD,EAAO,IAAP,CAA3C,EAAyD,GAAG,kBAA5D,CAA9B;AAA8G;;;;;;ACjGrH,SAAS,cAAT,CAAwB,IAAI,GAAG,EAA/B,EAAmC;AACjC,SAAO,eAAe,CAAC,IAAhB,CAAqB,CAAC,CAAC,KAAD,EAAQ,GAAR,CAAD,KAAkB,aAAa,CAAC,IAAD,EAAO,KAAP,EAAc,GAAd,CAApD,CAAP;AACD;ACND;;;;;;;;;;;;;;;;;;;;;;;AAqBA,SAAS,UAAT,CAAoB,KAAK,GAAG,EAA5B,EAAgC,OAAhC,EAAyC;AACvC,QAAM,SAAS,GAAG,MAAM,CAAC,OAAD,CAAN,KAAoB,QAAtC;AACA,SAAO,OAAO,CAAC,KAAD,CAAP,GAAiB,KAAjB,GAAyB,CAAC,GAAG,KAAJ,EAAW,KAAX,CAAiB,IAAI,IAAI;AACvD,UAAM,IAAI,GAAG,cAAc,CAAC,IAAD,CAA3B;AACA,WAAO,CAAC,SAAD,GAAa,IAAb,GAAoB,IAAI,IAAI,OAAO,CAAC,IAAR,CAAa,IAAb,CAAnC;AACD,GAH+B,CAAhC;AAID;AC5BD;;;;;;;AAKA,SAAS,cAAT,CAAwB,IAAI,GAAG,EAA/B,EAAmC;AACjC,MAAI,OAAO,CAAC,IAAD,CAAX,EAAmB,OAAO,KAAP;AACnB,SAAO,IAAI,CAAC,UAAL,CAAgB,CAAhB,MAAuB,oBAA9B;AACD;ACND;;;;;;;AAKA,SAAS,cAAT,CAAwB,IAAI,GAAG,EAA/B,EAAmC;AACjC,MAAI,OAAO,CAAC,IAAD,CAAX,EAAmB,OAAO,KAAP;AACnB,MAAI,cAAc,CAAC,IAAD,CAAlB,EAA0B,OAAO,IAAP;AAC1B,SAAO,aAAa,CAAC,IAAD,EAAO,cAAP,EAAuB,YAAvB,CAApB;AACD;ACVD;;;;;;;AAKA,SAAS,cAAT,CAAwB,IAAI,GAAG,EAA/B,EAAmC;AACjC,SAAO,aAAa,CAAC,IAAD,EAAO,cAAP,EAAuB,YAAvB,CAApB;AACD;ACPD;;;;;;;AAKA,SAAS,UAAT,CAAoB,IAAI,GAAG,EAA3B,EAA+B;AAC7B,MAAI,OAAO,CAAC,IAAD,CAAX,EAAmB,OAAO,KAAP;AACnB,SAAO,cAAc,CAAC,IAAD,CAAd,IAAwB,cAAc,CAAC,IAAD,CAA7C;AACD;ACTD;;;;;;;;;;;;;;;;;;AAgBA,SAAS,MAAT,CAAgB,KAAK,GAAG,EAAxB,EAA4B;AAC1B,MAAI,OAAO,CAAC,KAAD,CAAX,EAAoB,OAAO,KAAP;AACpB,SAAO,CAAC,GAAG,KAAJ,EAAW,KAAX,CAAiB,UAAjB,CAAP;AACD;ACnBD;;;;;;;AAKA,SAAS,WAAT,CAAqB,IAAI,GAAG,EAA5B,EAAgC;AAC9B,SAAO,aAAa,CAAC,IAAD,EAAO,WAAP,EAAoB,SAApB,CAApB;AACD;ACPD;;;;;;;;;;;;;;;;;;AAgBA,SAAS,OAAT,CAAiB,KAAK,GAAG,EAAzB,EAA6B;AAC3B,MAAI,OAAO,CAAC,KAAD,CAAX,EAAoB,OAAO,KAAP;AACpB,SAAO,CAAC,GAAG,KAAJ,EAAW,KAAX,CAAiB,WAAjB,CAAP;AACD;AClBD;;;;;;;AAKA,SAAS,wBAAT,CAAkC,IAAI,GAAG,EAAzC,EAA6C;AAC3C,MAAI,OAAO,CAAC,IAAD,CAAX,EAAmB,OAAO,KAAP;AACnB,SAAO,qBAAqB,CAAC,IAAtB,CAA2B,CAAC,CAAC,KAAD,EAAQ,GAAR,CAAD,KAAkB,aAAa,CAAC,IAAD,EAAO,KAAP,EAAc,GAAd,CAA1D,CAAP;AACD;ACRD;;;;;;;AAKA,SAAS,yBAAT,CAAmC,IAAI,GAAG,EAA1C,EAA8C;AAC5C,MAAI,OAAO,CAAC,IAAD,CAAX,EAAmB,OAAO,KAAP;AACnB,SAAO,qBAAqB,CAAC,IAAtB,CAA2B,CAAC,CAAC,KAAD,EAAQ,GAAR,CAAD,KAAkB,aAAa,CAAC,IAAD,EAAO,KAAP,EAAc,GAAd,CAA1D,CAAP;AACD;ACRD;;;;;;;AAKA,SAAS,YAAT,CAAsB,IAAI,GAAG,EAA7B,EAAiC;AAC/B,MAAI,OAAO,CAAC,IAAD,CAAX,EAAmB,OAAO,KAAP;AACnB,SAAO,aAAa,CAAC,IAAd,CAAmB,CAAC,CAAC,KAAD,EAAQ,GAAR,CAAD,KAAkB,aAAa,CAAC,IAAD,EAAO,KAAP,EAAc,GAAd,CAAlD,CAAP;AACD;;ACHD,MAAM,aAAa,GAAG,CAAC,IAAI,CAAC,KAAK,GAAjC;;AACA,MAAM,aAAa,GAAG,CAAC,IAAI,CAAC,KAAK,GAAjC;;AACA,MAAM,WAAW,GAAG,CAAC,IAAI,QAAQ,IAAR,CAAa,CAAb,CAAzB;;AACA,MAAM,WAAW,GAAG,CAAC,IAAI,QAAQ,IAAR,CAAa,CAAb,CAAzB;;AAEO,MAAM,WAAW,GAAG;AACzB,EAAA,EAAE,EAAE,IADqB;AAEzB,EAAA,EAAE,EAAE,IAFqB;AAGzB,EAAA,MAAM,EAAE,gBAHiB;AAIzB,EAAA,MAAM,EAAE,iBAJiB;AAKzB,EAAA,OAAO,EAAE,oBALgB;AAMzB,EAAA,OAAO,EAAE,qBANgB;AAOzB,EAAA,KAAK,EAAE,OAPkB;AAQzB,EAAA,QAAQ,EAAE,UARe;AASzB,EAAA,QAAQ,EAAE,UATe;AAUzB,EAAA,KAAK,EAAE,OAVkB;AAWzB,EAAA,KAAK,EAAE;AAXkB,CAApB,C;;AAeA,SAAS,OAAT,CAAiB,KAAjB,EAAwB,OAAO,GAAG,KAAlC,EAAyC;AAC9C,QAAM;AACJ,IAAA,EADI;AACA,IAAA,EADA;AACI,IAAA,MADJ;AACY,IAAA,MADZ;AACoB,IAAA,OADpB;AAC6B,IAAA,OAD7B;AACsC,IAAA,KADtC;AAC6C,IAAA,QAD7C;AACuD,IAAA,QADvD;AACiE,IAAA,KADjE;AACwE,IAAA;AADxE,MAEF,WAFJ;;AAIA,MAAI,OAAJ,EAAa;AACX,YAAQ,IAAR;AACE,WAAK,WAAW,CAAC,KAAD,CAAhB;AACE,eAAO,KAAP;;AACF,WAAK,WAAW,CAAC,KAAD,CAAhB;AACE,eAAO,KAAP;;AACF,WAAK,aAAa,CAAC,KAAD,CAAlB;AACE,eAAO,EAAP;;AACF,WAAK,wBAAwB,CAAC,KAAD,CAA7B;AACE,eAAO,KAAP;;AACF,WAAK,aAAa,CAAC,KAAD,CAAlB;AACE,eAAO,EAAP;;AACF,WAAK,yBAAyB,CAAC,KAAD,CAA9B;AACE,eAAO,KAAP;;AACF,WAAK,cAAc,CAAC,KAAD,CAAnB;AACE,eAAO,EAAP;;AACF,WAAK,YAAY,CAAC,KAAD,CAAjB;AACE,eAAO,EAAP;;AACF;AACE,eAAO,KAAP;AAlBJ;AAoBD,GArBD,MAqBO;AACL,YAAQ,IAAR;AACE,WAAK,aAAa,CAAC,KAAD,CAAlB;AACE,eAAO,KAAP;;AACF,WAAK,aAAa,CAAC,KAAD,CAAlB;AACE,eAAO,KAAP;;AACF,WAAK,WAAW,CAAC,KAAD,CAAhB;AACE,eAAO,MAAP;;AACF,WAAK,WAAW,CAAC,KAAD,CAAhB;AACE,eAAO,MAAP;;AACF,WAAK,wBAAwB,CAAC,KAAD,CAA7B;AACE,eAAO,OAAP;;AACF,WAAK,yBAAyB,CAAC,KAAD,CAA9B;AACE,eAAO,OAAP;;AACF,WAAK,WAAW,CAAC,KAAD,CAAhB;AACE,eAAO,KAAP;;AACF,WAAK,cAAc,CAAC,KAAD,CAAnB;AACE,eAAO,QAAP;;AACF,WAAK,cAAc,CAAC,KAAD,CAAnB;AACE,eAAO,QAAP;;AACF,WAAK,cAAc,CAAC,KAAD,CAAnB;AACE,eAAO,EAAP;;AACF,WAAK,YAAY,CAAC,KAAD,CAAjB;AACE,eAAO,EAAP;;AACF;AACE,eAAO,KAAP;AAxBJ;AA0BD;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8DD,SAAS,QAAT,CAAkB,KAAlB,EAAyB;AAAE,EAAA,OAAO,GAAG,KAAZ;AAAmB,EAAA,QAAQ,GAAG;AAA9B,IAAwC,EAAjE,EAAqE;AACnE,MAAI,KAAK,IAAI,IAAT,IAAiB,OAAO,CAAC,KAAD,CAA5B,EAAqC;AACnC,WAAO,EAAP;AACD;;AACD,QAAM,KAAK,GAAG,CAAC,GAAG,KAAJ,CAAd;AACA,MAAI,OAAO,GAAG,KAAK,CAAC,KAAN,EAAd;AACA,MAAI,QAAQ,GAAG,OAAO,CAAC,OAAD,EAAU,OAAV,CAAtB;AACA,EAAA,OAAO,GAAG,QAAQ,GAAG;AAAE,IAAA,IAAI,EAAE,QAAR;AAAkB,IAAA,KAAK,EAAE;AAAzB,GAAH,GAAwC,OAA1D;AAEA,QAAM,MAAM,GAAG,KAAK,CAAC,MAAN,CAAa,CAAC,MAAD,EAAS,IAAT,KAAkB;AAC5C,UAAM,QAAQ,GAAG,OAAO,CAAC,IAAD,EAAO,OAAP,CAAxB;AACA,UAAM,QAAQ,GAAG,QAAQ,KAAK,QAA9B;AACA,IAAA,QAAQ,GAAG,QAAX;AACA,QAAI,QAAQ,GAAG,IAAf;;AAEA,QAAI,QAAJ,EAAc;AACZ,MAAA,QAAQ,GAAG,CAAC,QAAQ,GAAG,MAAM,CAAC,GAAP,GAAa,KAAhB,GAAwB,MAAM,CAAC,GAAP,EAAjC,IAAiD,QAA5D;AACD;;AAED,WAAO,QAAQ,GAAG,MAAM,CAAC,MAAP,CAAc;AAAE,MAAA,IAAI,EAAE,QAAR;AAAkB,MAAA,KAAK,EAAE;AAAzB,KAAd,CAAH,GAAwD,MAAM,CAAC,MAAP,CAAc,QAAd,CAAvE;AACD,GAXc,EAWZ,CAAC,OAAD,CAXY,CAAf;AAYA,SAAO,MAAP;AACD;;AClKD,MAAM,2BAA2B,GAAG,CAAC,KAAD,EAAQ,OAAR,KAAoB,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAD,CAAN,CAA1E;;AACA,MAAM,0BAA0B,GAAG,CAAC,KAAD,EAAQ,OAAR,KAAoB,CAAC,OAAD,IAAY,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,MAAN,GAAe,CAAhB,CAAN,CAA1E;;AACA,MAAM,gBAAgB,GAAG,CAAC,KAAD,EAAQ,UAAR,KAAuB,UAAU,IAAI,CAAC,CAAC,GAAG,UAAJ,EAAgB,IAAhB,CAAqB,OAArB,CAAf,IAAgD,CAAC,UAAD,IAAe,MAAM,CAAC,KAAD,CAArH;;;;;;;;;;;;;;;;;;;;AAmBA,SAAS,cAAT,CAAwB,KAAK,GAAG,EAAhC,EAAoC;AAAE,EAAA,OAAO,GAAG,KAAZ;AAAmB,EAAA,UAAU,GAAG;AAAhC,IAAuC,EAA3E,EAA+E;AAC7E,MAAI,CAAC,UAAU,CAAC,KAAD,CAAX,IAAsB,2BAA2B,CAAC,KAAD,EAAQ,OAAR,CAAjD,IAAqE,0BAA0B,CAAC,KAAD,EAAQ,OAAR,CAA/F,IAAmH,gBAAgB,CAAC,KAAD,EAAQ,UAAR,CAAvI,EAA4J;AAC1J,WAAO,KAAP;AACD;;AAED,QAAM,KAAK,GAAG,UAAU,IAAI,KAA5B;AACA,QAAM,cAAc,GAAG,IAAI,MAAJ,CAAW,OAAO,GAAI,IAAG,QAAQ,CAAC,KAAD,CAAR,CAAgB,KAAhB,EAAwB,EAA/B,GAAoC,GAAE,QAAQ,CAAC,KAAD,CAAR,CAAgB,GAAhB,EAAsB,GAA9E,CAAvB;AACA,SAAO,KAAK,CAAC,OAAN,CAAc,cAAd,EAA8B,EAA9B,CAAP;AACD;AC/BD;;;;;;;;;;;;;;AAYA,SAAS,UAAT,CAAoB,KAAK,GAAG,EAA5B,EAAgC;AAC9B,MAAI,OAAO,CAAC,KAAD,CAAX,EAAoB,OAAO,KAAP;AACpB,SAAO,CAAC,GAAG,KAAJ,EAAW,KAAX,CAAiB,cAAjB,CAAP;AACD;ACfD;;;;;;;;;;;;;;;;AAcA,SAAS,UAAT,CAAoB,KAAK,GAAG,EAA5B,EAAgC;AAC9B,MAAI,OAAO,CAAC,KAAD,CAAX,EAAoB,OAAO,KAAP;AACpB,SAAO,CAAC,GAAG,KAAJ,EAAW,KAAX,CAAiB,cAAjB,CAAP;AACD;;ACpBD,IAAA,SAAc,GAAG,GAAjB;;;;;;;;;;;;;;AAeA,SAAS,GAAT,GAAe;AACb,MAAI,MAAM,GAAG,EAAb;AACA,MAAI,IAAI,GAAG,KAAK,CAAC,SAAN,CAAgB,KAAhB,CAAsB,IAAtB,CAA2B,SAA3B,CAAX;AACA,MAAI,OAAO,GAAG,IAAI,CAAC,MAAnB;AACA,MAAI,MAAM,GAAG,CAAb;AACA,MAAI,CAAJ,EAAO,CAAP;;AAEA,MAAI,CAAC,OAAL,EAAc;AACZ,UAAM,IAAI,KAAJ,CAAU,oCAAV,CAAN;AACD;;AAED,OAAK,CAAC,GAAG,CAAT,EAAY,CAAC,GAAG,OAAhB,EAAyB,CAAC,EAA1B,EAA8B;AAC5B,QAAI,CAAC,KAAK,CAAC,OAAN,CAAc,IAAI,CAAC,CAAD,CAAlB,CAAL,EAA6B;AAC3B,YAAM,IAAI,KAAJ,CAAU,8BAAV,CAAN;AACD;;AACD,QAAI,MAAM,GAAG,IAAI,CAAC,CAAD,CAAJ,CAAQ,MAArB;;AACA,QAAI,MAAM,GAAG,MAAb,EAAqB;AACnB,MAAA,MAAM,GAAG,MAAT;AACD;AACF;;AAED,OAAK,CAAC,GAAG,CAAT,EAAY,CAAC,GAAG,MAAhB,EAAwB,CAAC,EAAzB,EAA6B;AAC3B,QAAI,KAAK,GAAG,EAAZ;;AACA,SAAK,CAAC,GAAG,CAAT,EAAY,CAAC,GAAG,OAAhB,EAAyB,CAAC,EAA1B,EAA8B;AAC5B,UAAI,CAAC,KAAK,CAAC,OAAN,CAAc,IAAI,CAAC,CAAD,CAAlB,CAAL,EAA6B;AAC3B,cAAM,IAAI,KAAJ,CAAU,8BAAV,CAAN;AACD;;AACD,MAAA,KAAK,CAAC,CAAD,CAAL,GAAW,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,CAAX;AACD;;AACD,IAAA,MAAM,CAAC,CAAD,CAAN,GAAY,KAAZ;AACD;;AAED,SAAO,MAAP;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxCD;;;;;;;;;;;;;;;;;;;;AAkBO,SAAA,WAAA,GAAyD;MAApCA,IAAoC,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAA7B,E;MAAIC,OAAyB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAf,E;MAAIC,IAAW,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,E;MACpDC,QAAAA,GAAWC,SAAAA,CAAjB,IAAiBA,C,CAD6C,C;;MAGxDC,gBAAAA,GAAmBF,QAAAA,CAAAA,MAAAA,KAAAA,CAAAA,IAAyB,GAAA,MAAA,CAAA,iBAAA,CAAA,IAAA,CAAA,EAAA,KAAA,CAAlD,OAAkD,C;MAC5CG,UAAAA,GAAa,GAAA,MAAA,CAAA,iBAAA,CAAA,IAAA,CAAA,EAAA,KAAA,CAAnB,MAAmB,C;MACbC,iBAAAA,GAAoB,GAAA,MAAA,CAAA,iBAAA,CAAA,OAAA,CAAA,EAAA,IAAA,CAAA,UAAA,KAAiC,GAAA,MAAA,CAAA,iBAAA,CAAA,OAAA,CAAA,EAAA,IAAA,CAA3D,UAA2D,C;;MAEvDP,IAAAA,KAAAA,OAAAA,IAAJ,U,EAAoC;WAC3B,CAAC,CAAA,EAAA,EAAR,IAAQ,CAAD,C;;;MAGL,CAAA,IAAA,IAAA,gBAAA,IAAJ,iB,EAAoD;WAC3CQ,SAAAA,CAAAA,IAAAA,EAAP,OAAOA,C;;;SAGFC,aAAAA,CAAAA,IAAAA,EAAP,QAAOA,C;;;;;;;;;;AASF,SAAA,SAAA,GAA4C;MAAzBT,IAAyB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAlB,E;MAAIC,OAAc,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,E,CAAI,C;;MAE7C,GAAA,MAAA,CAAA,iBAAA,CAAA,IAAA,CAAA,EAAA,KAAA,CAAgB,UAAA,CAAA,EAAA;WAAO,CAACS,MAAAA,CAAR,CAAQA,C;AAA5B,GAAI,C,EAAoC;WAC/B,CAAC,CAAA,OAAA,EAAR,IAAQ,CAAD,C;;;aAGmB,CAC1BT,OAAAA,CAAAA,KAAAA,CAAAA,CAAAA,EAAiBD,IAAAA,CAAAA,MAAAA,GAAca,cAAAA,CAAAA,IAAAA,EAAqB;AAAEC,IAAAA,OAAAA,EAAvBD;AAAqB,GAArBA,CAAAA,CADL,MAC1BZ,CAD0B,EAE1BA,OAAAA,CAAAA,KAAAA,CAAcY,cAAAA,CAAAA,OAAAA,EAAwB;AAAEE,IAAAA,UAAAA,EAA1BF;AAAwB,GAAxBA,CAAAA,CARiC,MAQ/CZ,CAF0B,C;MAArBU,MAN0C,GAAA,IAAA,CAAA,CAAA,C;MAMlCC,SANkC,GAAA,IAAA,CAAA,CAAA,C;MAW3CI,eAAAA,GAAkBC,QAAAA,CAASC,oBAAAA,CAAAA,IAAAA,EAAAA,MAAAA,EAAjC,SAAiCA,CAATD,C;MACpBE,iBAAAA,GAAoBD,oBAAAA,CAAAA,OAAAA,EAAAA,MAAAA,EAAxB,SAAwBA,C;MAElBE,qBAAAA,GAAwB,MAAA,CAC5B,eAAA,CAAA,GAAA,CAAoB,UAAA,IAAA,EAAA;WAAWC,OAAAA,CAAAA,IAAAA,CAAAA,GAAAA,MAAAA,GAAAA,MAAAA,IAAAA,GAAX,G;AAApB,GAAA,EAAA,IAAA,CADF,EACE,CAD4B,C;;cAIHF,iBAAAA,CAAAA,KAAAA,CAAAA,qBAAAA,KAlBsB,E;;;;mBAAA,GAAA,KAAA,CAAA,KAAA,CAAA,CAAA,C;MAoB3CG,GAAAA,GAAMC,SAAAA,CAAAA,iBAAAA,EAAAA,eAAAA,CAAAA,CAAAA,GAAAA,CAAZ,qBAAYA,C;;MAEZ,M,EAAY;QACV,O,CAAY,CAAA,EAAA,EAAZ,MAAY,C;;;MAGd,S,EAAe;QACb,I,CAAS,CAAA,EAAA,EAAT,SAAS,C;;;SAGX,G;;;AAGF,SAAA,oBAAA,GAAqE;MAAvCC,GAAuC,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAjC,E;MAAIV,OAA6B,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAnB,E;MAAIW,QAAe,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,E;SACxDD,GAAAA,CAAAA,OAAAA,CAAYE,MAAAA,CAAAA,MAAZF,OAAYE,CAAZF,EAAAA,EAAAA,EAAAA,OAAAA,CAA+CE,MAAAA,CAAUD,QAAVC,GAA/CF,GAA+CE,CAA/CF,EAAP,EAAOA,C;;;AAGT,SAAA,qBAAA,CAAA,KAAA,EAAqD;;MAArBvB,OAAqB,GAAA,KAAA,CAAA,CAAA,C;;MAAZD,IAAY,GAAA,MAAA,KAAA,SAAA,GAAL,EAAK,GAAA,M;;SAC5C,CAAA,OAAA,IAAYC,OAAAA,KAAZ,IAAA,GAA+B,CAAA,EAAA,EAA/B,IAA+B,CAA/B,GAA4C,CAAA,OAAA,EAAnD,IAAmD,C;;;AAG9C,SAAA,SAAA,CAAA,IAAA,EAAyB;SACvB,OAAA,IAAA,KAAA,QAAA,GAA2B0B,eAAAA,CAA3B,IAA2BA,CAA3B,GAAmDC,eAAAA,CAA1D,IAA0DA,C;;;;;;;;;AAQ5D,SAAA,eAAA,GAAyC;MAAhBC,SAAgB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,E;SAC5B,MAAA,CAAA,OAAA,CAAA,SAAA,EAAA,GAAA,CAA8B,UAAA,KAAA,EAAA;;QAAEC,KAAF,GAAA,KAAA,CAAA,CAAA,C;QAASC,OAAT,GAAA,KAAA,CAAA,CAAA,C;;WAAsB,CACzD,CAACC,MAAAA,CAAD,KAACA,CAAD,EAAgBA,MAAAA,CAAAA,KAAAA,CAAAA,GADyC,CACzD,CADyD,EAAtB,OAAsB,C;AAA3D,GAAO,C;;;;;;;;;AAWT,SAAA,eAAA,GAAyC;MAAhBH,SAAgB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,E;SAC5B,SAAA,CAAA,KAAA,CAAA,GAAA,EAAA,GAAA,CAAyB,UAAA,KAAA,EAAW;uBACdK,KAAAA,CAAAA,KAAAA,CADc,GACdA,C;;QAApBD,OADkC,GAAA,aAAA,CAAA,CAAA,C;QACzBF,OADyB,GAAA,aAAA,CAAA,CAAA,C;;6BAEpBE,OAAAA,CAAAA,KAAAA,CAAAA,GAAAA,EAAAA,GAAAA,CAFoB,MAEpBA,C;;QAAdH,KAFkC,GAAA,mBAAA,CAAA,CAAA,C;QAE3BK,GAF2B,GAAA,mBAAA,CAAA,CAAA,C,CAAA,C;;;;;WAMlC,CAAC,CAAA,KAAA,EAAQA,GAAAA,GAAMA,GAAAA,GAANA,CAAAA,GAAgBL,KAAAA,GAAzB,CAAC,CAAD,EAAP,OAAO,C;AANT,GAAO,C;;;;;;;;;;AAgBF,SAAA,aAAA,GAAiD;MAA1B9B,IAA0B,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAnB,E;MAAIG,QAAe,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,E;MAC9CiC,WAAAA,GAAJ,C;SAEO,QAAA,CAAA,MAAA,CAAgB,UAAA,KAAA,EAAA,KAAA,EAAA,KAAA,EAAA,MAAA,EAAoD;;;QAA1CN,KAA0C,GAAA,MAAA,CAAA,CAAA,C;QAAnCK,GAAmC,GAAA,MAAA,CAAA,CAAA,C;QAA7BE,QAA6B,GAAA,KAAA,CAAA,CAAA,C,CAAA,C;;;QAErEP,KAAAA,KAAJ,W,EAA2B;YACzB,I,CAAW,CAAA,EAAA,EAAK9B,IAAAA,CAAAA,KAAAA,CAAAA,WAAAA,EAAhB,KAAgBA,CAAL,C;KAH4D,C;;;UAOzE,I,CAAW,CAAA,QAAA,EAAWA,IAAAA,CAAAA,KAAAA,CAAAA,KAAAA,EAAtB,GAAsBA,CAAX,C,EAP8D,C;;QAUrEmC,GAAAA,GAAMnC,IAAAA,CAANmC,MAAAA,IAAqB,CAACG,MAAAA,CAAOC,KAAAA,GAAjC,CAA0BD,C,EAAmB;YAC3C,I,CAAW,CAAA,EAAA,EAAKtC,IAAAA,CAAAA,KAAAA,CAAhB,GAAgBA,CAAL,C;;;kBAGb,G;WACA,K;AAfK,GAAA,EAAP,EAAO,C;;;;;;;;AC9HT,IAAMwC,OAAAA,GAAUC,MAAAA,CAAVD,IAAUC,CAAhB,eAAgBA,CAAhB;AAQA,IAAMC,IAAAA,GAAOD,MAAAA,CAAPC,IAAOD,CAAb,gBAAaA,CAAb;AAUA,IAAME,IAAAA,GAAOF,MAAAA,CAAPE,IAAOF,CAAb,gBAAaA,CAAb;AAWA,IAAMG,IAAAA,GAAOH,MAAAA,CAAPG,IAAOH,CAAb,gBAAaA,CAAb;;AAIA,SAAA,SAAA,CAAA,IAAA,EAAwE;MAAnDzC,IAAmD,GAAA,IAAA,CAAnDA,I;MAAMC,OAA6C,GAAA,IAAA,CAA7CA,O;MAASC,IAAoC,GAAA,IAAA,CAApCA,I;MAAM2C,QAA8B,GAAA,IAAA,CAA9BA,Q;MAAUC,MAAoB,GAAA,IAAA,CAApBA,M;MAAWC,KAAS,GAAA,uBAAA,CAAA,IAAA,EAAA,CAAA,MAAA,EAAA,SAAA,EAAA,MAAA,EAAA,UAAA,EAAA,QAAA,CAAA,C;MAChEC,KAAAA,GAAQC,WAAAA,CAAAA,IAAAA,EAAAA,OAAAA,EAAd,IAAcA,C;SAEPH,MAAAA,GACLA,MAAAA,CAAO;AAAEE,IAAAA,KAAAA,EADJF;AACE,GAAPA,CADKA,GAGL,KAAA,CAAA,aAAA,CAAA,OAAA,E;AAAS,IAAA,IAAA,EAAT;KAAA,K,CAAA,E,MACG,G,CAAU,UAAA,KAAA,EAAA,KAAA,EAAA;;QAAET,QAAF,GAAA,KAAA,CAAA,CAAA,C;QAAYa,IAAZ,GAAA,KAAA,CAAA,CAAA,C;;;;0BAGT,I;AAAM,QAAA,GAAA,EAAN;qBACe,KAAA,CAAA,aAAA,CAAA,IAAA,E,IAAA,E,QAAA,C,sBACb,I;;AALH,G,CADH,C;;;AAqBJC,SAAAA,CAAAA,YAAAA,GAAyB;WAAA,EAAA;QAAA,EAAA;YAGb;AAHa,CAAzBA;AAMAA,SAAAA,CAAAA,OAAAA,GAAAA,OAAAA;AACAA,SAAAA,CAAAA,IAAAA,GAAAA,IAAAA;AACAA,SAAAA,CAAAA,IAAAA,GAAAA,IAAAA;AACAA,SAAAA,CAAAA,IAAAA,GAAAA,IAAAA","sourcesContent":["/**\n * Returns detailed type as string (instead of just 'object' for arrays etc)\n * @private\n * @param {any} value js value\n * @returns {String} type of value\n * @example\n * typeOf({}); // 'object'\n * typeOf([]); // 'array'\n * typeOf(function() {}); // 'function'\n * typeOf(/a/); // 'regexp'\n * typeOf(new Date()); // 'date'\n * typeOf(null); // 'null'\n * typeOf(undefined); // 'undefined'\n * typeOf('a'); // 'string'\n * typeOf(1); // 'number'\n * typeOf(true); // 'boolean'\n * typeOf(new Map()); // 'map'\n * typeOf(new Set()); // 'map'\n */\nfunction typeOf(value) {\n  if (value === null) {\n    return 'null';\n  }\n  if (value !== Object(value)) {\n    return typeof value;\n  }\n  return {}.toString.call(value).slice(8, -1).toLowerCase();\n}\n\nexport default typeOf;","import typeOf from './typeOf';\n/**\n * Checks if input string is empty\n * @param  {String} input text input\n * @return {Boolean} true if no input\n */\nfunction isEmpty(input) {\n  if (typeOf(input) !== 'string') {\n    return true;\n  }\n  return !input.length;\n}\n\nexport default isEmpty;","import isEmpty from './isEmpty';\n\n/**\n * Takes a character and a unicode range. Returns true if the char is in the range.\n * @param  {String}  char  unicode character\n * @param  {Number}  start unicode start range\n * @param  {Number}  end   unicode end range\n * @return {Boolean}\n */\nfunction isCharInRange(char = '', start, end) {\n  if (isEmpty(char)) return false;\n  const code = char.charCodeAt(0);\n  return start <= code && code <= end;\n}\n\nexport default isCharInRange;","export const VERSION = '4.0.1';\n\nexport const TO_KANA_METHODS = {\n  HIRAGANA: 'toHiragana',\n  KATAKANA: 'toKatakana'\n};\n\nexport const ROMANIZATIONS = {\n  HEPBURN: 'hepburn'\n};\n\n/**\n * Default config for WanaKana, user passed options will be merged with these\n * @type {DefaultOptions}\n * @name defaultOptions\n * @property {Boolean} [useObsoleteKana=false] - Set to true to use obsolete characters, such as ゐ and ゑ.\n * @example\n * toHiragana('we', { useObsoleteKana: true })\n * // => 'ゑ'\n * @property {Boolean} [passRomaji=false] - Set to true to pass romaji when using mixed syllabaries with toKatakana() or toHiragana()\n * @example\n * toHiragana('only convert the katakana: ヒラガナ', { passRomaji: true })\n * // => \"only convert the katakana: ひらがな\"\n * @property {Boolean} [upcaseKatakana=false] - Set to true to convert katakana to uppercase using toRomaji()\n * @example\n * toRomaji('ひらがな カタカナ', { upcaseKatakana: true })\n * // => \"hiragana KATAKANA\"\n * @property {Boolean|String} [IMEMode=false] - Set to true, 'toHiragana', or 'toKatakana' to handle conversion while it is being typed.\n * @property {String} [romanization='hepburn'] - choose toRomaji() romanization map (currently only 'hepburn')\n * @property {Object} [customKanaMapping] - custom map will be merged with default conversion\n * @example\n * toKana('wanakana', { customKanaMapping: { na: 'に', ka: 'Bana' }) };\n * // => 'わにBanaに'\n * @property {Object} [customRomajiMapping] - custom map will be merged with default conversion\n * @example\n * toRomaji('つじぎり', { customRomajiMapping: { じ: 'zi', つ: 'tu', り: 'li' }) };\n * // => 'tuzigili'\n */\nexport const DEFAULT_OPTIONS = {\n  useObsoleteKana: false,\n  passRomaji: false,\n  upcaseKatakana: false,\n  ignoreCase: false,\n  IMEMode: false,\n  romanization: ROMANIZATIONS.HEPBURN\n};\n\n// CharCode References\n// http://www.rikai.com/library/kanjitables/kanji_codes.unicode.shtml\n// http://unicode-table.com\n\nexport const LATIN_LOWERCASE_START = 0x61;\nexport const LATIN_LOWERCASE_END = 0x7a;\nexport const LATIN_UPPERCASE_START = 0x41;\nexport const LATIN_UPPERCASE_END = 0x5a;\nexport const LOWERCASE_ZENKAKU_START = 0xff41;\nexport const LOWERCASE_ZENKAKU_END = 0xff5a;\nexport const UPPERCASE_ZENKAKU_START = 0xff21;\nexport const UPPERCASE_ZENKAKU_END = 0xff3a;\nexport const HIRAGANA_START = 0x3041;\nexport const HIRAGANA_END = 0x3096;\nexport const KATAKANA_START = 0x30a1;\nexport const KATAKANA_END = 0x30fc;\nexport const KANJI_START = 0x4e00;\nexport const KANJI_END = 0x9faf;\nexport const PROLONGED_SOUND_MARK = 0x30fc;\nexport const KANA_SLASH_DOT = 0x30fb;\n\nconst ZENKAKU_NUMBERS = [0xff10, 0xff19];\nconst ZENKAKU_UPPERCASE = [UPPERCASE_ZENKAKU_START, UPPERCASE_ZENKAKU_END];\nconst ZENKAKU_LOWERCASE = [LOWERCASE_ZENKAKU_START, LOWERCASE_ZENKAKU_END];\nconst ZENKAKU_PUNCTUATION_1 = [0xff01, 0xff0f];\nconst ZENKAKU_PUNCTUATION_2 = [0xff1a, 0xff1f];\nconst ZENKAKU_PUNCTUATION_3 = [0xff3b, 0xff3f];\nconst ZENKAKU_PUNCTUATION_4 = [0xff5b, 0xff60];\nconst ZENKAKU_SYMBOLS_CURRENCY = [0xffe0, 0xffee];\n\nconst HIRAGANA_CHARS = [0x3040, 0x309f];\nconst KATAKANA_CHARS = [0x30a0, 0x30ff];\nconst HANKAKU_KATAKANA = [0xff66, 0xff9f];\nconst KATAKANA_PUNCTUATION = [0x30fb, 0x30fc];\nconst KANA_PUNCTUATION = [0xff61, 0xff65];\nconst CJK_SYMBOLS_PUNCTUATION = [0x3000, 0x303f];\nconst COMMON_CJK = [0x4e00, 0x9fff];\nconst RARE_CJK = [0x3400, 0x4dbf];\n\nexport const KANA_RANGES = [HIRAGANA_CHARS, KATAKANA_CHARS, KANA_PUNCTUATION, HANKAKU_KATAKANA];\n\nexport const JA_PUNCTUATION_RANGES = [CJK_SYMBOLS_PUNCTUATION, KANA_PUNCTUATION, KATAKANA_PUNCTUATION, ZENKAKU_PUNCTUATION_1, ZENKAKU_PUNCTUATION_2, ZENKAKU_PUNCTUATION_3, ZENKAKU_PUNCTUATION_4, ZENKAKU_SYMBOLS_CURRENCY];\n\n// All Japanese unicode start and end ranges\n// Includes kanji, kana, zenkaku latin chars, punctuation, and number ranges.\nexport const JAPANESE_RANGES = [...KANA_RANGES, ...JA_PUNCTUATION_RANGES, ZENKAKU_UPPERCASE, ZENKAKU_LOWERCASE, ZENKAKU_NUMBERS, COMMON_CJK, RARE_CJK];\n\nconst MODERN_ENGLISH = [0x0000, 0x007f];\nconst HEPBURN_MACRON_RANGES = [[0x0100, 0x0101], // Ā ā\n[0x0112, 0x0113], // Ē ē\n[0x012a, 0x012b], // Ī ī\n[0x014c, 0x014d], // Ō ō\n[0x016a, 0x016b]];\nconst SMART_QUOTE_RANGES = [[0x2018, 0x2019], // ‘ ’\n[0x201c, 0x201d]];\n\nexport const ROMAJI_RANGES = [MODERN_ENGLISH, ...HEPBURN_MACRON_RANGES];\n\nexport const EN_PUNCTUATION_RANGES = [[0x20, 0x2f], [0x3a, 0x3f], [0x5b, 0x60], [0x7b, 0x7e], ...SMART_QUOTE_RANGES];","import isCharInRange from './isCharInRange';\nimport { JAPANESE_RANGES } from '../constants';\n\n/**\n * Tests a character. Returns true if the character is [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharJapanese(char = '') {\n  return JAPANESE_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n\nexport default isCharJapanese;","import typeOf from './utils/typeOf';\nimport isEmpty from './utils/isEmpty';\nimport isCharJapanese from './utils/isCharJapanese';\n\n/**\n * Test if `input` only includes [Kanji](https://en.wikipedia.org/wiki/Kanji), [Kana](https://en.wikipedia.org/wiki/Kana), zenkaku numbers, and JA punctuation/symbols.”\n * @param  {String} [input=''] text\n * @param  {Regexp} [allowed] additional test allowed to pass for each char\n * @return {Boolean} true if passes checks\n * @example\n * isJapanese('泣き虫')\n * // => true\n * isJapanese('あア')\n * // => true\n * isJapanese('２月') // Zenkaku numbers allowed\n * // => true\n * isJapanese('泣き虫。！〜＄') // Zenkaku/JA punctuation\n * // => true\n * isJapanese('泣き虫.!~$') // Latin punctuation fails\n * // => false\n * isJapanese('A泣き虫')\n * // => false\n * isJapanese('≪偽括弧≫', /[≪≫]/);\n * // => true\n */\nfunction isJapanese(input = '', allowed) {\n  const augmented = typeOf(allowed) === 'regexp';\n  return isEmpty(input) ? false : [...input].every(char => {\n    const isJa = isCharJapanese(char);\n    return !augmented ? isJa : isJa || allowed.test(char);\n  });\n}\n\nexport default isJapanese;","import isEmpty from './isEmpty';\nimport { PROLONGED_SOUND_MARK } from '../constants';\n\n/**\n * Returns true if char is 'ー'\n * @param  {String} char to test\n * @return {Boolean}\n */\nfunction isCharLongDash(char = '') {\n  if (isEmpty(char)) return false;\n  return char.charCodeAt(0) === PROLONGED_SOUND_MARK;\n}\n\nexport default isCharLongDash;","import isEmpty from './isEmpty';\nimport isCharLongDash from './isCharLongDash';\nimport isCharInRange from './isCharInRange';\nimport { HIRAGANA_START, HIRAGANA_END } from '../constants';\n\n/**\n * Tests a character. Returns true if the character is [Hiragana](https://en.wikipedia.org/wiki/Hiragana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharHiragana(char = '') {\n  if (isEmpty(char)) return false;\n  if (isCharLongDash(char)) return true;\n  return isCharInRange(char, HIRAGANA_START, HIRAGANA_END);\n}\n\nexport default isCharHiragana;","import { KATAKANA_START, KATAKANA_END } from '../constants';\n\nimport isCharInRange from './isCharInRange';\n\n/**\n * Tests a character. Returns true if the character is [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharKatakana(char = '') {\n  return isCharInRange(char, KATAKANA_START, KATAKANA_END);\n}\n\nexport default isCharKatakana;","import isEmpty from './isEmpty';\nimport isCharHiragana from './isCharHiragana';\nimport isCharKatakana from './isCharKatakana';\n\n/**\n * Tests a character. Returns true if the character is [Hiragana](https://en.wikipedia.org/wiki/Hiragana) or [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharKana(char = '') {\n  if (isEmpty(char)) return false;\n  return isCharHiragana(char) || isCharKatakana(char);\n}\n\nexport default isCharKana;","import isEmpty from './utils/isEmpty';\nimport isCharKana from './utils/isCharKana';\n\n/**\n * Test if `input` is [Kana](https://en.wikipedia.org/wiki/Kana) ([Katakana](https://en.wikipedia.org/wiki/Katakana) and/or [Hiragana](https://en.wikipedia.org/wiki/Hiragana))\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Kana](https://en.wikipedia.org/wiki/Kana)\n * @example\n * isKana('あ')\n * // => true\n * isKana('ア')\n * // => true\n * isKana('あーア')\n * // => true\n * isKana('A')\n * // => false\n * isKana('あAア')\n * // => false\n */\nfunction isKana(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharKana);\n}\n\nexport default isKana;","import { KANJI_START, KANJI_END } from '../constants';\n\nimport isCharInRange from './isCharInRange';\n/**\n * Tests a character. Returns true if the character is a CJK ideograph (kanji).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharKanji(char = '') {\n  return isCharInRange(char, KANJI_START, KANJI_END);\n}\n\nexport default isCharKanji;","import isEmpty from './utils/isEmpty';\nimport isCharKanji from './utils/isCharKanji';\n\n/**\n * Tests if `input` is [Kanji](https://en.wikipedia.org/wiki/Kanji) ([Japanese CJK ideographs](https://en.wikipedia.org/wiki/CJK_Unified_Ideographs))\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Kanji](https://en.wikipedia.org/wiki/Kanji)\n * @example\n * isKanji('刀')\n * // => true\n * isKanji('切腹')\n * // => true\n * isKanji('勢い')\n * // => false\n * isKanji('あAア')\n * // => false\n * isKanji('🐸')\n * // => false\n */\nfunction isKanji(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharKanji);\n}\n\nexport default isKanji;","import isEmpty from './isEmpty';\nimport { EN_PUNCTUATION_RANGES } from '../constants';\nimport isCharInRange from './isCharInRange';\n\n/**\n * Tests a character. Returns true if the character is considered English punctuation.\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharEnglishPunctuation(char = '') {\n  if (isEmpty(char)) return false;\n  return EN_PUNCTUATION_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n\nexport default isCharEnglishPunctuation;","import isEmpty from './isEmpty';\nimport { JA_PUNCTUATION_RANGES } from '../constants';\nimport isCharInRange from './isCharInRange';\n\n/**\n * Tests a character. Returns true if the character is considered English punctuation.\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharJapanesePunctuation(char = '') {\n  if (isEmpty(char)) return false;\n  return JA_PUNCTUATION_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n\nexport default isCharJapanesePunctuation;","import isEmpty from './isEmpty';\nimport isCharInRange from './isCharInRange';\nimport { ROMAJI_RANGES } from '../constants';\n\n/**\n * Tests a character. Returns true if the character is [Romaji](https://en.wikipedia.org/wiki/Romaji) (allowing [Hepburn romanisation](https://en.wikipedia.org/wiki/Hepburn_romanization))\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharRomaji(char = '') {\n  if (isEmpty(char)) return false;\n  return ROMAJI_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n\nexport default isCharRomaji;","import isEmpty from './utils/isEmpty';\nimport isCharEnglishPunctuation from './utils/isCharEnglishPunctuation';\nimport isCharJapanesePunctuation from './utils/isCharJapanesePunctuation';\nimport isCharRomaji from './utils/isCharRomaji';\nimport isCharKanji from './utils/isCharKanji';\nimport isCharHiragana from './utils/isCharHiragana';\nimport isCharKatakana from './utils/isCharKatakana';\nimport isCharJapanese from './utils/isCharJapanese';\n\nconst isCharEnSpace = x => x === ' ';\nconst isCharJaSpace = x => x === '　';\nconst isCharJaNum = x => /[０-９]/.test(x);\nconst isCharEnNum = x => /[0-9]/.test(x);\n\nexport const TOKEN_TYPES = {\n  EN: 'en',\n  JA: 'ja',\n  EN_NUM: 'englishNumeral',\n  JA_NUM: 'japaneseNumeral',\n  EN_PUNC: 'englishPunctuation',\n  JA_PUNC: 'japanesePunctuation',\n  KANJI: 'kanji',\n  HIRAGANA: 'hiragana',\n  KATAKANA: 'katakana',\n  SPACE: 'space',\n  OTHER: 'other'\n};\n\n// prettier-ignore\nexport function getType(input, compact = false) {\n  const {\n    EN, JA, EN_NUM, JA_NUM, EN_PUNC, JA_PUNC, KANJI, HIRAGANA, KATAKANA, SPACE, OTHER\n  } = TOKEN_TYPES;\n\n  if (compact) {\n    switch (true) {\n      case isCharJaNum(input):\n        return OTHER;\n      case isCharEnNum(input):\n        return OTHER;\n      case isCharEnSpace(input):\n        return EN;\n      case isCharEnglishPunctuation(input):\n        return OTHER;\n      case isCharJaSpace(input):\n        return JA;\n      case isCharJapanesePunctuation(input):\n        return OTHER;\n      case isCharJapanese(input):\n        return JA;\n      case isCharRomaji(input):\n        return EN;\n      default:\n        return OTHER;\n    }\n  } else {\n    switch (true) {\n      case isCharJaSpace(input):\n        return SPACE;\n      case isCharEnSpace(input):\n        return SPACE;\n      case isCharJaNum(input):\n        return JA_NUM;\n      case isCharEnNum(input):\n        return EN_NUM;\n      case isCharEnglishPunctuation(input):\n        return EN_PUNC;\n      case isCharJapanesePunctuation(input):\n        return JA_PUNC;\n      case isCharKanji(input):\n        return KANJI;\n      case isCharHiragana(input):\n        return HIRAGANA;\n      case isCharKatakana(input):\n        return KATAKANA;\n      case isCharJapanese(input):\n        return JA;\n      case isCharRomaji(input):\n        return EN;\n      default:\n        return OTHER;\n    }\n  }\n}\n\n/**\n * Splits input into array of strings separated by opinionated token types\n * `'en', 'ja', 'englishNumeral', 'japaneseNumeral','englishPunctuation', 'japanesePunctuation','kanji', 'hiragana', 'katakana', 'space', 'other'`.\n * If `{ compact: true }` then many same-language tokens are combined (spaces + text, kanji + kana, numeral + punctuation).\n * If `{ detailed: true }` then return array will contain `{ type, value }` instead of `'value'`\n * @param  {String} input text\n * @param  {Object} [options={ compact: false, detailed: false}] options to modify output style\n * @return {String|Object[]} text split into tokens containing values, or detailed object\n * @example\n * tokenize('ふふフフ')\n * // ['ふふ', 'フフ']\n *\n * tokenize('感じ')\n * // ['感', 'じ']\n *\n * tokenize('truly 私は悲しい')\n * // ['truly', ' ', '私', 'は', '悲', 'しい']\n *\n * tokenize('truly 私は悲しい', { compact: true })\n * // ['truly ', '私は悲しい']\n *\n * tokenize('5romaji here...!?漢字ひらがな４カタ　カナ「ＳＨＩＯ」。！')\n * // [ '5', 'romaji', ' ', 'here', '...!?', '漢字', 'ひらがな', 'カタ', '　', 'カナ', '４', '「', 'ＳＨＩＯ', '」。！']\n *\n * tokenize('5romaji here...!?漢字ひらがな４カタ　カナ「ＳＨＩＯ」。！', { compact: true })\n * // [ '5', 'romaji here', '...!?', '漢字ひらがなカタ　カナ', '４「', 'ＳＨＩＯ', '」。！']\n *\n * tokenize('5romaji here...!?漢字ひらがなカタ　カナ４「ＳＨＩＯ」。！ لنذهب', { detailed: true })\n * // [\n *  { type: 'englishNumeral', value: '5' },\n *  { type: 'en', value: 'romaji' },\n *  { type: 'space', value: ' ' },\n *  { type: 'en', value: 'here' },\n *  { type: 'englishPunctuation', value: '...!?' },\n *  { type: 'kanji', value: '漢字' },\n *  { type: 'hiragana', value: 'ひらがな' },\n *  { type: 'katakana', value: 'カタ' },\n *  { type: 'space', value: '　' },\n *  { type: 'katakana', value: 'カナ' },\n *  { type: 'japaneseNumeral', value: '４' },\n *  { type: 'japanesePunctuation', value: '「' },\n *  { type: 'ja', value: 'ＳＨＩＯ' },\n *  { type: 'japanesePunctuation', value: '」。！' },\n *  { type: 'space', value: ' ' },\n *  { type: 'other', value: 'لنذهب' },\n * ]\n *\n * tokenize('5romaji here...!?漢字ひらがなカタ　カナ４「ＳＨＩＯ」。！ لنذهب', { compact: true, detailed: true})\n * // [\n *  { type: 'other', value: '5' },\n *  { type: 'en', value: 'romaji here' },\n *  { type: 'other', value: '...!?' },\n *  { type: 'ja', value: '漢字ひらがなカタ　カナ' },\n *  { type: 'other', value: '４「' },\n *  { type: 'ja', value: 'ＳＨＩＯ' },\n *  { type: 'other', value: '」。！' },\n *  { type: 'en', value: ' ' },\n *  { type: 'other', value: 'لنذهب' },\n *]\n */\nfunction tokenize(input, { compact = false, detailed = false } = {}) {\n  if (input == null || isEmpty(input)) {\n    return [];\n  }\n  const chars = [...input];\n  let initial = chars.shift();\n  let prevType = getType(initial, compact);\n  initial = detailed ? { type: prevType, value: initial } : initial;\n\n  const result = chars.reduce((tokens, char) => {\n    const currType = getType(char, compact);\n    const sameType = currType === prevType;\n    prevType = currType;\n    let newValue = char;\n\n    if (sameType) {\n      newValue = (detailed ? tokens.pop().value : tokens.pop()) + newValue;\n    }\n\n    return detailed ? tokens.concat({ type: currType, value: newValue }) : tokens.concat(newValue);\n  }, [initial]);\n  return result;\n}\n\nexport default tokenize;","import isJapanese from './isJapanese';\nimport isKana from './isKana';\nimport isKanji from './isKanji';\nimport tokenize from './tokenize';\n\nconst isLeadingWithoutInitialKana = (input, leading) => leading && !isKana(input[0]);\nconst isTrailingWithoutFinalKana = (input, leading) => !leading && !isKana(input[input.length - 1]);\nconst isInvalidMatcher = (input, matchKanji) => matchKanji && ![...matchKanji].some(isKanji) || !matchKanji && isKana(input);\n\n/**\n * Strips [Okurigana](https://en.wikipedia.org/wiki/Okurigana)\n * @param  {String} input text\n * @param  {Object} [options={ leading: false, matchKanji: '' }] optional config\n * @return {String} text with okurigana removed\n * @example\n * stripOkurigana('踏み込む')\n * // => '踏み込'\n * stripOkurigana('お祝い')\n * // => 'お祝'\n * stripOkurigana('お腹', { leading: true });\n * // => '腹'\n * stripOkurigana('ふみこむ', { matchKanji: '踏み込む' });\n * // => 'ふみこ'\n * stripOkurigana('おみまい', { matchKanji: 'お祝い', leading: true });\n * // => 'みまい'\n */\nfunction stripOkurigana(input = '', { leading = false, matchKanji = '' } = {}) {\n  if (!isJapanese(input) || isLeadingWithoutInitialKana(input, leading) || isTrailingWithoutFinalKana(input, leading) || isInvalidMatcher(input, matchKanji)) {\n    return input;\n  }\n\n  const chars = matchKanji || input;\n  const okuriganaRegex = new RegExp(leading ? `^${tokenize(chars).shift()}` : `${tokenize(chars).pop()}$`);\n  return input.replace(okuriganaRegex, '');\n}\n\nexport default stripOkurigana;","import isEmpty from './utils/isEmpty';\nimport isCharHiragana from './utils/isCharHiragana';\n\n/**\n * Test if `input` is [Hiragana](https://en.wikipedia.org/wiki/Hiragana)\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Hiragana](https://en.wikipedia.org/wiki/Hiragana)\n * @example\n * isHiragana('げーむ')\n * // => true\n * isHiragana('A')\n * // => false\n * isHiragana('あア')\n * // => false\n */\nfunction isHiragana(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharHiragana);\n}\n\nexport default isHiragana;","import isEmpty from './utils/isEmpty';\nimport isCharKatakana from './utils/isCharKatakana';\n\n/**\n * Test if `input` is [Katakana](https://en.wikipedia.org/wiki/Katakana)\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Katakana](https://en.wikipedia.org/wiki/Katakana)\n * @example\n * isKatakana('ゲーム')\n * // => true\n * isKatakana('あ')\n * // => false\n * isKatakana('A')\n * // => false\n * isKatakana('あア')\n * // => false\n */\nfunction isKatakana(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharKatakana);\n}\n\nexport default isKatakana;","module.exports = zip;\n\n/*\n  zip([1, 2, 3]); // [[1], [2], [3]]\n  zip([1, 2, 3], ['a', 'b', 'c']); // [[1, 'a'], [2, 'b'], [3, 'c']]\n  zip([1, 2], ['a', 'b'], [true, false]); //[[1, 'a', true], [2, 'b', false]]\n\n  zip([1, 2, 3], ['a', 'b'], [true]);\n  // [[1, 'a', true], [2, 'b', undefined], [3, undefined, undefined]]\n\n  zip(undefined, {}, false, 1, 'foo'); // throws\n  zip([1, 2], ['a', 'b'], undefined, {}, false, 1, 'foo'); // throws\n  \n*/\n\nfunction zip() {\n  var result = [];\n  var args = Array.prototype.slice.call(arguments);\n  var argsLen = args.length;\n  var maxLen = 0;\n  var i, j;\n\n  if (!argsLen) {\n    throw new Error('zip requires at least one argument');\n  }\n\n  for (i = 0; i < argsLen; i++) {\n    if (!Array.isArray(args[i])) {\n      throw new Error('all arguments must be arrays');\n    }\n    var arrLen = args[i].length;\n    if (arrLen > maxLen) {\n      maxLen = arrLen;\n    }\n  }\n\n  for (i = 0; i < maxLen; i++) {\n    var group = [];\n    for (j = 0; j < argsLen; j++) {\n      if (!Array.isArray(args[j])) {\n        throw new Error('all arguments must be arrays');\n      }\n      group[j] = args[j][i];\n    }\n    result[i] = group;\n  }\n\n  return result;\n}\n","import stripOkurigana from 'wanakana/es/stripOkurigana';\nimport tokenize from 'wanakana/es/tokenize';\nimport isKanji from 'wanakana/es/isKanji';\nimport isKana from 'wanakana/es/isKana';\nimport isHiragana from 'wanakana/es/isHiragana';\nimport isKatakana from 'wanakana/es/isKatakana';\nimport zip from 'just-zip-it';\n\n/**\n * Combines furigana with kanji into an array of string pairs.\n * @param  {String} word vocab kanji word\n * @param  {String} reading vocab kana reading\n * @param  {String|Object} furi furigana placement info\n * @return {Array} furigana/kanji pairs\n * @example\n * combineFuri('お世辞', 'おせじ', '1:せ;2:じ')\n * // => [['', 'お'], ['せ', '世'], ['じ', '辞']]\n * combineFuri('大人しい', 'おとなしい') // smart fallbacks\n * // => [['おとな', '大人'], ['', 'しい']]\n * combineFuri('使い方', 'つかいかた') // smart fallbacks\n * // => [['つか', '使'], ['', 'い'], ['かた', '方']]\n *\n * // special compound readings (義訓/熟字訓) are spread across relevant kanji\n * combineFuri('胡座', 'あぐら', '0:あぐら')\n * // => [['あぐら', '胡座']]\n */\nexport function combineFuri(word = '', reading = '', furi = '') {\n  const furiLocs = parseFuri(furi);\n  // 義訓/熟字訓 words with a single furi loc: 今日 \"0:きょう\"\n  const isSpecialReading = furiLocs.length === 1 && [...word].every(isKanji);\n  const isKanaWord = [...word].every(isKana);\n  const isWanikaniMadness = [...reading].some(isHiragana) && [...reading].some(isKatakana);\n\n  if (word === reading || isKanaWord) {\n    return [['', word]];\n  }\n\n  if (!furi || isSpecialReading || isWanikaniMadness) {\n    return basicFuri(word, reading);\n  }\n\n  return generatePairs(word, furiLocs);\n}\n\n/**\n * Displays simple furigana by removing redundant kana\n * @param  {String} [word=''] 'お見舞い'\n * @param  {String} [reading=''] 'おみまい'\n * @return {Array} [['', 'お'], ['見舞', 'みま'], ['', 'い']]\n */\nexport function basicFuri(word = '', reading = '') {\n  // early return + guard against words like １日 which are tokenized unfavourably\n  if ([...word].every((c) => !isKana(c))) {\n    return [[reading, word]];\n  }\n\n  const [bikago, okurigana] = [\n    reading.slice(0, word.length - stripOkurigana(word, { leading: true }).length),\n    reading.slice(stripOkurigana(reading, { matchKanji: word }).length),\n  ];\n\n  const innerWordTokens = tokenize(removeExtraneousKana(word, bikago, okurigana));\n  let innerReadingChars = removeExtraneousKana(reading, bikago, okurigana);\n\n  const kanjiOddKanaEvenRegex = RegExp(\n    innerWordTokens.map((char) => (isKanji(char) ? '(.*)' : `(${char})`)).join('')\n  );\n\n  [, ...innerReadingChars] = innerReadingChars.match(kanjiOddKanaEvenRegex) || [];\n\n  const ret = zip(innerReadingChars, innerWordTokens).map(skipRedundantReadings);\n\n  if (bikago) {\n    ret.unshift(['', bikago]);\n  }\n\n  if (okurigana) {\n    ret.push(['', okurigana]);\n  }\n\n  return ret;\n}\n\nfunction removeExtraneousKana(str = '', leading = '', trailing = '') {\n  return str.replace(RegExp(`^${leading}`), '').replace(RegExp(`${trailing}$`), '');\n}\n\nfunction skipRedundantReadings([reading, word = '']) {\n  return !reading || reading === word ? ['', word] : [reading, word];\n}\n\nexport function parseFuri(data) {\n  return typeof data === 'string' ? parseFuriString(data) : parseFuriObject(data);\n}\n\n/**\n * Parses furigana placement object\n * @param  {Object} [locations={}] { 1:'せ', 2:'じ' }\n * @return {Array} [ [[1, 2], 'せ'], [[2, 3], 'じ'] ]\n */\nfunction parseFuriObject(locations = {}) {\n  return Object.entries(locations).map(([start, content]) => [\n    [Number(start), Number(start) + 1],\n    content,\n  ]);\n}\n\n/**\n * Parses furigana placement string\n * @param  {String} [locations=''] '1:せ;2:じ'\n * @return {Array} [ [[1, 2], 'せ'], [[2, 3], 'じ'] ]\n */\nfunction parseFuriString(locations = '') {\n  return locations.split(';').map((entry) => {\n    const [indexes, content] = entry.split(':');\n    const [start, end] = indexes.split('-').map(Number);\n    // NOTE: in the JMDict furistring data, the end index is either missing\n    // or it is listed as the *start* index of the final char ¯\\_(ツ)_/¯\n    // so we need to bump it either way to encompass that char\n    return [[start, end ? end + 1 : start + 1], content];\n  });\n}\n\n/**\n * Generates array pairs via furigana location data\n * @param  {String} word 'お世辞'\n * @param  {Array} furiLocs [[[1, 2], 'せ'], [[2, 3], 'じ']]\n * @return {Array} [['', 'お'], ['せ', '世'], ['じ', '辞']]\n */\nexport function generatePairs(word = '', furiLocs = []) {\n  let prevCharEnd = 0;\n\n  return furiLocs.reduce((pairs, [[start, end], furiText], index, source) => {\n    // if no furigana at this index, add intervening chars\n    if (start !== prevCharEnd) {\n      pairs.push(['', word.slice(prevCharEnd, start)]);\n    }\n\n    // add furigana and associated chars\n    pairs.push([furiText, word.slice(start, end)]);\n\n    // if no more furigana left, add any remaining chars/okurigana with blank furi\n    if (end < word.length && !source[index + 1]) {\n      pairs.push(['', word.slice(end)]);\n    }\n\n    prevCharEnd = end;\n    return pairs;\n  }, []);\n}\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport styled from 'styled-components';\n\nimport { combineFuri } from './utils';\n\nconst Wrapper = styled.span`\n  display: inline-flex;\n  flex-flow: row wrap;\n  font-family: 'ヒラギノ角ゴ ProN', 'Hiragino Kaku Gothic ProN', 'TakaoPゴシック', TakaoPGothic,\n    '游ゴシック', '游ゴシック体', YuGothic, 'Yu Gothic', 'メイリオ', Meiryo, 'ＭＳ ゴシック',\n    'MS Gothic', HiraKakuProN-W3, 'MotoyaLCedar', 'Droid Sans Japanese', sans-serif;\n`;\n\nconst Pair = styled.span`\n  display: inline-flex;\n  font-size: 24px;\n  line-height: 1;\n  flex-flow: column nowrap;\n  justify-content: flex-end;\n  align-items: center;\n  align-self: flex-end;\n`;\n\nconst Furi = styled.span`\n  display: block;\n  font-size: 0.5em;\n  letter-spacing: -0.02em;\n  margin: 0 0.1em;\n  padding-top: 0.2em;\n  padding-bottom: 0.1em;\n  user-select: none; /* don't interfere with main text selection */\n  opacity: 0.9;\n`;\n\nconst Text = styled.span`\n  display: block;\n`;\n\nfunction ReactFuri({ word, reading, furi, showFuri, render, ...props }) {\n  const pairs = combineFuri(word, reading, furi);\n\n  return render ? (\n    render({ pairs })\n  ) : (\n    <Wrapper lang=\"ja\" {...props}>\n      {pairs.map(([furiText, text], index) => (\n        // \"list\" is static, index is fine\n        // eslint-disable-next-line react/no-array-index-key\n        <Pair key={index}>\n          {showFuri && <Furi>{furiText}</Furi>}\n          <Text>{text}</Text>\n        </Pair>\n      ))}\n    </Wrapper>\n  );\n}\n\nReactFuri.propTypes = {\n  word: PropTypes.string.isRequired,\n  reading: PropTypes.string,\n  furi: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),\n  showFuri: PropTypes.bool,\n  render: PropTypes.func, // eslint-disable-line react/require-default-props\n};\n\nReactFuri.defaultProps = {\n  reading: '',\n  furi: '',\n  showFuri: true,\n};\n\nReactFuri.Wrapper = Wrapper;\nReactFuri.Pair = Pair;\nReactFuri.Furi = Furi;\nReactFuri.Text = Text;\n\nexport default ReactFuri;\n"]},"metadata":{},"sourceType":"module"}