{"ast":null,"code":"import _regeneratorRuntime from \"/home/byungchan/Projects/JapaneseQuiz/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/byungchan/Projects/JapaneseQuiz/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/byungchan/Projects/JapaneseQuiz/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/byungchan/Projects/JapaneseQuiz/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { ROMANIZATION_SYSTEM, getStrType, patchTokens, isHiragana, isKatakana, isKana, isKanji, isJapanese, hasHiragana, hasKatakana, hasKana, hasKanji, hasJapanese, toRawHiragana, toRawKatakana, toRawRomaji, kanaToHiragna, kanaToKatakana, kanaToRomaji } from \"./util\";\n/**\n * Kuroshiro Class\n */\n\nvar Kuroshiro = /*#__PURE__*/function () {\n  /**\n   * Constructor\n   * @constructs Kuroshiro\n   */\n  function Kuroshiro() {\n    _classCallCheck(this, Kuroshiro);\n\n    this._analyzer = null;\n  }\n  /**\n   * Initialize Kuroshiro\n   * @memberOf Kuroshiro\n   * @instance\n   * @returns {Promise} Promise object represents the result of initialization\n   */\n\n\n  _createClass(Kuroshiro, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(analyzer) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(!analyzer || typeof analyzer !== \"object\" || typeof analyzer.init !== \"function\" || typeof analyzer.parse !== \"function\")) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw new Error(\"Invalid initialization parameter.\");\n\n              case 4:\n                if (!(this._analyzer == null)) {\n                  _context.next = 16;\n                  break;\n                }\n\n                _context.prev = 5;\n                _context.next = 8;\n                return analyzer.init();\n\n              case 8:\n                this._analyzer = analyzer;\n                _context.next = 14;\n                break;\n\n              case 11:\n                _context.prev = 11;\n                _context.t0 = _context[\"catch\"](5);\n                throw _context.t0;\n\n              case 14:\n                _context.next = 17;\n                break;\n\n              case 16:\n                throw new Error(\"Kuroshiro has already been initialized.\");\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[5, 11]]);\n      }));\n\n      function init(_x) {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n    /**\n     * Convert given string to target syllabary with options available\n     * @memberOf Kuroshiro\n     * @instance\n     * @param {string} str Given String\n     * @param {Object} [options] Settings Object\n     * @param {string} [options.to=\"hiragana\"] Target syllabary [\"hiragana\"|\"katakana\"|\"romaji\"]\n     * @param {string} [options.mode=\"normal\"] Convert mode [\"normal\"|\"spaced\"|\"okurigana\"|\"furigana\"]\n     * @param {string} [options.romajiSystem=\"hepburn\"] Romanization System [\"nippon\"|\"passport\"|\"hepburn\"]\n     * @param {string} [options.delimiter_start=\"(\"] Delimiter(Start)\n     * @param {string} [options.delimiter_end=\")\"] Delimiter(End)\n     * @returns {Promise} Promise object represents the result of conversion\n     */\n\n  }, {\n    key: \"convert\",\n    value: function () {\n      var _convert = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(str, options) {\n        var ROMAJI_SYSTEMS, rawTokens, tokens, romajiConv, hi, tmp, hpattern, hc, hreg, hmatches, pickKJ, hc1, notations, i, strType, pattern, isLastTokenKanji, subs, c, reg, matches, pickKanji, c1, c2, c3, result, n0, n1, n2, n3, n4, n5;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                options = options || {};\n                options.to = options.to || \"hiragana\";\n                options.mode = options.mode || \"normal\";\n                options.romajiSystem = options.romajiSystem || ROMANIZATION_SYSTEM.HEPBURN;\n                options.delimiter_start = options.delimiter_start || \"(\";\n                options.delimiter_end = options.delimiter_end || \")\";\n                str = str || \"\";\n\n                if (!([\"hiragana\", \"katakana\", \"romaji\"].indexOf(options.to) === -1)) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                throw new Error(\"Invalid Target Syllabary.\");\n\n              case 9:\n                if (!([\"normal\", \"spaced\", \"okurigana\", \"furigana\"].indexOf(options.mode) === -1)) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                throw new Error(\"Invalid Conversion Mode.\");\n\n              case 11:\n                ROMAJI_SYSTEMS = Object.keys(ROMANIZATION_SYSTEM).map(function (e) {\n                  return ROMANIZATION_SYSTEM[e];\n                });\n\n                if (!(ROMAJI_SYSTEMS.indexOf(options.romajiSystem) === -1)) {\n                  _context2.next = 14;\n                  break;\n                }\n\n                throw new Error(\"Invalid Romanization System.\");\n\n              case 14:\n                _context2.next = 16;\n                return this._analyzer.parse(str);\n\n              case 16:\n                rawTokens = _context2.sent;\n                tokens = patchTokens(rawTokens);\n\n                if (!(options.mode === \"normal\" || options.mode === \"spaced\")) {\n                  _context2.next = 36;\n                  break;\n                }\n\n                _context2.t0 = options.to;\n                _context2.next = _context2.t0 === \"katakana\" ? 22 : _context2.t0 === \"romaji\" ? 25 : _context2.t0 === \"hiragana\" ? 29 : 33;\n                break;\n\n              case 22:\n                if (!(options.mode === \"normal\")) {\n                  _context2.next = 24;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", tokens.map(function (token) {\n                  return token.reading;\n                }).join(\"\"));\n\n              case 24:\n                return _context2.abrupt(\"return\", tokens.map(function (token) {\n                  return token.reading;\n                }).join(\" \"));\n\n              case 25:\n                romajiConv = function romajiConv(token) {\n                  var preToken;\n\n                  if (hasJapanese(token.surface_form)) {\n                    preToken = token.pronunciation || token.reading;\n                  } else {\n                    preToken = token.surface_form;\n                  }\n\n                  return toRawRomaji(preToken, options.romajiSystem);\n                };\n\n                if (!(options.mode === \"normal\")) {\n                  _context2.next = 28;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", tokens.map(romajiConv).join(\"\"));\n\n              case 28:\n                return _context2.abrupt(\"return\", tokens.map(romajiConv).join(\" \"));\n\n              case 29:\n                for (hi = 0; hi < tokens.length; hi++) {\n                  if (hasKanji(tokens[hi].surface_form)) {\n                    if (!hasKatakana(tokens[hi].surface_form)) {\n                      tokens[hi].reading = toRawHiragana(tokens[hi].reading);\n                    } else {\n                      // handle katakana-kanji-mixed tokens\n                      tokens[hi].reading = toRawHiragana(tokens[hi].reading);\n                      tmp = \"\";\n                      hpattern = \"\";\n\n                      for (hc = 0; hc < tokens[hi].surface_form.length; hc++) {\n                        if (isKanji(tokens[hi].surface_form[hc])) {\n                          hpattern += \"(.*)\";\n                        } else {\n                          hpattern += isKatakana(tokens[hi].surface_form[hc]) ? toRawHiragana(tokens[hi].surface_form[hc]) : tokens[hi].surface_form[hc];\n                        }\n                      }\n\n                      hreg = new RegExp(hpattern);\n                      hmatches = hreg.exec(tokens[hi].reading);\n\n                      if (hmatches) {\n                        pickKJ = 0;\n\n                        for (hc1 = 0; hc1 < tokens[hi].surface_form.length; hc1++) {\n                          if (isKanji(tokens[hi].surface_form[hc1])) {\n                            tmp += hmatches[pickKJ + 1];\n                            pickKJ++;\n                          } else {\n                            tmp += tokens[hi].surface_form[hc1];\n                          }\n                        }\n\n                        tokens[hi].reading = tmp;\n                      }\n                    }\n                  } else {\n                    tokens[hi].reading = tokens[hi].surface_form;\n                  }\n                }\n\n                if (!(options.mode === \"normal\")) {\n                  _context2.next = 32;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", tokens.map(function (token) {\n                  return token.reading;\n                }).join(\"\"));\n\n              case 32:\n                return _context2.abrupt(\"return\", tokens.map(function (token) {\n                  return token.reading;\n                }).join(\" \"));\n\n              case 33:\n                throw new Error(\"Unknown option.to param\");\n\n              case 34:\n                _context2.next = 73;\n                break;\n\n              case 36:\n                if (!(options.mode === \"okurigana\" || options.mode === \"furigana\")) {\n                  _context2.next = 73;\n                  break;\n                }\n\n                notations = []; // [basic, basic_type[1=kanji,2=kana,3=others], notation, pronunciation]\n\n                i = 0;\n\n              case 39:\n                if (!(i < tokens.length)) {\n                  _context2.next = 62;\n                  break;\n                }\n\n                strType = getStrType(tokens[i].surface_form);\n                _context2.t1 = strType;\n                _context2.next = _context2.t1 === 0 ? 44 : _context2.t1 === 1 ? 46 : _context2.t1 === 2 ? 54 : _context2.t1 === 3 ? 56 : 58;\n                break;\n\n              case 44:\n                notations.push([tokens[i].surface_form, 1, toRawHiragana(tokens[i].reading), tokens[i].pronunciation || tokens[i].reading]);\n                return _context2.abrupt(\"break\", 59);\n\n              case 46:\n                pattern = \"\";\n                isLastTokenKanji = false;\n                subs = []; // recognize kanjis and group them\n\n                for (c = 0; c < tokens[i].surface_form.length; c++) {\n                  if (isKanji(tokens[i].surface_form[c])) {\n                    if (!isLastTokenKanji) {\n                      // ignore successive kanji tokens (#10)\n                      isLastTokenKanji = true;\n                      pattern += \"(.*)\";\n                      subs.push(tokens[i].surface_form[c]);\n                    } else {\n                      subs[subs.length - 1] += tokens[i].surface_form[c];\n                    }\n                  } else {\n                    isLastTokenKanji = false;\n                    subs.push(tokens[i].surface_form[c]);\n                    pattern += isKatakana(tokens[i].surface_form[c]) ? toRawHiragana(tokens[i].surface_form[c]) : tokens[i].surface_form[c];\n                  }\n                }\n\n                reg = new RegExp(\"^\".concat(pattern, \"$\"));\n                matches = reg.exec(toRawHiragana(tokens[i].reading));\n\n                if (matches) {\n                  pickKanji = 1;\n\n                  for (c1 = 0; c1 < subs.length; c1++) {\n                    if (isKanji(subs[c1][0])) {\n                      notations.push([subs[c1], 1, matches[pickKanji], toRawKatakana(matches[pickKanji])]);\n                      pickKanji += 1;\n                    } else {\n                      notations.push([subs[c1], 2, toRawHiragana(subs[c1]), toRawKatakana(subs[c1])]);\n                    }\n                  }\n                } else {\n                  notations.push([tokens[i].surface_form, 1, toRawHiragana(tokens[i].reading), tokens[i].pronunciation || tokens[i].reading]);\n                }\n\n                return _context2.abrupt(\"break\", 59);\n\n              case 54:\n                for (c2 = 0; c2 < tokens[i].surface_form.length; c2++) {\n                  notations.push([tokens[i].surface_form[c2], 2, toRawHiragana(tokens[i].reading[c2]), tokens[i].pronunciation && tokens[i].pronunciation[c2] || tokens[i].reading[c2]]);\n                }\n\n                return _context2.abrupt(\"break\", 59);\n\n              case 56:\n                for (c3 = 0; c3 < tokens[i].surface_form.length; c3++) {\n                  notations.push([tokens[i].surface_form[c3], 3, tokens[i].surface_form[c3], tokens[i].surface_form[c3]]);\n                }\n\n                return _context2.abrupt(\"break\", 59);\n\n              case 58:\n                throw new Error(\"Unknown strType\");\n\n              case 59:\n                i++;\n                _context2.next = 39;\n                break;\n\n              case 62:\n                result = \"\";\n                _context2.t2 = options.to;\n                _context2.next = _context2.t2 === \"katakana\" ? 66 : _context2.t2 === \"romaji\" ? 68 : _context2.t2 === \"hiragana\" ? 70 : 72;\n                break;\n\n              case 66:\n                if (options.mode === \"okurigana\") {\n                  for (n0 = 0; n0 < notations.length; n0++) {\n                    if (notations[n0][1] !== 1) {\n                      result += notations[n0][0];\n                    } else {\n                      result += notations[n0][0] + options.delimiter_start + toRawKatakana(notations[n0][2]) + options.delimiter_end;\n                    }\n                  }\n                } else {\n                  // furigana\n                  for (n1 = 0; n1 < notations.length; n1++) {\n                    if (notations[n1][1] !== 1) {\n                      result += notations[n1][0];\n                    } else {\n                      result += \"<ruby>\".concat(notations[n1][0], \"<rp>\").concat(options.delimiter_start, \"</rp><rt>\").concat(toRawKatakana(notations[n1][2]), \"</rt><rp>\").concat(options.delimiter_end, \"</rp></ruby>\");\n                    }\n                  }\n                }\n\n                return _context2.abrupt(\"return\", result);\n\n              case 68:\n                if (options.mode === \"okurigana\") {\n                  for (n2 = 0; n2 < notations.length; n2++) {\n                    if (notations[n2][1] !== 1) {\n                      result += notations[n2][0];\n                    } else {\n                      result += notations[n2][0] + options.delimiter_start + toRawRomaji(notations[n2][3], options.romajiSystem) + options.delimiter_end;\n                    }\n                  }\n                } else {\n                  // furigana\n                  result += \"<ruby>\";\n\n                  for (n3 = 0; n3 < notations.length; n3++) {\n                    result += \"\".concat(notations[n3][0], \"<rp>\").concat(options.delimiter_start, \"</rp><rt>\").concat(toRawRomaji(notations[n3][3], options.romajiSystem), \"</rt><rp>\").concat(options.delimiter_end, \"</rp>\");\n                  }\n\n                  result += \"</ruby>\";\n                }\n\n                return _context2.abrupt(\"return\", result);\n\n              case 70:\n                if (options.mode === \"okurigana\") {\n                  for (n4 = 0; n4 < notations.length; n4++) {\n                    if (notations[n4][1] !== 1) {\n                      result += notations[n4][0];\n                    } else {\n                      result += notations[n4][0] + options.delimiter_start + notations[n4][2] + options.delimiter_end;\n                    }\n                  }\n                } else {\n                  // furigana\n                  for (n5 = 0; n5 < notations.length; n5++) {\n                    if (notations[n5][1] !== 1) {\n                      result += notations[n5][0];\n                    } else {\n                      result += \"<ruby>\".concat(notations[n5][0], \"<rp>\").concat(options.delimiter_start, \"</rp><rt>\").concat(notations[n5][2], \"</rt><rp>\").concat(options.delimiter_end, \"</rp></ruby>\");\n                    }\n                  }\n                }\n\n                return _context2.abrupt(\"return\", result);\n\n              case 72:\n                throw new Error(\"Invalid Target Syllabary.\");\n\n              case 73:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function convert(_x2, _x3) {\n        return _convert.apply(this, arguments);\n      }\n\n      return convert;\n    }()\n  }]);\n\n  return Kuroshiro;\n}();\n\nvar Util = {\n  isHiragana: isHiragana,\n  isKatakana: isKatakana,\n  isKana: isKana,\n  isKanji: isKanji,\n  isJapanese: isJapanese,\n  hasHiragana: hasHiragana,\n  hasKatakana: hasKatakana,\n  hasKana: hasKana,\n  hasKanji: hasKanji,\n  hasJapanese: hasJapanese,\n  kanaToHiragna: kanaToHiragna,\n  kanaToKatakana: kanaToKatakana,\n  kanaToRomaji: kanaToRomaji\n};\nKuroshiro.Util = Util;\nexport default Kuroshiro;","map":{"version":3,"sources":["/home/byungchan/Projects/JapaneseQuiz/node_modules/kuroshiro/src/core.js"],"names":["ROMANIZATION_SYSTEM","getStrType","patchTokens","isHiragana","isKatakana","isKana","isKanji","isJapanese","hasHiragana","hasKatakana","hasKana","hasKanji","hasJapanese","toRawHiragana","toRawKatakana","toRawRomaji","kanaToHiragna","kanaToKatakana","kanaToRomaji","Kuroshiro","_analyzer","analyzer","init","parse","Error","str","options","to","mode","romajiSystem","HEPBURN","delimiter_start","delimiter_end","indexOf","ROMAJI_SYSTEMS","Object","keys","map","e","rawTokens","tokens","token","reading","join","romajiConv","preToken","surface_form","pronunciation","hi","length","tmp","hpattern","hc","hreg","RegExp","hmatches","exec","pickKJ","hc1","notations","i","strType","push","pattern","isLastTokenKanji","subs","c","reg","matches","pickKanji","c1","c2","c3","result","n0","n1","n2","n3","n4","n5","Util"],"mappings":"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","sourcesContent":["import {\n    ROMANIZATION_SYSTEM,\n    getStrType,\n    patchTokens,\n    isHiragana,\n    isKatakana,\n    isKana,\n    isKanji,\n    isJapanese,\n    hasHiragana,\n    hasKatakana,\n    hasKana,\n    hasKanji,\n    hasJapanese,\n    toRawHiragana,\n    toRawKatakana,\n    toRawRomaji,\n    kanaToHiragna,\n    kanaToKatakana,\n    kanaToRomaji\n} from \"./util\";\n\n/**\n * Kuroshiro Class\n */\nclass Kuroshiro {\n    /**\n     * Constructor\n     * @constructs Kuroshiro\n     */\n    constructor() {\n        this._analyzer = null;\n    }\n\n    /**\n     * Initialize Kuroshiro\n     * @memberOf Kuroshiro\n     * @instance\n     * @returns {Promise} Promise object represents the result of initialization\n     */\n    async init(analyzer) {\n        if (!analyzer || typeof analyzer !== \"object\" || typeof analyzer.init !== \"function\" || typeof analyzer.parse !== \"function\") {\n            throw new Error(\"Invalid initialization parameter.\");\n        }\n        else if (this._analyzer == null) {\n            try {\n                await analyzer.init();\n                this._analyzer = analyzer;\n            }\n            catch (err) {\n                throw err;\n            }\n        }\n        else {\n            throw new Error(\"Kuroshiro has already been initialized.\");\n        }\n    }\n\n    /**\n     * Convert given string to target syllabary with options available\n     * @memberOf Kuroshiro\n     * @instance\n     * @param {string} str Given String\n     * @param {Object} [options] Settings Object\n     * @param {string} [options.to=\"hiragana\"] Target syllabary [\"hiragana\"|\"katakana\"|\"romaji\"]\n     * @param {string} [options.mode=\"normal\"] Convert mode [\"normal\"|\"spaced\"|\"okurigana\"|\"furigana\"]\n     * @param {string} [options.romajiSystem=\"hepburn\"] Romanization System [\"nippon\"|\"passport\"|\"hepburn\"]\n     * @param {string} [options.delimiter_start=\"(\"] Delimiter(Start)\n     * @param {string} [options.delimiter_end=\")\"] Delimiter(End)\n     * @returns {Promise} Promise object represents the result of conversion\n     */\n    async convert(str, options) {\n        options = options || {};\n        options.to = options.to || \"hiragana\";\n        options.mode = options.mode || \"normal\";\n        options.romajiSystem = options.romajiSystem || ROMANIZATION_SYSTEM.HEPBURN;\n        options.delimiter_start = options.delimiter_start || \"(\";\n        options.delimiter_end = options.delimiter_end || \")\";\n        str = str || \"\";\n\n        if ([\"hiragana\", \"katakana\", \"romaji\"].indexOf(options.to) === -1) {\n            throw new Error(\"Invalid Target Syllabary.\");\n        }\n\n        if ([\"normal\", \"spaced\", \"okurigana\", \"furigana\"].indexOf(options.mode) === -1) {\n            throw new Error(\"Invalid Conversion Mode.\");\n        }\n\n        const ROMAJI_SYSTEMS = Object.keys(ROMANIZATION_SYSTEM).map(e => ROMANIZATION_SYSTEM[e]);\n        if (ROMAJI_SYSTEMS.indexOf(options.romajiSystem) === -1) {\n            throw new Error(\"Invalid Romanization System.\");\n        }\n\n        const rawTokens = await this._analyzer.parse(str);\n        const tokens = patchTokens(rawTokens);\n\n        if (options.mode === \"normal\" || options.mode === \"spaced\") {\n            switch (options.to) {\n                case \"katakana\":\n                    if (options.mode === \"normal\") {\n                        return tokens.map(token => token.reading).join(\"\");\n                    }\n                    return tokens.map(token => token.reading).join(\" \");\n                case \"romaji\":\n                    const romajiConv = (token) => {\n                        let preToken;\n                        if (hasJapanese(token.surface_form)) {\n                            preToken = token.pronunciation || token.reading;\n                        }\n                        else {\n                            preToken = token.surface_form;\n                        }\n                        return toRawRomaji(preToken, options.romajiSystem);\n                    };\n                    if (options.mode === \"normal\") {\n                        return tokens.map(romajiConv).join(\"\");\n                    }\n                    return tokens.map(romajiConv).join(\" \");\n                case \"hiragana\":\n                    for (let hi = 0; hi < tokens.length; hi++) {\n                        if (hasKanji(tokens[hi].surface_form)) {\n                            if (!hasKatakana(tokens[hi].surface_form)) {\n                                tokens[hi].reading = toRawHiragana(tokens[hi].reading);\n                            }\n                            else {\n                                // handle katakana-kanji-mixed tokens\n                                tokens[hi].reading = toRawHiragana(tokens[hi].reading);\n                                let tmp = \"\";\n                                let hpattern = \"\";\n                                for (let hc = 0; hc < tokens[hi].surface_form.length; hc++) {\n                                    if (isKanji(tokens[hi].surface_form[hc])) {\n                                        hpattern += \"(.*)\";\n                                    }\n                                    else {\n                                        hpattern += isKatakana(tokens[hi].surface_form[hc]) ? toRawHiragana(tokens[hi].surface_form[hc]) : tokens[hi].surface_form[hc];\n                                    }\n                                }\n                                const hreg = new RegExp(hpattern);\n                                const hmatches = hreg.exec(tokens[hi].reading);\n                                if (hmatches) {\n                                    let pickKJ = 0;\n                                    for (let hc1 = 0; hc1 < tokens[hi].surface_form.length; hc1++) {\n                                        if (isKanji(tokens[hi].surface_form[hc1])) {\n                                            tmp += hmatches[pickKJ + 1];\n                                            pickKJ++;\n                                        }\n                                        else {\n                                            tmp += tokens[hi].surface_form[hc1];\n                                        }\n                                    }\n                                    tokens[hi].reading = tmp;\n                                }\n                            }\n                        }\n                        else {\n                            tokens[hi].reading = tokens[hi].surface_form;\n                        }\n                    }\n                    if (options.mode === \"normal\") {\n                        return tokens.map(token => token.reading).join(\"\");\n                    }\n                    return tokens.map(token => token.reading).join(\" \");\n                default:\n                    throw new Error(\"Unknown option.to param\");\n            }\n        }\n        else if (options.mode === \"okurigana\" || options.mode === \"furigana\") {\n            const notations = []; // [basic, basic_type[1=kanji,2=kana,3=others], notation, pronunciation]\n            for (let i = 0; i < tokens.length; i++) {\n                const strType = getStrType(tokens[i].surface_form);\n                switch (strType) {\n                    case 0:\n                        notations.push([tokens[i].surface_form, 1, toRawHiragana(tokens[i].reading), tokens[i].pronunciation || tokens[i].reading]);\n                        break;\n                    case 1:\n                        let pattern = \"\";\n                        let isLastTokenKanji = false;\n                        const subs = []; // recognize kanjis and group them\n                        for (let c = 0; c < tokens[i].surface_form.length; c++) {\n                            if (isKanji(tokens[i].surface_form[c])) {\n                                if (!isLastTokenKanji) { // ignore successive kanji tokens (#10)\n                                    isLastTokenKanji = true;\n                                    pattern += \"(.*)\";\n                                    subs.push(tokens[i].surface_form[c]);\n                                }\n                                else {\n                                    subs[subs.length - 1] += tokens[i].surface_form[c];\n                                }\n                            }\n                            else {\n                                isLastTokenKanji = false;\n                                subs.push(tokens[i].surface_form[c]);\n                                pattern += isKatakana(tokens[i].surface_form[c]) ? toRawHiragana(tokens[i].surface_form[c]) : tokens[i].surface_form[c];\n                            }\n                        }\n                        const reg = new RegExp(`^${pattern}$`);\n                        const matches = reg.exec(toRawHiragana(tokens[i].reading));\n                        if (matches) {\n                            let pickKanji = 1;\n                            for (let c1 = 0; c1 < subs.length; c1++) {\n                                if (isKanji(subs[c1][0])) {\n                                    notations.push([subs[c1], 1, matches[pickKanji], toRawKatakana(matches[pickKanji])]);\n                                    pickKanji += 1;\n                                }\n                                else {\n                                    notations.push([subs[c1], 2, toRawHiragana(subs[c1]), toRawKatakana(subs[c1])]);\n                                }\n                            }\n                        }\n                        else {\n                            notations.push([tokens[i].surface_form, 1, toRawHiragana(tokens[i].reading), tokens[i].pronunciation || tokens[i].reading]);\n                        }\n                        break;\n                    case 2:\n                        for (let c2 = 0; c2 < tokens[i].surface_form.length; c2++) {\n                            notations.push([tokens[i].surface_form[c2], 2, toRawHiragana(tokens[i].reading[c2]), (tokens[i].pronunciation && tokens[i].pronunciation[c2]) || tokens[i].reading[c2]]);\n                        }\n                        break;\n                    case 3:\n                        for (let c3 = 0; c3 < tokens[i].surface_form.length; c3++) {\n                            notations.push([tokens[i].surface_form[c3], 3, tokens[i].surface_form[c3], tokens[i].surface_form[c3]]);\n                        }\n                        break;\n                    default:\n                        throw new Error(\"Unknown strType\");\n                }\n            }\n            let result = \"\";\n            switch (options.to) {\n                case \"katakana\":\n                    if (options.mode === \"okurigana\") {\n                        for (let n0 = 0; n0 < notations.length; n0++) {\n                            if (notations[n0][1] !== 1) {\n                                result += notations[n0][0];\n                            }\n                            else {\n                                result += notations[n0][0] + options.delimiter_start + toRawKatakana(notations[n0][2]) + options.delimiter_end;\n                            }\n                        }\n                    }\n                    else { // furigana\n                        for (let n1 = 0; n1 < notations.length; n1++) {\n                            if (notations[n1][1] !== 1) {\n                                result += notations[n1][0];\n                            }\n                            else {\n                                result += `<ruby>${notations[n1][0]}<rp>${options.delimiter_start}</rp><rt>${toRawKatakana(notations[n1][2])}</rt><rp>${options.delimiter_end}</rp></ruby>`;\n                            }\n                        }\n                    }\n                    return result;\n                case \"romaji\":\n                    if (options.mode === \"okurigana\") {\n                        for (let n2 = 0; n2 < notations.length; n2++) {\n                            if (notations[n2][1] !== 1) {\n                                result += notations[n2][0];\n                            }\n                            else {\n                                result += notations[n2][0] + options.delimiter_start + toRawRomaji(notations[n2][3], options.romajiSystem) + options.delimiter_end;\n                            }\n                        }\n                    }\n                    else { // furigana\n                        result += \"<ruby>\";\n                        for (let n3 = 0; n3 < notations.length; n3++) {\n                            result += `${notations[n3][0]}<rp>${options.delimiter_start}</rp><rt>${toRawRomaji(notations[n3][3], options.romajiSystem)}</rt><rp>${options.delimiter_end}</rp>`;\n                        }\n                        result += \"</ruby>\";\n                    }\n                    return result;\n                case \"hiragana\":\n                    if (options.mode === \"okurigana\") {\n                        for (let n4 = 0; n4 < notations.length; n4++) {\n                            if (notations[n4][1] !== 1) {\n                                result += notations[n4][0];\n                            }\n                            else {\n                                result += notations[n4][0] + options.delimiter_start + notations[n4][2] + options.delimiter_end;\n                            }\n                        }\n                    }\n                    else { // furigana\n                        for (let n5 = 0; n5 < notations.length; n5++) {\n                            if (notations[n5][1] !== 1) {\n                                result += notations[n5][0];\n                            }\n                            else {\n                                result += `<ruby>${notations[n5][0]}<rp>${options.delimiter_start}</rp><rt>${notations[n5][2]}</rt><rp>${options.delimiter_end}</rp></ruby>`;\n                            }\n                        }\n                    }\n                    return result;\n                default:\n                    throw new Error(\"Invalid Target Syllabary.\");\n            }\n        }\n    }\n}\n\nconst Util = {\n    isHiragana,\n    isKatakana,\n    isKana,\n    isKanji,\n    isJapanese,\n    hasHiragana,\n    hasKatakana,\n    hasKana,\n    hasKanji,\n    hasJapanese,\n    kanaToHiragna,\n    kanaToKatakana,\n    kanaToRomaji\n};\n\nKuroshiro.Util = Util;\n\nexport default Kuroshiro;\n"]},"metadata":{},"sourceType":"module"}