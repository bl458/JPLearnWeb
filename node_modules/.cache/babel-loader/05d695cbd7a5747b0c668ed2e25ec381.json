{"ast":null,"code":"/*\n * Copyright 2014 Takuya Asano\n * Copyright 2010-2014 Atilika Inc. and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\n\nvar ByteBuffer = require(\"../util/ByteBuffer\");\n\nvar CharacterClass = require(\"./CharacterClass\");\n/**\n * InvokeDefinitionMap represents invoke definition a part of char.def\n * @constructor\n */\n\n\nfunction InvokeDefinitionMap() {\n  this.map = [];\n  this.lookup_table = {}; // Just for building dictionary\n}\n/**\n * Load InvokeDefinitionMap from buffer\n * @param {Uint8Array} invoke_def_buffer\n * @returns {InvokeDefinitionMap}\n */\n\n\nInvokeDefinitionMap.load = function (invoke_def_buffer) {\n  var invoke_def = new InvokeDefinitionMap();\n  var character_category_definition = [];\n  var buffer = new ByteBuffer(invoke_def_buffer);\n\n  while (buffer.position + 1 < buffer.size()) {\n    var class_id = character_category_definition.length;\n    var is_always_invoke = buffer.get();\n    var is_grouping = buffer.get();\n    var max_length = buffer.getInt();\n    var class_name = buffer.getString();\n    character_category_definition.push(new CharacterClass(class_id, class_name, is_always_invoke, is_grouping, max_length));\n  }\n\n  invoke_def.init(character_category_definition);\n  return invoke_def;\n};\n/**\n * Initializing method\n * @param {Array.<CharacterClass>} character_category_definition Array of CharacterClass\n */\n\n\nInvokeDefinitionMap.prototype.init = function (character_category_definition) {\n  if (character_category_definition == null) {\n    return;\n  }\n\n  for (var i = 0; i < character_category_definition.length; i++) {\n    var character_class = character_category_definition[i];\n    this.map[i] = character_class;\n    this.lookup_table[character_class.class_name] = i;\n  }\n};\n/**\n * Get class information by class ID\n * @param {number} class_id\n * @returns {CharacterClass}\n */\n\n\nInvokeDefinitionMap.prototype.getCharacterClass = function (class_id) {\n  return this.map[class_id];\n};\n/**\n * For building character definition dictionary\n * @param {string} class_name character\n * @returns {number} class_id\n */\n\n\nInvokeDefinitionMap.prototype.lookup = function (class_name) {\n  var class_id = this.lookup_table[class_name];\n\n  if (class_id == null) {\n    return null;\n  }\n\n  return class_id;\n};\n/**\n * Transform from map to binary buffer\n * @returns {Uint8Array}\n */\n\n\nInvokeDefinitionMap.prototype.toBuffer = function () {\n  var buffer = new ByteBuffer();\n\n  for (var i = 0; i < this.map.length; i++) {\n    var char_class = this.map[i];\n    buffer.put(char_class.is_always_invoke);\n    buffer.put(char_class.is_grouping);\n    buffer.putInt(char_class.max_length);\n    buffer.putString(char_class.class_name);\n  }\n\n  buffer.shrink();\n  return buffer.buffer;\n};\n\nmodule.exports = InvokeDefinitionMap;","map":{"version":3,"sources":["/home/byungchan/Projects/JapaneseQuiz/node_modules/kuromoji/src/dict/InvokeDefinitionMap.js"],"names":["ByteBuffer","require","CharacterClass","InvokeDefinitionMap","map","lookup_table","load","invoke_def_buffer","invoke_def","character_category_definition","buffer","position","size","class_id","length","is_always_invoke","get","is_grouping","max_length","getInt","class_name","getString","push","init","prototype","i","character_class","getCharacterClass","lookup","toBuffer","char_class","put","putInt","putString","shrink","module","exports"],"mappings":"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","sourcesContent":["/*\n * Copyright 2014 Takuya Asano\n * Copyright 2010-2014 Atilika Inc. and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\"use strict\";\n\nvar ByteBuffer = require(\"../util/ByteBuffer\");\nvar CharacterClass = require(\"./CharacterClass\");\n\n/**\n * InvokeDefinitionMap represents invoke definition a part of char.def\n * @constructor\n */\nfunction InvokeDefinitionMap() {\n    this.map = [];\n    this.lookup_table = {};  // Just for building dictionary\n}\n\n/**\n * Load InvokeDefinitionMap from buffer\n * @param {Uint8Array} invoke_def_buffer\n * @returns {InvokeDefinitionMap}\n */\nInvokeDefinitionMap.load = function (invoke_def_buffer) {\n    var invoke_def = new InvokeDefinitionMap();\n    var character_category_definition = [];\n\n    var buffer = new ByteBuffer(invoke_def_buffer);\n    while (buffer.position + 1 < buffer.size()) {\n        var class_id = character_category_definition.length;\n        var is_always_invoke = buffer.get();\n        var is_grouping = buffer.get();\n        var max_length = buffer.getInt();\n        var class_name = buffer.getString();\n        character_category_definition.push(new CharacterClass(class_id, class_name, is_always_invoke, is_grouping, max_length));\n    }\n\n    invoke_def.init(character_category_definition);\n\n    return invoke_def;\n};\n\n/**\n * Initializing method\n * @param {Array.<CharacterClass>} character_category_definition Array of CharacterClass\n */\nInvokeDefinitionMap.prototype.init = function (character_category_definition) {\n    if (character_category_definition == null) {\n        return;\n    }\n    for (var i = 0; i < character_category_definition.length; i++) {\n        var character_class = character_category_definition[i];\n        this.map[i] = character_class;\n        this.lookup_table[character_class.class_name] = i;\n    }\n};\n\n/**\n * Get class information by class ID\n * @param {number} class_id\n * @returns {CharacterClass}\n */\nInvokeDefinitionMap.prototype.getCharacterClass = function (class_id) {\n    return this.map[class_id];\n};\n\n/**\n * For building character definition dictionary\n * @param {string} class_name character\n * @returns {number} class_id\n */\nInvokeDefinitionMap.prototype.lookup = function (class_name) {\n    var class_id = this.lookup_table[class_name];\n    if (class_id == null) {\n        return null;\n    }\n    return class_id;\n};\n\n/**\n * Transform from map to binary buffer\n * @returns {Uint8Array}\n */\nInvokeDefinitionMap.prototype.toBuffer = function () {\n    var buffer = new ByteBuffer();\n    for (var i = 0; i < this.map.length; i++) {\n        var char_class = this.map[i];\n        buffer.put(char_class.is_always_invoke);\n        buffer.put(char_class.is_grouping);\n        buffer.putInt(char_class.max_length);\n        buffer.putString(char_class.class_name);\n    }\n    buffer.shrink();\n    return buffer.buffer;\n};\n\nmodule.exports = InvokeDefinitionMap;\n"]},"metadata":{},"sourceType":"script"}