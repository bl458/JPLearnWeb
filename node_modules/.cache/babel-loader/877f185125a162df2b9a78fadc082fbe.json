{"ast":null,"code":"import kuromoji from \"kuromoji\"; // Check where we are\n\nlet isNode = false;\nconst isBrowser = typeof window !== \"undefined\";\n\nif (!isBrowser && typeof module !== \"undefined\" && module.exports) {\n  isNode = true;\n}\n/**\n * Kuromoji based morphological analyzer for kuroshiro\n */\n\n\nclass Analyzer {\n  /**\n   * Constructor\n   * @param {Object} [options] JSON object which have key-value pairs settings\n   * @param {string} [options.dictPath] Path of the dictionary files\n   */\n  constructor({\n    dictPath\n  } = {}) {\n    this._analyzer = null;\n\n    if (!dictPath) {\n      if (isNode) this._dictPath = require.resolve(\"kuromoji\").replace(/src(?!.*src).*/, \"dict/\");else this._dictPath = \"node_modules/kuromoji/dict/\";\n    } else {\n      this._dictPath = dictPath;\n    }\n  }\n  /**\n   * Initialize the analyzer\n   * @returns {Promise} Promise object represents the result of initialization\n   */\n\n\n  init() {\n    return new Promise((resolve, reject) => {\n      const self = this;\n\n      if (this._analyzer == null) {\n        kuromoji.builder({\n          dicPath: this._dictPath\n        }).build((err, newAnalyzer) => {\n          if (err) {\n            return reject(err);\n          }\n\n          self._analyzer = newAnalyzer;\n          resolve();\n        });\n      } else {\n        reject(new Error(\"This analyzer has already been initialized.\"));\n      }\n    });\n  }\n  /**\n   * Parse the given string\n   * @param {string} str input string\n   * @returns {Promise} Promise object represents the result of parsing\n   * @example The result of parsing\n   * [{\n   *     \"surface_form\": \"黒白\",    // 表層形\n   *     \"pos\": \"名詞\",               // 品詞 (part of speech)\n   *     \"pos_detail_1\": \"一般\",      // 品詞細分類1\n   *     \"pos_detail_2\": \"*\",        // 品詞細分類2\n   *     \"pos_detail_3\": \"*\",        // 品詞細分類3\n   *     \"conjugated_type\": \"*\",     // 活用型\n   *     \"conjugated_form\": \"*\",     // 活用形\n   *     \"basic_form\": \"黒白\",      // 基本形\n   *     \"reading\": \"クロシロ\",       // 読み\n   *     \"pronunciation\": \"クロシロ\",  // 発音\n   *     \"verbose\": {                 // Other properties\n   *         \"word_id\": 413560,\n   *         \"word_type\": \"KNOWN\",\n   *         \"word_position\": 1\n   *     }\n   * }]\n   */\n\n\n  parse(str = \"\") {\n    return new Promise((resolve, reject) => {\n      if (str.trim() === \"\") return resolve([]);\n\n      const result = this._analyzer.tokenize(str);\n\n      for (let i = 0; i < result.length; i++) {\n        result[i].verbose = {};\n        result[i].verbose.word_id = result[i].word_id;\n        result[i].verbose.word_type = result[i].word_type;\n        result[i].verbose.word_position = result[i].word_position;\n        delete result[i].word_id;\n        delete result[i].word_type;\n        delete result[i].word_position;\n      }\n\n      resolve(result);\n    });\n  }\n\n}\n\nexport default Analyzer;","map":{"version":3,"sources":["/home/byungchan/Projects/JapaneseQuiz/node_modules/kuroshiro-analyzer-kuromoji/src/index.js"],"names":["kuromoji","isNode","isBrowser","window","module","exports","Analyzer","constructor","dictPath","_analyzer","_dictPath","require","resolve","replace","init","Promise","reject","self","builder","dicPath","build","err","newAnalyzer","Error","parse","str","trim","result","tokenize","i","length","verbose","word_id","word_type","word_position"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,UAArB,C,CAEA;;AACA,IAAIC,MAAM,GAAG,KAAb;AACA,MAAMC,SAAS,GAAI,OAAOC,MAAP,KAAkB,WAArC;;AACA,IAAI,CAACD,SAAD,IAAc,OAAOE,MAAP,KAAkB,WAAhC,IAA+CA,MAAM,CAACC,OAA1D,EAAmE;AAC/DJ,EAAAA,MAAM,GAAG,IAAT;AACH;AAED;;;;;AAGA,MAAMK,QAAN,CAAe;AACX;;;;;AAKAC,EAAAA,WAAW,CAAC;AAAEC,IAAAA;AAAF,MAAe,EAAhB,EAAoB;AAC3B,SAAKC,SAAL,GAAiB,IAAjB;;AAEA,QAAI,CAACD,QAAL,EAAe;AACX,UAAIP,MAAJ,EAAY,KAAKS,SAAL,GAAiBC,OAAO,CAACC,OAAR,CAAgB,UAAhB,EAA4BC,OAA5B,CAAoC,gBAApC,EAAsD,OAAtD,CAAjB,CAAZ,KACK,KAAKH,SAAL,GAAiB,6BAAjB;AACR,KAHD,MAIK;AACD,WAAKA,SAAL,GAAiBF,QAAjB;AACH;AACJ;AAED;;;;;;AAIAM,EAAAA,IAAI,GAAG;AACH,WAAO,IAAIC,OAAJ,CAAY,CAACH,OAAD,EAAUI,MAAV,KAAqB;AACpC,YAAMC,IAAI,GAAG,IAAb;;AACA,UAAI,KAAKR,SAAL,IAAkB,IAAtB,EAA4B;AACxBT,QAAAA,QAAQ,CAACkB,OAAT,CAAiB;AAAEC,UAAAA,OAAO,EAAE,KAAKT;AAAhB,SAAjB,EAA8CU,KAA9C,CAAoD,CAACC,GAAD,EAAMC,WAAN,KAAsB;AACtE,cAAID,GAAJ,EAAS;AACL,mBAAOL,MAAM,CAACK,GAAD,CAAb;AACH;;AACDJ,UAAAA,IAAI,CAACR,SAAL,GAAiBa,WAAjB;AACAV,UAAAA,OAAO;AACV,SAND;AAOH,OARD,MASK;AACDI,QAAAA,MAAM,CAAC,IAAIO,KAAJ,CAAU,6CAAV,CAAD,CAAN;AACH;AACJ,KAdM,CAAP;AAeH;AAED;;;;;;;;;;;;;;;;;;;;;;;;;AAuBAC,EAAAA,KAAK,CAACC,GAAG,GAAG,EAAP,EAAW;AACZ,WAAO,IAAIV,OAAJ,CAAY,CAACH,OAAD,EAAUI,MAAV,KAAqB;AACpC,UAAIS,GAAG,CAACC,IAAJ,OAAe,EAAnB,EAAuB,OAAOd,OAAO,CAAC,EAAD,CAAd;;AACvB,YAAMe,MAAM,GAAG,KAAKlB,SAAL,CAAemB,QAAf,CAAwBH,GAAxB,CAAf;;AACA,WAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,MAAM,CAACG,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACpCF,QAAAA,MAAM,CAACE,CAAD,CAAN,CAAUE,OAAV,GAAoB,EAApB;AACAJ,QAAAA,MAAM,CAACE,CAAD,CAAN,CAAUE,OAAV,CAAkBC,OAAlB,GAA4BL,MAAM,CAACE,CAAD,CAAN,CAAUG,OAAtC;AACAL,QAAAA,MAAM,CAACE,CAAD,CAAN,CAAUE,OAAV,CAAkBE,SAAlB,GAA8BN,MAAM,CAACE,CAAD,CAAN,CAAUI,SAAxC;AACAN,QAAAA,MAAM,CAACE,CAAD,CAAN,CAAUE,OAAV,CAAkBG,aAAlB,GAAkCP,MAAM,CAACE,CAAD,CAAN,CAAUK,aAA5C;AACA,eAAOP,MAAM,CAACE,CAAD,CAAN,CAAUG,OAAjB;AACA,eAAOL,MAAM,CAACE,CAAD,CAAN,CAAUI,SAAjB;AACA,eAAON,MAAM,CAACE,CAAD,CAAN,CAAUK,aAAjB;AACH;;AACDtB,MAAAA,OAAO,CAACe,MAAD,CAAP;AACH,KAbM,CAAP;AAcH;;AA9EU;;AAiFf,eAAerB,QAAf","sourcesContent":["import kuromoji from \"kuromoji\";\n\n// Check where we are\nlet isNode = false;\nconst isBrowser = (typeof window !== \"undefined\");\nif (!isBrowser && typeof module !== \"undefined\" && module.exports) {\n    isNode = true;\n}\n\n/**\n * Kuromoji based morphological analyzer for kuroshiro\n */\nclass Analyzer {\n    /**\n     * Constructor\n     * @param {Object} [options] JSON object which have key-value pairs settings\n     * @param {string} [options.dictPath] Path of the dictionary files\n     */\n    constructor({ dictPath } = {}) {\n        this._analyzer = null;\n\n        if (!dictPath) {\n            if (isNode) this._dictPath = require.resolve(\"kuromoji\").replace(/src(?!.*src).*/, \"dict/\");\n            else this._dictPath = \"node_modules/kuromoji/dict/\";\n        }\n        else {\n            this._dictPath = dictPath;\n        }\n    }\n\n    /**\n     * Initialize the analyzer\n     * @returns {Promise} Promise object represents the result of initialization\n     */\n    init() {\n        return new Promise((resolve, reject) => {\n            const self = this;\n            if (this._analyzer == null) {\n                kuromoji.builder({ dicPath: this._dictPath }).build((err, newAnalyzer) => {\n                    if (err) {\n                        return reject(err);\n                    }\n                    self._analyzer = newAnalyzer;\n                    resolve();\n                });\n            }\n            else {\n                reject(new Error(\"This analyzer has already been initialized.\"));\n            }\n        });\n    }\n\n    /**\n     * Parse the given string\n     * @param {string} str input string\n     * @returns {Promise} Promise object represents the result of parsing\n     * @example The result of parsing\n     * [{\n     *     \"surface_form\": \"黒白\",    // 表層形\n     *     \"pos\": \"名詞\",               // 品詞 (part of speech)\n     *     \"pos_detail_1\": \"一般\",      // 品詞細分類1\n     *     \"pos_detail_2\": \"*\",        // 品詞細分類2\n     *     \"pos_detail_3\": \"*\",        // 品詞細分類3\n     *     \"conjugated_type\": \"*\",     // 活用型\n     *     \"conjugated_form\": \"*\",     // 活用形\n     *     \"basic_form\": \"黒白\",      // 基本形\n     *     \"reading\": \"クロシロ\",       // 読み\n     *     \"pronunciation\": \"クロシロ\",  // 発音\n     *     \"verbose\": {                 // Other properties\n     *         \"word_id\": 413560,\n     *         \"word_type\": \"KNOWN\",\n     *         \"word_position\": 1\n     *     }\n     * }]\n     */\n    parse(str = \"\") {\n        return new Promise((resolve, reject) => {\n            if (str.trim() === \"\") return resolve([]);\n            const result = this._analyzer.tokenize(str);\n            for (let i = 0; i < result.length; i++) {\n                result[i].verbose = {};\n                result[i].verbose.word_id = result[i].word_id;\n                result[i].verbose.word_type = result[i].word_type;\n                result[i].verbose.word_position = result[i].word_position;\n                delete result[i].word_id;\n                delete result[i].word_type;\n                delete result[i].word_position;\n            }\n            resolve(result);\n        });\n    }\n}\n\nexport default Analyzer;\n"]},"metadata":{},"sourceType":"module"}