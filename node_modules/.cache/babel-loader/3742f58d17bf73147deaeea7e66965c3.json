{"ast":null,"code":"// Copyright (c) 2014 Takuya Asano All Rights Reserved.\n(function () {\n  \"use strict\";\n\n  var TERM_CHAR = \"\\0\",\n      // terminal character\n  TERM_CODE = 0,\n      // terminal character code\n  ROOT_ID = 0,\n      // index of root node\n  NOT_FOUND = -1,\n      // traverse() returns if no nodes found\n  BASE_SIGNED = true,\n      CHECK_SIGNED = true,\n      BASE_BYTES = 4,\n      CHECK_BYTES = 4,\n      MEMORY_EXPAND_RATIO = 2;\n\n  var newBC = function newBC(initial_size) {\n    if (initial_size == null) {\n      initial_size = 1024;\n    }\n\n    var initBase = function initBase(_base, start, end) {\n      // 'end' index does not include\n      for (var i = start; i < end; i++) {\n        _base[i] = -i + 1; // inversed previous empty node index\n      }\n\n      if (0 < check.array[check.array.length - 1]) {\n        var last_used_id = check.array.length - 2;\n\n        while (0 < check.array[last_used_id]) {\n          last_used_id--;\n        }\n\n        _base[start] = -last_used_id;\n      }\n    };\n\n    var initCheck = function initCheck(_check, start, end) {\n      for (var i = start; i < end; i++) {\n        _check[i] = -i - 1; // inversed next empty node index\n      }\n    };\n\n    var realloc = function realloc(min_size) {\n      // expand arrays size by given ratio\n      var new_size = min_size * MEMORY_EXPAND_RATIO; // console.log('re-allocate memory to ' + new_size);\n\n      var base_new_array = newArrayBuffer(base.signed, base.bytes, new_size);\n      initBase(base_new_array, base.array.length, new_size); // init BASE in new range\n\n      base_new_array.set(base.array);\n      base.array = null; // explicit GC\n\n      base.array = base_new_array;\n      var check_new_array = newArrayBuffer(check.signed, check.bytes, new_size);\n      initCheck(check_new_array, check.array.length, new_size); // init CHECK in new range\n\n      check_new_array.set(check.array);\n      check.array = null; // explicit GC\n\n      check.array = check_new_array;\n    };\n\n    var first_unused_node = ROOT_ID + 1;\n    var base = {\n      signed: BASE_SIGNED,\n      bytes: BASE_BYTES,\n      array: newArrayBuffer(BASE_SIGNED, BASE_BYTES, initial_size)\n    };\n    var check = {\n      signed: CHECK_SIGNED,\n      bytes: CHECK_BYTES,\n      array: newArrayBuffer(CHECK_SIGNED, CHECK_BYTES, initial_size)\n    }; // init root node\n\n    base.array[ROOT_ID] = 1;\n    check.array[ROOT_ID] = ROOT_ID; // init BASE\n\n    initBase(base.array, ROOT_ID + 1, base.array.length); // init CHECK\n\n    initCheck(check.array, ROOT_ID + 1, check.array.length);\n    return {\n      getBaseBuffer: function getBaseBuffer() {\n        return base.array;\n      },\n      getCheckBuffer: function getCheckBuffer() {\n        return check.array;\n      },\n      loadBaseBuffer: function loadBaseBuffer(base_buffer) {\n        base.array = base_buffer;\n        return this;\n      },\n      loadCheckBuffer: function loadCheckBuffer(check_buffer) {\n        check.array = check_buffer;\n        return this;\n      },\n      size: function size() {\n        return Math.max(base.array.length, check.array.length);\n      },\n      getBase: function getBase(index) {\n        if (base.array.length - 1 < index) {\n          return -index + 1; // realloc(index);\n        } // if (!Number.isFinite(base.array[index])) {\n        //     console.log('getBase:' + index);\n        //     throw 'getBase' + index;\n        // }\n\n\n        return base.array[index];\n      },\n      getCheck: function getCheck(index) {\n        if (check.array.length - 1 < index) {\n          return -index - 1; // realloc(index);\n        } // if (!Number.isFinite(check.array[index])) {\n        //     console.log('getCheck:' + index);\n        //     throw 'getCheck' + index;\n        // }\n\n\n        return check.array[index];\n      },\n      setBase: function setBase(index, base_value) {\n        if (base.array.length - 1 < index) {\n          realloc(index);\n        }\n\n        base.array[index] = base_value;\n      },\n      setCheck: function setCheck(index, check_value) {\n        if (check.array.length - 1 < index) {\n          realloc(index);\n        }\n\n        check.array[index] = check_value;\n      },\n      setFirstUnusedNode: function setFirstUnusedNode(index) {\n        // if (!Number.isFinite(index)) {\n        //     throw 'assertion error: setFirstUnusedNode ' + index + ' is not finite number';\n        // }\n        first_unused_node = index;\n      },\n      getFirstUnusedNode: function getFirstUnusedNode() {\n        // if (!Number.isFinite(first_unused_node)) {\n        //     throw 'assertion error: getFirstUnusedNode ' + first_unused_node + ' is not finite number';\n        // }\n        return first_unused_node;\n      },\n      shrink: function shrink() {\n        var last_index = this.size() - 1;\n\n        while (true) {\n          if (0 <= check.array[last_index]) {\n            break;\n          }\n\n          last_index--;\n        }\n\n        base.array = base.array.subarray(0, last_index + 2); // keep last unused node\n\n        check.array = check.array.subarray(0, last_index + 2); // keep last unused node\n      },\n      calc: function calc() {\n        var unused_count = 0;\n        var size = check.array.length;\n\n        for (var i = 0; i < size; i++) {\n          if (check.array[i] < 0) {\n            unused_count++;\n          }\n        }\n\n        return {\n          all: size,\n          unused: unused_count,\n          efficiency: (size - unused_count) / size\n        };\n      },\n      dump: function dump() {\n        // for debug\n        var dump_base = \"\";\n        var dump_check = \"\";\n        var i;\n\n        for (i = 0; i < base.array.length; i++) {\n          dump_base = dump_base + \" \" + this.getBase(i);\n        }\n\n        for (i = 0; i < check.array.length; i++) {\n          dump_check = dump_check + \" \" + this.getCheck(i);\n        }\n\n        console.log(\"base:\" + dump_base);\n        console.log(\"chck:\" + dump_check);\n        return \"base:\" + dump_base + \" chck:\" + dump_check;\n      }\n    };\n  };\n  /**\n   * Factory method of double array\n   */\n\n\n  function DoubleArrayBuilder(initial_size) {\n    this.bc = newBC(initial_size); // BASE and CHECK\n\n    this.keys = [];\n  }\n  /**\n   * Append a key to initialize set\n   * (This method should be called by dictionary ordered key)\n   *\n   * @param {String} key\n   * @param {Number} value Integer value from 0 to max signed integer number - 1\n   */\n\n\n  DoubleArrayBuilder.prototype.append = function (key, record) {\n    this.keys.push({\n      k: key,\n      v: record\n    });\n    return this;\n  };\n  /**\n   * Build double array for given keys\n   *\n   * @param {Array} keys Array of keys. A key is a Object which has properties 'k', 'v'.\n   * 'k' is a key string, 'v' is a record assigned to that key.\n   * @return {DoubleArray} Compiled double array\n   */\n\n\n  DoubleArrayBuilder.prototype.build = function (keys, sorted) {\n    if (keys == null) {\n      keys = this.keys;\n    }\n\n    if (keys == null) {\n      return new DoubleArray(this.bc);\n    }\n\n    if (sorted == null) {\n      sorted = false;\n    } // Convert key string to ArrayBuffer\n\n\n    var buff_keys = keys.map(function (k) {\n      return {\n        k: stringToUtf8Bytes(k.k + TERM_CHAR),\n        v: k.v\n      };\n    }); // Sort keys by byte order\n\n    if (sorted) {\n      this.keys = buff_keys;\n    } else {\n      this.keys = buff_keys.sort(function (k1, k2) {\n        var b1 = k1.k;\n        var b2 = k2.k;\n        var min_length = Math.min(b1.length, b2.length);\n\n        for (var pos = 0; pos < min_length; pos++) {\n          if (b1[pos] === b2[pos]) {\n            continue;\n          }\n\n          return b1[pos] - b2[pos];\n        }\n\n        return b1.length - b2.length;\n      });\n    }\n\n    buff_keys = null; // explicit GC\n\n    this._build(ROOT_ID, 0, 0, this.keys.length);\n\n    return new DoubleArray(this.bc);\n  };\n  /**\n   * Append nodes to BASE and CHECK array recursively\n   */\n\n\n  DoubleArrayBuilder.prototype._build = function (parent_index, position, start, length) {\n    var children_info = this.getChildrenInfo(position, start, length);\n\n    var _base = this.findAllocatableBase(children_info);\n\n    this.setBC(parent_index, children_info, _base);\n\n    for (var i = 0; i < children_info.length; i = i + 3) {\n      var child_code = children_info[i];\n\n      if (child_code === TERM_CODE) {\n        continue;\n      }\n\n      var child_start = children_info[i + 1];\n      var child_len = children_info[i + 2];\n      var child_index = _base + child_code;\n\n      this._build(child_index, position + 1, child_start, child_len);\n    }\n  };\n\n  DoubleArrayBuilder.prototype.getChildrenInfo = function (position, start, length) {\n    var current_char = this.keys[start].k[position];\n    var i = 0;\n    var children_info = new Int32Array(length * 3);\n    children_info[i++] = current_char; // char (current)\n\n    children_info[i++] = start; // start index (current)\n\n    var next_pos = start;\n    var start_pos = start;\n\n    for (; next_pos < start + length; next_pos++) {\n      var next_char = this.keys[next_pos].k[position];\n\n      if (current_char !== next_char) {\n        children_info[i++] = next_pos - start_pos; // length (current)\n\n        children_info[i++] = next_char; // char (next)\n\n        children_info[i++] = next_pos; // start index (next)\n\n        current_char = next_char;\n        start_pos = next_pos;\n      }\n    }\n\n    children_info[i++] = next_pos - start_pos;\n    children_info = children_info.subarray(0, i);\n    return children_info;\n  };\n\n  DoubleArrayBuilder.prototype.setBC = function (parent_id, children_info, _base) {\n    var bc = this.bc;\n    bc.setBase(parent_id, _base); // Update BASE of parent node\n\n    var i;\n\n    for (i = 0; i < children_info.length; i = i + 3) {\n      var code = children_info[i];\n      var child_id = _base + code; // Update linked list of unused nodes\n      // Assertion\n      // if (child_id < 0) {\n      //     throw 'assertion error: child_id is negative'\n      // }\n\n      var prev_unused_id = -bc.getBase(child_id);\n      var next_unused_id = -bc.getCheck(child_id); // if (prev_unused_id < 0) {\n      //     throw 'assertion error: setBC'\n      // }\n      // if (next_unused_id < 0) {\n      //     throw 'assertion error: setBC'\n      // }\n\n      if (child_id !== bc.getFirstUnusedNode()) {\n        bc.setCheck(prev_unused_id, -next_unused_id);\n      } else {\n        // Update first_unused_node\n        bc.setFirstUnusedNode(next_unused_id);\n      }\n\n      bc.setBase(next_unused_id, -prev_unused_id);\n      var check = parent_id; // CHECK is parent node index\n\n      bc.setCheck(child_id, check); // Update CHECK of child node\n      // Update record\n\n      if (code === TERM_CODE) {\n        var start_pos = children_info[i + 1]; // var len = children_info[i + 2];\n        // if (len != 1) {\n        //     throw 'assertion error: there are multiple terminal nodes. len:' + len;\n        // }\n\n        var value = this.keys[start_pos].v;\n\n        if (value == null) {\n          value = 0;\n        }\n\n        var base = -value - 1; // BASE is inverted record value\n\n        bc.setBase(child_id, base); // Update BASE of child(leaf) node\n      }\n    }\n  };\n  /**\n   * Find BASE value that all children are allocatable in double array's region\n   */\n\n\n  DoubleArrayBuilder.prototype.findAllocatableBase = function (children_info) {\n    var bc = this.bc; // Assertion: keys are sorted by byte order\n    // var c = -1;\n    // for (var i = 0; i < children_info.length; i = i + 3) {\n    //     if (children_info[i] < c) {\n    //         throw 'assertion error: not sort key'\n    //     }\n    //     c = children_info[i];\n    // }\n    // iterate linked list of unused nodes\n\n    var _base;\n\n    var curr = bc.getFirstUnusedNode(); // current index\n    // if (curr < 0) {\n    //     throw 'assertion error: getFirstUnusedNode returns negative value'\n    // }\n\n    while (true) {\n      _base = curr - children_info[0];\n\n      if (_base < 0) {\n        curr = -bc.getCheck(curr); // next\n        // if (curr < 0) {\n        //     throw 'assertion error: getCheck returns negative value'\n        // }\n\n        continue;\n      }\n\n      var empty_area_found = true;\n\n      for (var i = 0; i < children_info.length; i = i + 3) {\n        var code = children_info[i];\n        var candidate_id = _base + code;\n\n        if (!this.isUnusedNode(candidate_id)) {\n          // candidate_id is used node\n          // next\n          curr = -bc.getCheck(curr); // if (curr < 0) {\n          //     throw 'assertion error: getCheck returns negative value'\n          // }\n\n          empty_area_found = false;\n          break;\n        }\n      }\n\n      if (empty_area_found) {\n        // Area is free\n        return _base;\n      }\n    }\n  };\n  /**\n   * Check this double array index is unused or not\n   */\n\n\n  DoubleArrayBuilder.prototype.isUnusedNode = function (index) {\n    var bc = this.bc;\n    var check = bc.getCheck(index); // if (index < 0) {\n    //     throw 'assertion error: isUnusedNode index:' + index;\n    // }\n\n    if (index === ROOT_ID) {\n      // root node\n      return false;\n    }\n\n    if (check < 0) {\n      // unused\n      return true;\n    } // used node (incl. leaf)\n\n\n    return false;\n  };\n  /**\n   * Factory method of double array\n   */\n\n\n  function DoubleArray(bc) {\n    this.bc = bc; // BASE and CHECK\n\n    this.bc.shrink();\n  }\n  /**\n   * Look up a given key in this trie\n   *\n   * @param {String} key\n   * @return {Boolean} True if this trie contains a given key\n   */\n\n\n  DoubleArray.prototype.contain = function (key) {\n    var bc = this.bc;\n    key += TERM_CHAR;\n    var buffer = stringToUtf8Bytes(key);\n    var parent = ROOT_ID;\n    var child = NOT_FOUND;\n\n    for (var i = 0; i < buffer.length; i++) {\n      var code = buffer[i];\n      child = this.traverse(parent, code);\n\n      if (child === NOT_FOUND) {\n        return false;\n      }\n\n      if (bc.getBase(child) <= 0) {\n        // leaf node\n        return true;\n      } else {\n        // not leaf\n        parent = child;\n        continue;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Look up a given key in this trie\n   *\n   * @param {String} key\n   * @return {Number} Record value assgned to this key, -1 if this key does not contain\n   */\n\n\n  DoubleArray.prototype.lookup = function (key) {\n    key += TERM_CHAR;\n    var buffer = stringToUtf8Bytes(key);\n    var parent = ROOT_ID;\n    var child = NOT_FOUND;\n\n    for (var i = 0; i < buffer.length; i++) {\n      var code = buffer[i];\n      child = this.traverse(parent, code);\n\n      if (child === NOT_FOUND) {\n        return NOT_FOUND;\n      }\n\n      parent = child;\n    }\n\n    var base = this.bc.getBase(child);\n\n    if (base <= 0) {\n      // leaf node\n      return -base - 1;\n    } else {\n      // not leaf\n      return NOT_FOUND;\n    }\n  };\n  /**\n   * Common prefix search\n   *\n   * @param {String} key\n   * @return {Array} Each result object has 'k' and 'v' (key and record,\n   * respectively) properties assigned to matched string\n   */\n\n\n  DoubleArray.prototype.commonPrefixSearch = function (key) {\n    var buffer = stringToUtf8Bytes(key);\n    var parent = ROOT_ID;\n    var child = NOT_FOUND;\n    var result = [];\n\n    for (var i = 0; i < buffer.length; i++) {\n      var code = buffer[i];\n      child = this.traverse(parent, code);\n\n      if (child !== NOT_FOUND) {\n        parent = child; // look forward by terminal character code to check this node is a leaf or not\n\n        var grand_child = this.traverse(child, TERM_CODE);\n\n        if (grand_child !== NOT_FOUND) {\n          var base = this.bc.getBase(grand_child);\n          var r = {};\n\n          if (base <= 0) {\n            // If child is a leaf node, add record to result\n            r.v = -base - 1;\n          } // If child is a leaf node, add word to result\n\n\n          r.k = utf8BytesToString(arrayCopy(buffer, 0, i + 1));\n          result.push(r);\n        }\n\n        continue;\n      } else {\n        break;\n      }\n    }\n\n    return result;\n  };\n\n  DoubleArray.prototype.traverse = function (parent, code) {\n    var child = this.bc.getBase(parent) + code;\n\n    if (this.bc.getCheck(child) === parent) {\n      return child;\n    } else {\n      return NOT_FOUND;\n    }\n  };\n\n  DoubleArray.prototype.size = function () {\n    return this.bc.size();\n  };\n\n  DoubleArray.prototype.calc = function () {\n    return this.bc.calc();\n  };\n\n  DoubleArray.prototype.dump = function () {\n    return this.bc.dump();\n  }; // Array utility functions\n\n\n  var newArrayBuffer = function newArrayBuffer(signed, bytes, size) {\n    if (signed) {\n      switch (bytes) {\n        case 1:\n          return new Int8Array(size);\n\n        case 2:\n          return new Int16Array(size);\n\n        case 4:\n          return new Int32Array(size);\n\n        default:\n          throw new RangeError(\"Invalid newArray parameter element_bytes:\" + bytes);\n      }\n    } else {\n      switch (bytes) {\n        case 1:\n          return new Uint8Array(size);\n\n        case 2:\n          return new Uint16Array(size);\n\n        case 4:\n          return new Uint32Array(size);\n\n        default:\n          throw new RangeError(\"Invalid newArray parameter element_bytes:\" + bytes);\n      }\n    }\n  };\n\n  var arrayCopy = function arrayCopy(src, src_offset, length) {\n    var buffer = new ArrayBuffer(length);\n    var dstU8 = new Uint8Array(buffer, 0, length);\n    var srcU8 = src.subarray(src_offset, length);\n    dstU8.set(srcU8);\n    return dstU8;\n  };\n  /**\n   * Convert String (UTF-16) to UTF-8 ArrayBuffer\n   *\n   * @param {String} str UTF-16 string to convert\n   * @return {Uint8Array} Byte sequence encoded by UTF-8\n   */\n\n\n  var stringToUtf8Bytes = function stringToUtf8Bytes(str) {\n    // Max size of 1 character is 4 bytes\n    var bytes = new Uint8Array(new ArrayBuffer(str.length * 4));\n    var i = 0,\n        j = 0;\n\n    while (i < str.length) {\n      var unicode_code;\n      var utf16_code = str.charCodeAt(i++);\n\n      if (utf16_code >= 0xD800 && utf16_code <= 0xDBFF) {\n        // surrogate pair\n        var upper = utf16_code; // high surrogate\n\n        var lower = str.charCodeAt(i++); // low surrogate\n\n        if (lower >= 0xDC00 && lower <= 0xDFFF) {\n          unicode_code = (upper - 0xD800) * (1 << 10) + (1 << 16) + (lower - 0xDC00);\n        } else {\n          // malformed surrogate pair\n          return null;\n        }\n      } else {\n        // not surrogate code\n        unicode_code = utf16_code;\n      }\n\n      if (unicode_code < 0x80) {\n        // 1-byte\n        bytes[j++] = unicode_code;\n      } else if (unicode_code < 1 << 11) {\n        // 2-byte\n        bytes[j++] = unicode_code >>> 6 | 0xC0;\n        bytes[j++] = unicode_code & 0x3F | 0x80;\n      } else if (unicode_code < 1 << 16) {\n        // 3-byte\n        bytes[j++] = unicode_code >>> 12 | 0xE0;\n        bytes[j++] = unicode_code >> 6 & 0x3f | 0x80;\n        bytes[j++] = unicode_code & 0x3F | 0x80;\n      } else if (unicode_code < 1 << 21) {\n        // 4-byte\n        bytes[j++] = unicode_code >>> 18 | 0xF0;\n        bytes[j++] = unicode_code >> 12 & 0x3F | 0x80;\n        bytes[j++] = unicode_code >> 6 & 0x3F | 0x80;\n        bytes[j++] = unicode_code & 0x3F | 0x80;\n      } else {// malformed UCS4 code\n      }\n    }\n\n    return bytes.subarray(0, j);\n  };\n  /**\n   * Convert UTF-8 ArrayBuffer to String (UTF-16)\n   *\n   * @param {Uint8Array} bytes UTF-8 byte sequence to convert\n   * @return {String} String encoded by UTF-16\n   */\n\n\n  var utf8BytesToString = function utf8BytesToString(bytes) {\n    var str = \"\";\n    var code, b1, b2, b3, b4, upper, lower;\n    var i = 0;\n\n    while (i < bytes.length) {\n      b1 = bytes[i++];\n\n      if (b1 < 0x80) {\n        // 1 byte\n        code = b1;\n      } else if (b1 >> 5 === 0x06) {\n        // 2 bytes\n        b2 = bytes[i++];\n        code = (b1 & 0x1f) << 6 | b2 & 0x3f;\n      } else if (b1 >> 4 === 0x0e) {\n        // 3 bytes\n        b2 = bytes[i++];\n        b3 = bytes[i++];\n        code = (b1 & 0x0f) << 12 | (b2 & 0x3f) << 6 | b3 & 0x3f;\n      } else {\n        // 4 bytes\n        b2 = bytes[i++];\n        b3 = bytes[i++];\n        b4 = bytes[i++];\n        code = (b1 & 0x07) << 18 | (b2 & 0x3f) << 12 | (b3 & 0x3f) << 6 | b4 & 0x3f;\n      }\n\n      if (code < 0x10000) {\n        str += String.fromCharCode(code);\n      } else {\n        // surrogate pair\n        code -= 0x10000;\n        upper = 0xD800 | code >> 10;\n        lower = 0xDC00 | code & 0x3FF;\n        str += String.fromCharCode(upper, lower);\n      }\n    }\n\n    return str;\n  }; // public methods\n\n\n  var doublearray = {\n    builder: function builder(initial_size) {\n      return new DoubleArrayBuilder(initial_size);\n    },\n    load: function load(base_buffer, check_buffer) {\n      var bc = newBC(0);\n      bc.loadBaseBuffer(base_buffer);\n      bc.loadCheckBuffer(check_buffer);\n      return new DoubleArray(bc);\n    }\n  };\n\n  if (\"undefined\" === typeof module) {\n    // In browser\n    window.doublearray = doublearray;\n  } else {\n    // In node\n    module.exports = doublearray;\n  }\n})();","map":{"version":3,"sources":["/home/byungchan/Projects/JapaneseQuiz/node_modules/doublearray/doublearray.js"],"names":["TERM_CHAR","TERM_CODE","ROOT_ID","NOT_FOUND","BASE_SIGNED","CHECK_SIGNED","BASE_BYTES","CHECK_BYTES","MEMORY_EXPAND_RATIO","newBC","initial_size","initBase","_base","start","end","i","check","array","length","last_used_id","initCheck","_check","realloc","min_size","new_size","base_new_array","newArrayBuffer","base","signed","bytes","set","check_new_array","first_unused_node","getBaseBuffer","getCheckBuffer","loadBaseBuffer","base_buffer","loadCheckBuffer","check_buffer","size","Math","max","getBase","index","getCheck","setBase","base_value","setCheck","check_value","setFirstUnusedNode","getFirstUnusedNode","shrink","last_index","subarray","calc","unused_count","all","unused","efficiency","dump","dump_base","dump_check","console","log","DoubleArrayBuilder","bc","keys","prototype","append","key","record","push","k","v","build","sorted","DoubleArray","buff_keys","map","stringToUtf8Bytes","sort","k1","k2","b1","b2","min_length","min","pos","_build","parent_index","position","children_info","getChildrenInfo","findAllocatableBase","setBC","child_code","child_start","child_len","child_index","current_char","Int32Array","next_pos","start_pos","next_char","parent_id","code","child_id","prev_unused_id","next_unused_id","value","curr","empty_area_found","candidate_id","isUnusedNode","contain","buffer","parent","child","traverse","lookup","commonPrefixSearch","result","grand_child","r","utf8BytesToString","arrayCopy","Int8Array","Int16Array","RangeError","Uint8Array","Uint16Array","Uint32Array","src","src_offset","ArrayBuffer","dstU8","srcU8","str","j","unicode_code","utf16_code","charCodeAt","upper","lower","b3","b4","String","fromCharCode","doublearray","builder","load","module","window","exports"],"mappings":"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","sourcesContent":["// Copyright (c) 2014 Takuya Asano All Rights Reserved.\n\n(function () {\n\n    \"use strict\";\n\n    var TERM_CHAR = \"\\u0000\", // terminal character\n        TERM_CODE = 0,        // terminal character code\n        ROOT_ID = 0,          // index of root node\n        NOT_FOUND = -1,       // traverse() returns if no nodes found\n        BASE_SIGNED = true,\n        CHECK_SIGNED = true,\n        BASE_BYTES = 4,\n        CHECK_BYTES = 4,\n        MEMORY_EXPAND_RATIO = 2;\n\n\n    var newBC = function (initial_size) {\n\n        if (initial_size == null) {\n            initial_size = 1024;\n        }\n\n        var initBase = function (_base, start, end) {  // 'end' index does not include\n            for (var i = start; i < end; i++) {\n                _base[i] = - i + 1;  // inversed previous empty node index\n            }\n            if (0 < check.array[check.array.length - 1]) {\n                var last_used_id = check.array.length - 2;\n                while (0 < check.array[last_used_id]) {\n                    last_used_id--;\n                }\n                _base[start] = - last_used_id;\n            }\n        };\n\n        var initCheck = function (_check, start, end) {\n            for (var i = start; i < end; i++) {\n                _check[i] = - i - 1;  // inversed next empty node index\n            }\n        };\n\n        var realloc = function (min_size) {\n            // expand arrays size by given ratio\n            var new_size = min_size * MEMORY_EXPAND_RATIO;\n            // console.log('re-allocate memory to ' + new_size);\n\n            var base_new_array = newArrayBuffer(base.signed, base.bytes, new_size);\n            initBase(base_new_array, base.array.length, new_size);  // init BASE in new range\n            base_new_array.set(base.array);\n            base.array = null;  // explicit GC\n            base.array = base_new_array;\n\n            var check_new_array = newArrayBuffer(check.signed, check.bytes, new_size);\n            initCheck(check_new_array, check.array.length, new_size);  // init CHECK in new range\n            check_new_array.set(check.array);\n            check.array = null;  // explicit GC\n            check.array = check_new_array;\n        };\n\n        var first_unused_node = ROOT_ID + 1;\n\n        var base = {\n            signed: BASE_SIGNED,\n            bytes: BASE_BYTES,\n            array: newArrayBuffer(BASE_SIGNED, BASE_BYTES, initial_size)\n        };\n\n        var check = {\n            signed: CHECK_SIGNED,\n            bytes: CHECK_BYTES,\n            array: newArrayBuffer(CHECK_SIGNED, CHECK_BYTES, initial_size)\n        };\n\n        // init root node\n        base.array[ROOT_ID] = 1;\n        check.array[ROOT_ID] = ROOT_ID;\n\n        // init BASE\n        initBase(base.array, ROOT_ID + 1, base.array.length);\n\n        // init CHECK\n        initCheck(check.array, ROOT_ID + 1, check.array.length);\n\n        return {\n            getBaseBuffer: function () {\n                return base.array;\n            },\n            getCheckBuffer: function () {\n                return check.array;\n            },\n            loadBaseBuffer: function (base_buffer) {\n                base.array = base_buffer;\n                return this;\n            },\n            loadCheckBuffer: function (check_buffer) {\n                check.array = check_buffer;\n                return this;\n            },\n            size: function () {\n                return Math.max(base.array.length, check.array.length);\n            },\n            getBase: function (index) {\n                if (base.array.length - 1 < index) {\n                    return - index + 1;\n                    // realloc(index);\n                }\n                // if (!Number.isFinite(base.array[index])) {\n                //     console.log('getBase:' + index);\n                //     throw 'getBase' + index;\n                // }\n                return base.array[index];\n            },\n            getCheck: function (index) {\n                if (check.array.length - 1 < index) {\n                    return - index - 1;\n                    // realloc(index);\n                }\n                // if (!Number.isFinite(check.array[index])) {\n                //     console.log('getCheck:' + index);\n                //     throw 'getCheck' + index;\n                // }\n                return check.array[index];\n            },\n            setBase: function (index, base_value) {\n                if (base.array.length - 1 < index) {\n                    realloc(index);\n                }\n                base.array[index] = base_value;\n            },\n            setCheck: function (index, check_value) {\n                if (check.array.length - 1 < index) {\n                    realloc(index);\n                }\n                check.array[index] = check_value;\n            },\n            setFirstUnusedNode: function (index) {\n                // if (!Number.isFinite(index)) {\n                //     throw 'assertion error: setFirstUnusedNode ' + index + ' is not finite number';\n                // }\n                first_unused_node = index;\n            },\n            getFirstUnusedNode: function () {\n                // if (!Number.isFinite(first_unused_node)) {\n                //     throw 'assertion error: getFirstUnusedNode ' + first_unused_node + ' is not finite number';\n                // }\n                return first_unused_node;\n            },\n            shrink: function () {\n                var last_index = this.size() - 1;\n                while (true) {\n                    if (0 <= check.array[last_index]) {\n                        break;\n                    }\n                    last_index--;\n                }\n                base.array = base.array.subarray(0, last_index + 2);   // keep last unused node\n                check.array = check.array.subarray(0, last_index + 2); // keep last unused node\n            },\n            calc: function () {\n                var unused_count = 0;\n                var size = check.array.length;\n                for (var i = 0; i < size; i++) {\n                    if (check.array[i] < 0) {\n                        unused_count++;\n                    }\n                }\n                return {\n                    all: size,\n                    unused: unused_count,\n                    efficiency: (size - unused_count) / size\n                };\n            },\n            dump: function () {\n                // for debug\n                var dump_base = \"\";\n                var dump_check = \"\";\n\n                var i;\n                for (i = 0; i < base.array.length; i++) {\n                    dump_base = dump_base + \" \" + this.getBase(i);\n                }\n                for (i = 0; i < check.array.length; i++) {\n                    dump_check = dump_check + \" \" + this.getCheck(i);\n                }\n\n                console.log(\"base:\" + dump_base);\n                console.log(\"chck:\" + dump_check);\n\n                return \"base:\" + dump_base + \" chck:\" + dump_check;\n            }\n        };\n    };\n\n\n    /**\n     * Factory method of double array\n     */\n    function DoubleArrayBuilder(initial_size) {\n        this.bc = newBC(initial_size);  // BASE and CHECK\n        this.keys = [];\n    }\n\n\n    /**\n     * Append a key to initialize set\n     * (This method should be called by dictionary ordered key)\n     *\n     * @param {String} key\n     * @param {Number} value Integer value from 0 to max signed integer number - 1\n     */\n    DoubleArrayBuilder.prototype.append = function (key, record) {\n        this.keys.push({ k: key, v: record });\n        return this;\n    };\n\n    /**\n     * Build double array for given keys\n     *\n     * @param {Array} keys Array of keys. A key is a Object which has properties 'k', 'v'.\n     * 'k' is a key string, 'v' is a record assigned to that key.\n     * @return {DoubleArray} Compiled double array\n     */\n    DoubleArrayBuilder.prototype.build = function (keys, sorted) {\n\n        if (keys == null) {\n            keys = this.keys;\n        }\n\n        if (keys == null) {\n            return new DoubleArray(this.bc);\n        }\n\n        if (sorted == null) {\n            sorted = false;\n        }\n\n        // Convert key string to ArrayBuffer\n        var buff_keys =\n            keys.map(function (k) {\n                return {\n                    k: stringToUtf8Bytes(k.k + TERM_CHAR),\n                    v: k.v\n                };\n            });\n\n        // Sort keys by byte order\n        if (sorted) {\n            this.keys = buff_keys;\n        } else {\n            this.keys =\n                buff_keys.sort(function (k1, k2) {\n                    var b1 = k1.k;\n                    var b2 = k2.k;\n                    var min_length = Math.min(b1.length, b2.length);\n                    for (var pos = 0; pos < min_length; pos++) {\n                        if (b1[pos] === b2[pos]) {\n                            continue;\n                        }\n                        return b1[pos] - b2[pos];\n                    }\n                    return b1.length - b2.length;\n                });\n        }\n\n        buff_keys = null;  // explicit GC\n\n        this._build(ROOT_ID, 0, 0, this.keys.length);\n        return new DoubleArray(this.bc);\n    };\n\n    /**\n     * Append nodes to BASE and CHECK array recursively\n     */\n    DoubleArrayBuilder.prototype._build = function (parent_index, position, start, length) {\n\n        var children_info = this.getChildrenInfo(position, start, length);\n        var _base = this.findAllocatableBase(children_info);\n\n        this.setBC(parent_index, children_info, _base);\n\n        for (var i = 0; i < children_info.length; i = i + 3) {\n            var child_code = children_info[i];\n            if (child_code === TERM_CODE) {\n                continue;\n            }\n            var child_start = children_info[i + 1];\n            var child_len = children_info[i + 2];\n            var child_index = _base + child_code;\n            this._build(child_index, position + 1, child_start, child_len);\n        }\n    };\n\n    DoubleArrayBuilder.prototype.getChildrenInfo = function (position, start, length) {\n        var current_char = this.keys[start].k[position];\n        var i = 0;\n        var children_info = new Int32Array(length * 3);\n\n        children_info[i++] = current_char;  // char (current)\n        children_info[i++] = start;         // start index (current)\n\n        var next_pos = start;\n        var start_pos = start;\n        for (; next_pos < start + length; next_pos++) {\n            var next_char = this.keys[next_pos].k[position];\n            if (current_char !== next_char) {\n                children_info[i++] = next_pos - start_pos;  // length (current)\n\n                children_info[i++] = next_char;             // char (next)\n                children_info[i++] = next_pos;              // start index (next)\n                current_char = next_char;\n                start_pos = next_pos;\n            }\n        }\n        children_info[i++] = next_pos - start_pos;\n        children_info = children_info.subarray(0, i);\n\n        return children_info;\n    };\n\n    DoubleArrayBuilder.prototype.setBC = function (parent_id, children_info, _base) {\n\n        var bc = this.bc;\n\n        bc.setBase(parent_id, _base);  // Update BASE of parent node\n\n        var i;\n        for (i = 0; i < children_info.length; i = i + 3) {\n            var code = children_info[i];\n            var child_id = _base + code;\n\n            // Update linked list of unused nodes\n\n            // Assertion\n            // if (child_id < 0) {\n            //     throw 'assertion error: child_id is negative'\n            // }\n\n            var prev_unused_id = - bc.getBase(child_id);\n            var next_unused_id = - bc.getCheck(child_id);\n            // if (prev_unused_id < 0) {\n            //     throw 'assertion error: setBC'\n            // }\n            // if (next_unused_id < 0) {\n            //     throw 'assertion error: setBC'\n            // }\n            if (child_id !== bc.getFirstUnusedNode()) {\n                bc.setCheck(prev_unused_id, - next_unused_id);\n            } else {\n                // Update first_unused_node\n                bc.setFirstUnusedNode(next_unused_id);\n            }\n            bc.setBase(next_unused_id, - prev_unused_id);\n\n            var check = parent_id;         // CHECK is parent node index\n            bc.setCheck(child_id, check);  // Update CHECK of child node\n\n            // Update record\n            if (code === TERM_CODE) {\n                var start_pos = children_info[i + 1];\n                // var len = children_info[i + 2];\n                // if (len != 1) {\n                //     throw 'assertion error: there are multiple terminal nodes. len:' + len;\n                // }\n                var value = this.keys[start_pos].v;\n\n                if (value == null) {\n                    value = 0;\n                }\n\n                var base = - value - 1;       // BASE is inverted record value\n                bc.setBase(child_id, base);  // Update BASE of child(leaf) node\n            }\n        }\n    };\n\n\n    /**\n     * Find BASE value that all children are allocatable in double array's region\n     */\n    DoubleArrayBuilder.prototype.findAllocatableBase = function (children_info) {\n\n        var bc = this.bc;\n\n        // Assertion: keys are sorted by byte order\n        // var c = -1;\n        // for (var i = 0; i < children_info.length; i = i + 3) {\n        //     if (children_info[i] < c) {\n        //         throw 'assertion error: not sort key'\n        //     }\n        //     c = children_info[i];\n        // }\n\n        // iterate linked list of unused nodes\n        var _base;\n        var curr = bc.getFirstUnusedNode();  // current index\n        // if (curr < 0) {\n        //     throw 'assertion error: getFirstUnusedNode returns negative value'\n        // }\n\n        while (true) {\n            _base = curr - children_info[0];\n\n            if (_base < 0) {\n                curr = - bc.getCheck(curr);  // next\n\n                // if (curr < 0) {\n                //     throw 'assertion error: getCheck returns negative value'\n                // }\n\n                continue;\n            }\n\n            var empty_area_found = true;\n            for (var i = 0; i < children_info.length; i = i + 3) {\n                var code = children_info[i];\n                var candidate_id = _base + code;\n\n                if (!this.isUnusedNode(candidate_id)) {\n                    // candidate_id is used node\n                    // next\n                    curr = - bc.getCheck(curr);\n                    // if (curr < 0) {\n                    //     throw 'assertion error: getCheck returns negative value'\n                    // }\n\n                    empty_area_found = false;\n                    break;\n                }\n            }\n            if (empty_area_found) {\n                // Area is free\n                return _base;\n            }\n        }\n    };\n\n    /**\n     * Check this double array index is unused or not\n     */\n    DoubleArrayBuilder.prototype.isUnusedNode = function (index) {\n        var bc = this.bc;\n        var check = bc.getCheck(index);\n\n        // if (index < 0) {\n        //     throw 'assertion error: isUnusedNode index:' + index;\n        // }\n\n        if (index === ROOT_ID) {\n            // root node\n            return false;\n        }\n        if (check < 0) {\n            // unused\n            return true;\n        }\n\n        // used node (incl. leaf)\n        return false;\n    };\n\n\n    /**\n     * Factory method of double array\n     */\n    function DoubleArray(bc) {\n        this.bc = bc;       // BASE and CHECK\n        this.bc.shrink();\n    }\n\n\n    /**\n     * Look up a given key in this trie\n     *\n     * @param {String} key\n     * @return {Boolean} True if this trie contains a given key\n     */\n    DoubleArray.prototype.contain = function (key) {\n\n        var bc = this.bc;\n\n        key += TERM_CHAR;\n        var buffer = stringToUtf8Bytes(key);\n\n        var parent = ROOT_ID;\n        var child = NOT_FOUND;\n\n        for (var i = 0; i < buffer.length; i++) {\n            var code = buffer[i];\n\n            child = this.traverse(parent, code);\n            if (child === NOT_FOUND) {\n                return false;\n            }\n\n            if (bc.getBase(child) <= 0) {\n                // leaf node\n                return true;\n            } else {\n                // not leaf\n                parent = child;\n                continue;\n            }\n        }\n        return false;\n    };\n\n\n    /**\n     * Look up a given key in this trie\n     *\n     * @param {String} key\n     * @return {Number} Record value assgned to this key, -1 if this key does not contain\n     */\n    DoubleArray.prototype.lookup = function (key) {\n\n        key += TERM_CHAR;\n        var buffer = stringToUtf8Bytes(key);\n\n        var parent = ROOT_ID;\n        var child = NOT_FOUND;\n\n        for (var i = 0; i < buffer.length; i++) {\n            var code = buffer[i];\n            child = this.traverse(parent, code);\n            if (child === NOT_FOUND) {\n                return NOT_FOUND;\n            }\n            parent = child;\n        }\n\n        var base = this.bc.getBase(child);\n        if (base <= 0) {\n            // leaf node\n            return - base - 1;\n        } else {\n            // not leaf\n            return NOT_FOUND;\n        }\n    };\n\n\n    /**\n     * Common prefix search\n     *\n     * @param {String} key\n     * @return {Array} Each result object has 'k' and 'v' (key and record,\n     * respectively) properties assigned to matched string\n     */\n    DoubleArray.prototype.commonPrefixSearch = function (key) {\n\n        var buffer = stringToUtf8Bytes(key);\n\n        var parent = ROOT_ID;\n        var child = NOT_FOUND;\n\n        var result = [];\n\n        for (var i = 0; i < buffer.length; i++) {\n            var code = buffer[i];\n\n            child = this.traverse(parent, code);\n\n            if (child !== NOT_FOUND) {\n                parent = child;\n\n                // look forward by terminal character code to check this node is a leaf or not\n                var grand_child = this.traverse(child, TERM_CODE);\n\n                if (grand_child !== NOT_FOUND) {\n                    var base = this.bc.getBase(grand_child);\n\n                    var r = {};\n\n                    if (base <= 0) {\n                        // If child is a leaf node, add record to result\n                        r.v = - base - 1;\n                    }\n\n                    // If child is a leaf node, add word to result\n                    r.k = utf8BytesToString(arrayCopy(buffer, 0, i + 1));\n\n                    result.push(r);\n                }\n                continue;\n            } else {\n                break;\n            }\n        }\n\n        return result;\n    };\n\n    DoubleArray.prototype.traverse = function (parent, code) {\n        var child = this.bc.getBase(parent) + code;\n        if (this.bc.getCheck(child) === parent) {\n            return child;\n        } else {\n            return NOT_FOUND;\n        }\n    };\n\n    DoubleArray.prototype.size = function () {\n        return this.bc.size();\n    };\n\n    DoubleArray.prototype.calc = function () {\n        return this.bc.calc();\n    };\n\n    DoubleArray.prototype.dump = function () {\n        return this.bc.dump();\n    };\n\n\n    // Array utility functions\n\n    var newArrayBuffer = function (signed, bytes, size) {\n        if (signed) {\n            switch(bytes) {\n                case 1:\n                return new Int8Array(size);\n                case 2:\n                return new Int16Array(size);\n                case 4:\n                return new Int32Array(size);\n                default:\n                throw new RangeError(\"Invalid newArray parameter element_bytes:\" + bytes);\n            }\n        } else {\n            switch(bytes) {\n                case 1:\n                return new Uint8Array(size);\n                case 2:\n                return new Uint16Array(size);\n                case 4:\n                return new Uint32Array(size);\n                default:\n                throw new RangeError(\"Invalid newArray parameter element_bytes:\" + bytes);\n            }\n        }\n    };\n\n    var arrayCopy = function (src, src_offset, length) {\n        var buffer = new ArrayBuffer(length);\n        var dstU8 = new Uint8Array(buffer, 0, length);\n        var srcU8 = src.subarray(src_offset, length);\n        dstU8.set(srcU8);\n        return dstU8;\n    };\n\n\n    /**\n     * Convert String (UTF-16) to UTF-8 ArrayBuffer\n     *\n     * @param {String} str UTF-16 string to convert\n     * @return {Uint8Array} Byte sequence encoded by UTF-8\n     */\n    var stringToUtf8Bytes = function (str) {\n\n        // Max size of 1 character is 4 bytes\n        var bytes = new Uint8Array(new ArrayBuffer(str.length * 4));\n\n        var i = 0, j = 0;\n\n        while (i < str.length) {\n            var unicode_code;\n\n            var utf16_code = str.charCodeAt(i++);\n            if (utf16_code >= 0xD800 && utf16_code <= 0xDBFF) {\n                // surrogate pair\n                var upper = utf16_code;           // high surrogate\n                var lower = str.charCodeAt(i++);  // low surrogate\n\n                if (lower >= 0xDC00 && lower <= 0xDFFF) {\n                    unicode_code =\n                        (upper - 0xD800) * (1 << 10) + (1 << 16) +\n                        (lower - 0xDC00);\n                } else {\n                    // malformed surrogate pair\n                    return null;\n                }\n            } else {\n                // not surrogate code\n                unicode_code = utf16_code;\n            }\n\n            if (unicode_code < 0x80) {\n                // 1-byte\n                bytes[j++] = unicode_code;\n\n            } else if (unicode_code < (1 << 11)) {\n                // 2-byte\n                bytes[j++] = (unicode_code >>> 6) | 0xC0;\n                bytes[j++] = (unicode_code & 0x3F) | 0x80;\n\n            } else if (unicode_code < (1 << 16)) {\n                // 3-byte\n                bytes[j++] = (unicode_code >>> 12) | 0xE0;\n                bytes[j++] = ((unicode_code >> 6) & 0x3f) | 0x80;\n                bytes[j++] = (unicode_code & 0x3F) | 0x80;\n\n            } else if (unicode_code < (1 << 21)) {\n                // 4-byte\n                bytes[j++] = (unicode_code >>> 18) | 0xF0;\n                bytes[j++] = ((unicode_code >> 12) & 0x3F) | 0x80;\n                bytes[j++] = ((unicode_code >> 6) & 0x3F) | 0x80;\n                bytes[j++] = (unicode_code & 0x3F) | 0x80;\n\n            } else {\n                // malformed UCS4 code\n            }\n        }\n\n        return bytes.subarray(0, j);\n    };\n\n\n    /**\n     * Convert UTF-8 ArrayBuffer to String (UTF-16)\n     *\n     * @param {Uint8Array} bytes UTF-8 byte sequence to convert\n     * @return {String} String encoded by UTF-16\n     */\n    var utf8BytesToString = function (bytes) {\n\n        var str = \"\";\n        var code, b1, b2, b3, b4, upper, lower;\n        var i = 0;\n\n        while (i < bytes.length) {\n\n            b1 = bytes[i++];\n\n            if (b1 < 0x80) {\n                // 1 byte\n                code = b1;\n            } else if ((b1 >> 5) === 0x06) {\n                // 2 bytes\n                b2 = bytes[i++];\n                code = ((b1 & 0x1f) << 6) | (b2 & 0x3f);\n            } else if ((b1 >> 4) === 0x0e) {\n                // 3 bytes\n                b2 = bytes[i++];\n                b3 = bytes[i++];\n                code = ((b1 & 0x0f) << 12) | ((b2 & 0x3f) << 6) | (b3 & 0x3f);\n            } else {\n                // 4 bytes\n                b2 = bytes[i++];\n                b3 = bytes[i++];\n                b4 = bytes[i++];\n                code = ((b1 & 0x07) << 18) | ((b2 & 0x3f) << 12) | ((b3 & 0x3f) << 6) | (b4 & 0x3f);\n            }\n\n            if (code < 0x10000) {\n\t            str += String.fromCharCode(code);\n            } else {\n\t            // surrogate pair\n\t            code -= 0x10000;\n\t            upper = (0xD800 | (code >> 10));\n\t            lower = (0xDC00 | (code & 0x3FF));\n\t            str += String.fromCharCode(upper, lower);\n            }\n        }\n\n        return str;\n    };\n\n\n    // public methods\n    var doublearray = {\n        builder: function (initial_size) {\n            return new DoubleArrayBuilder(initial_size);\n        },\n        load: function (base_buffer, check_buffer) {\n            var bc = newBC(0);\n            bc.loadBaseBuffer(base_buffer);\n            bc.loadCheckBuffer(check_buffer);\n            return new DoubleArray(bc);\n        }\n    };\n\n    if (\"undefined\" === typeof module) {\n\t    // In browser\n        window.doublearray = doublearray;\n    } else {\n\t    // In node\n        module.exports = doublearray;\n    }\n\n})();\n"]},"metadata":{},"sourceType":"script"}