{"ast":null,"code":"\"use strict\"; // Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GoogleAuth = exports.CLOUD_SDK_CLIENT_ID = void 0;\n\nconst child_process_1 = require(\"child_process\");\n\nconst fs = require(\"fs\");\n\nconst gcpMetadata = require(\"gcp-metadata\");\n\nconst os = require(\"os\");\n\nconst path = require(\"path\");\n\nconst crypto_1 = require(\"../crypto/crypto\");\n\nconst transporters_1 = require(\"../transporters\");\n\nconst computeclient_1 = require(\"./computeclient\");\n\nconst idtokenclient_1 = require(\"./idtokenclient\");\n\nconst envDetect_1 = require(\"./envDetect\");\n\nconst jwtclient_1 = require(\"./jwtclient\");\n\nconst refreshclient_1 = require(\"./refreshclient\");\n\nexports.CLOUD_SDK_CLIENT_ID = '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';\n\nlet GoogleAuth =\n/** @class */\n(() => {\n  class GoogleAuth {\n    constructor(opts) {\n      /**\n       * Caches a value indicating whether the auth layer is running on Google\n       * Compute Engine.\n       * @private\n       */\n      this.checkIsGCE = undefined; // To save the contents of the JSON credential file\n\n      this.jsonContent = null;\n      this.cachedCredential = null;\n      opts = opts || {};\n      this._cachedProjectId = opts.projectId || null;\n      this.keyFilename = opts.keyFilename || opts.keyFile;\n      this.scopes = opts.scopes;\n      this.jsonContent = opts.credentials || null;\n      this.clientOptions = opts.clientOptions;\n    } // Note:  this properly is only public to satisify unit tests.\n    // https://github.com/Microsoft/TypeScript/issues/5228\n\n\n    get isGCE() {\n      return this.checkIsGCE;\n    }\n\n    getProjectId(callback) {\n      if (callback) {\n        this.getProjectIdAsync().then(r => callback(null, r), callback);\n      } else {\n        return this.getProjectIdAsync();\n      }\n    }\n\n    getProjectIdAsync() {\n      if (this._cachedProjectId) {\n        return Promise.resolve(this._cachedProjectId);\n      } // In implicit case, supports three environments. In order of precedence,\n      // the implicit environments are:\n      // - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n      // - GOOGLE_APPLICATION_CREDENTIALS JSON file\n      // - Cloud SDK: `gcloud config config-helper --format json`\n      // - GCE project ID from metadata server)\n\n\n      if (!this._getDefaultProjectIdPromise) {\n        // TODO: refactor the below code so that it doesn't mix and match\n        // promises and async/await.\n        this._getDefaultProjectIdPromise = new Promise( // eslint-disable-next-line no-async-promise-executor\n        async (resolve, reject) => {\n          try {\n            const projectId = this.getProductionProjectId() || (await this.getFileProjectId()) || (await this.getDefaultServiceProjectId()) || (await this.getGCEProjectId());\n            this._cachedProjectId = projectId;\n\n            if (!projectId) {\n              throw new Error('Unable to detect a Project Id in the current environment. \\n' + 'To learn more about authentication and Google APIs, visit: \\n' + 'https://cloud.google.com/docs/authentication/getting-started');\n            }\n\n            resolve(projectId);\n          } catch (e) {\n            reject(e);\n          }\n        });\n      }\n\n      return this._getDefaultProjectIdPromise;\n    }\n\n    getApplicationDefault(optionsOrCallback = {}, callback) {\n      let options;\n\n      if (typeof optionsOrCallback === 'function') {\n        callback = optionsOrCallback;\n      } else {\n        options = optionsOrCallback;\n      }\n\n      if (callback) {\n        this.getApplicationDefaultAsync(options).then(r => callback(null, r.credential, r.projectId), callback);\n      } else {\n        return this.getApplicationDefaultAsync(options);\n      }\n    }\n\n    async getApplicationDefaultAsync(options = {}) {\n      // If we've already got a cached credential, just return it.\n      if (this.cachedCredential) {\n        return {\n          credential: this.cachedCredential,\n          projectId: await this.getProjectIdAsync()\n        };\n      }\n\n      let credential;\n      let projectId; // Check for the existence of a local environment variable pointing to the\n      // location of the credential file. This is typically used in local\n      // developer scenarios.\n\n      credential = await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);\n\n      if (credential) {\n        if (credential instanceof jwtclient_1.JWT) {\n          credential.scopes = this.scopes;\n        }\n\n        this.cachedCredential = credential;\n        projectId = await this.getProjectId();\n        return {\n          credential,\n          projectId\n        };\n      } // Look in the well-known credential file location.\n\n\n      credential = await this._tryGetApplicationCredentialsFromWellKnownFile(options);\n\n      if (credential) {\n        if (credential instanceof jwtclient_1.JWT) {\n          credential.scopes = this.scopes;\n        }\n\n        this.cachedCredential = credential;\n        projectId = await this.getProjectId();\n        return {\n          credential,\n          projectId\n        };\n      } // Determine if we're running on GCE.\n\n\n      let isGCE;\n\n      try {\n        isGCE = await this._checkIsGCE();\n      } catch (e) {\n        e.message = `Unexpected error determining execution environment: ${e.message}`;\n        throw e;\n      }\n\n      if (!isGCE) {\n        // We failed to find the default credentials. Bail out with an error.\n        throw new Error('Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.');\n      } // For GCE, just return a default ComputeClient. It will take care of\n      // the rest.\n\n\n      options.scopes = this.scopes;\n      this.cachedCredential = new computeclient_1.Compute(options);\n      projectId = await this.getProjectId();\n      return {\n        projectId,\n        credential: this.cachedCredential\n      };\n    }\n    /**\n     * Determines whether the auth layer is running on Google Compute Engine.\n     * @returns A promise that resolves with the boolean.\n     * @api private\n     */\n\n\n    async _checkIsGCE() {\n      if (this.checkIsGCE === undefined) {\n        this.checkIsGCE = await gcpMetadata.isAvailable();\n      }\n\n      return this.checkIsGCE;\n    }\n    /**\n     * Attempts to load default credentials from the environment variable path..\n     * @returns Promise that resolves with the OAuth2Client or null.\n     * @api private\n     */\n\n\n    async _tryGetApplicationCredentialsFromEnvironmentVariable(options) {\n      const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'] || process.env['google_application_credentials'];\n\n      if (!credentialsPath || credentialsPath.length === 0) {\n        return null;\n      }\n\n      try {\n        return this._getApplicationCredentialsFromFilePath(credentialsPath, options);\n      } catch (e) {\n        e.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e.message}`;\n        throw e;\n      }\n    }\n    /**\n     * Attempts to load default credentials from a well-known file location\n     * @return Promise that resolves with the OAuth2Client or null.\n     * @api private\n     */\n\n\n    async _tryGetApplicationCredentialsFromWellKnownFile(options) {\n      // First, figure out the location of the file, depending upon the OS type.\n      let location = null;\n\n      if (this._isWindows()) {\n        // Windows\n        location = process.env['APPDATA'];\n      } else {\n        // Linux or Mac\n        const home = process.env['HOME'];\n\n        if (home) {\n          location = path.join(home, '.config');\n        }\n      } // If we found the root path, expand it.\n\n\n      if (location) {\n        location = path.join(location, 'gcloud', 'application_default_credentials.json');\n\n        if (!fs.existsSync(location)) {\n          location = null;\n        }\n      } // The file does not exist.\n\n\n      if (!location) {\n        return null;\n      } // The file seems to exist. Try to use it.\n\n\n      const client = await this._getApplicationCredentialsFromFilePath(location, options);\n      return client;\n    }\n    /**\n     * Attempts to load default credentials from a file at the given path..\n     * @param filePath The path to the file to read.\n     * @returns Promise that resolves with the OAuth2Client\n     * @api private\n     */\n\n\n    async _getApplicationCredentialsFromFilePath(filePath, options = {}) {\n      // Make sure the path looks like a string.\n      if (!filePath || filePath.length === 0) {\n        throw new Error('The file path is invalid.');\n      } // Make sure there is a file at the path. lstatSync will throw if there is\n      // nothing there.\n\n\n      try {\n        // Resolve path to actual file in case of symlink. Expect a thrown error\n        // if not resolvable.\n        filePath = fs.realpathSync(filePath);\n\n        if (!fs.lstatSync(filePath).isFile()) {\n          throw new Error();\n        }\n      } catch (err) {\n        err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n        throw err;\n      } // Now open a read stream on the file, and parse it.\n\n\n      const readStream = fs.createReadStream(filePath);\n      return this.fromStream(readStream, options);\n    }\n    /**\n     * Create a credentials instance using the given input options.\n     * @param json The input object.\n     * @param options The JWT or UserRefresh options for the client\n     * @returns JWT or UserRefresh Client with data\n     */\n\n\n    fromJSON(json, options) {\n      let client;\n\n      if (!json) {\n        throw new Error('Must pass in a JSON object containing the Google auth settings.');\n      }\n\n      options = options || {};\n\n      if (json.type === 'authorized_user') {\n        client = new refreshclient_1.UserRefreshClient(options);\n      } else {\n        options.scopes = this.scopes;\n        client = new jwtclient_1.JWT(options);\n      }\n\n      client.fromJSON(json);\n      return client;\n    }\n    /**\n     * Return a JWT or UserRefreshClient from JavaScript object, caching both the\n     * object used to instantiate and the client.\n     * @param json The input object.\n     * @param options The JWT or UserRefresh options for the client\n     * @returns JWT or UserRefresh Client with data\n     */\n\n\n    _cacheClientFromJSON(json, options) {\n      let client; // create either a UserRefreshClient or JWT client.\n\n      options = options || {};\n\n      if (json.type === 'authorized_user') {\n        client = new refreshclient_1.UserRefreshClient(options);\n      } else {\n        options.scopes = this.scopes;\n        client = new jwtclient_1.JWT(options);\n      }\n\n      client.fromJSON(json); // cache both raw data used to instantiate client and client itself.\n\n      this.jsonContent = json;\n      this.cachedCredential = client;\n      return this.cachedCredential;\n    }\n\n    fromStream(inputStream, optionsOrCallback = {}, callback) {\n      let options = {};\n\n      if (typeof optionsOrCallback === 'function') {\n        callback = optionsOrCallback;\n      } else {\n        options = optionsOrCallback;\n      }\n\n      if (callback) {\n        this.fromStreamAsync(inputStream, options).then(r => callback(null, r), callback);\n      } else {\n        return this.fromStreamAsync(inputStream, options);\n      }\n    }\n\n    fromStreamAsync(inputStream, options) {\n      return new Promise((resolve, reject) => {\n        if (!inputStream) {\n          throw new Error('Must pass in a stream containing the Google auth settings.');\n        }\n\n        let s = '';\n        inputStream.setEncoding('utf8').on('error', reject).on('data', chunk => s += chunk).on('end', () => {\n          try {\n            const data = JSON.parse(s);\n\n            const r = this._cacheClientFromJSON(data, options);\n\n            return resolve(r);\n          } catch (err) {\n            return reject(err);\n          }\n        });\n      });\n    }\n    /**\n     * Create a credentials instance using the given API key string.\n     * @param apiKey The API key string\n     * @param options An optional options object.\n     * @returns A JWT loaded from the key\n     */\n\n\n    fromAPIKey(apiKey, options) {\n      options = options || {};\n      const client = new jwtclient_1.JWT(options);\n      client.fromAPIKey(apiKey);\n      return client;\n    }\n    /**\n     * Determines whether the current operating system is Windows.\n     * @api private\n     */\n\n\n    _isWindows() {\n      const sys = os.platform();\n\n      if (sys && sys.length >= 3) {\n        if (sys.substring(0, 3).toLowerCase() === 'win') {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Run the Google Cloud SDK command that prints the default project ID\n     */\n\n\n    async getDefaultServiceProjectId() {\n      return new Promise(resolve => {\n        child_process_1.exec('gcloud config config-helper --format json', (err, stdout, stderr) => {\n          if (!err && stdout) {\n            try {\n              const projectId = JSON.parse(stdout).configuration.properties.core.project;\n              resolve(projectId);\n              return;\n            } catch (e) {// ignore errors\n            }\n          }\n\n          resolve(null);\n        });\n      });\n    }\n    /**\n     * Loads the project id from environment variables.\n     * @api private\n     */\n\n\n    getProductionProjectId() {\n      return process.env['GCLOUD_PROJECT'] || process.env['GOOGLE_CLOUD_PROJECT'] || process.env['gcloud_project'] || process.env['google_cloud_project'];\n    }\n    /**\n     * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\n     * @api private\n     */\n\n\n    async getFileProjectId() {\n      if (this.cachedCredential) {\n        // Try to read the project ID from the cached credentials file\n        return this.cachedCredential.projectId;\n      } // Ensure the projectId is loaded from the keyFile if available.\n\n\n      if (this.keyFilename) {\n        const creds = await this.getClient();\n\n        if (creds && creds.projectId) {\n          return creds.projectId;\n        }\n      } // Try to load a credentials file and read its project ID\n\n\n      const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();\n\n      if (r) {\n        return r.projectId;\n      } else {\n        return null;\n      }\n    }\n    /**\n     * Gets the Compute Engine project ID if it can be inferred.\n     */\n\n\n    async getGCEProjectId() {\n      try {\n        const r = await gcpMetadata.project('project-id');\n        return r;\n      } catch (e) {\n        // Ignore any errors\n        return null;\n      }\n    }\n\n    getCredentials(callback) {\n      if (callback) {\n        this.getCredentialsAsync().then(r => callback(null, r), callback);\n      } else {\n        return this.getCredentialsAsync();\n      }\n    }\n\n    async getCredentialsAsync() {\n      await this.getClient();\n\n      if (this.jsonContent) {\n        const credential = {\n          client_email: this.jsonContent.client_email,\n          private_key: this.jsonContent.private_key\n        };\n        return credential;\n      }\n\n      const isGCE = await this._checkIsGCE();\n\n      if (!isGCE) {\n        throw new Error('Unknown error.');\n      } // For GCE, return the service account details from the metadata server\n      // NOTE: The trailing '/' at the end of service-accounts/ is very important!\n      // The GCF metadata server doesn't respect querystring params if this / is\n      // not included.\n\n\n      const data = await gcpMetadata.instance({\n        property: 'service-accounts/',\n        params: {\n          recursive: 'true'\n        }\n      });\n\n      if (!data || !data.default || !data.default.email) {\n        throw new Error('Failure from metadata server.');\n      }\n\n      return {\n        client_email: data.default.email\n      };\n    }\n    /**\n     * Automatically obtain a client based on the provided configuration.  If no\n     * options were passed, use Application Default Credentials.\n     */\n\n\n    async getClient(options) {\n      if (options) {\n        throw new Error('Passing options to getClient is forbidden in v5.0.0. Use new GoogleAuth(opts) instead.');\n      }\n\n      if (!this.cachedCredential) {\n        if (this.jsonContent) {\n          this._cacheClientFromJSON(this.jsonContent, this.clientOptions);\n        } else if (this.keyFilename) {\n          const filePath = path.resolve(this.keyFilename);\n          const stream = fs.createReadStream(filePath);\n          await this.fromStreamAsync(stream, this.clientOptions);\n        } else {\n          await this.getApplicationDefaultAsync(this.clientOptions);\n        }\n      }\n\n      return this.cachedCredential;\n    }\n    /**\n     * Creates a client which will fetch an ID token for authorization.\n     * @param targetAudience the audience for the fetched ID token.\n     * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.\n     */\n\n\n    async getIdTokenClient(targetAudience) {\n      const client = await this.getClient();\n\n      if (!('fetchIdToken' in client)) {\n        throw new Error('Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.');\n      }\n\n      return new idtokenclient_1.IdTokenClient({\n        targetAudience,\n        idTokenProvider: client\n      });\n    }\n    /**\n     * Automatically obtain application default credentials, and return\n     * an access token for making requests.\n     */\n\n\n    async getAccessToken() {\n      const client = await this.getClient();\n      return (await client.getAccessToken()).token;\n    }\n    /**\n     * Obtain the HTTP headers that will provide authorization for a given\n     * request.\n     */\n\n\n    async getRequestHeaders(url) {\n      const client = await this.getClient();\n      return client.getRequestHeaders(url);\n    }\n    /**\n     * Obtain credentials for a request, then attach the appropriate headers to\n     * the request options.\n     * @param opts Axios or Request options on which to attach the headers\n     */\n\n\n    async authorizeRequest(opts) {\n      opts = opts || {};\n      const url = opts.url || opts.uri;\n      const client = await this.getClient();\n      const headers = await client.getRequestHeaders(url);\n      opts.headers = Object.assign(opts.headers || {}, headers);\n      return opts;\n    }\n    /**\n     * Automatically obtain application default credentials, and make an\n     * HTTP request using the given options.\n     * @param opts Axios request options for the HTTP request.\n     */\n    // tslint:disable-next-line no-any\n\n\n    async request(opts) {\n      const client = await this.getClient();\n      return client.request(opts);\n    }\n    /**\n     * Determine the compute environment in which the code is running.\n     */\n\n\n    getEnv() {\n      return envDetect_1.getEnv();\n    }\n    /**\n     * Sign the given data with the current private key, or go out\n     * to the IAM API to sign it.\n     * @param data The data to be signed.\n     */\n\n\n    async sign(data) {\n      const client = await this.getClient();\n      const crypto = crypto_1.createCrypto();\n\n      if (client instanceof jwtclient_1.JWT && client.key) {\n        const sign = await crypto.sign(client.key, data);\n        return sign;\n      }\n\n      const projectId = await this.getProjectId();\n\n      if (!projectId) {\n        throw new Error('Cannot sign data without a project ID.');\n      }\n\n      const creds = await this.getCredentials();\n\n      if (!creds.client_email) {\n        throw new Error('Cannot sign data without `client_email`.');\n      }\n\n      const url = `https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/${creds.client_email}:signBlob`;\n      const res = await this.request({\n        method: 'POST',\n        url,\n        data: {\n          payload: crypto.encodeBase64StringUtf8(data)\n        }\n      });\n      return res.data.signedBlob;\n    }\n\n  }\n  /**\n   * Export DefaultTransporter as a static property of the class.\n   */\n\n\n  GoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;\n  return GoogleAuth;\n})();\n\nexports.GoogleAuth = GoogleAuth;","map":{"version":3,"sources":["/home/byungchan/Projects/react/JapaneseQuiz/client/node_modules/google-auth-library/build/src/auth/googleauth.js"],"names":["Object","defineProperty","exports","value","GoogleAuth","CLOUD_SDK_CLIENT_ID","child_process_1","require","fs","gcpMetadata","os","path","crypto_1","transporters_1","computeclient_1","idtokenclient_1","envDetect_1","jwtclient_1","refreshclient_1","constructor","opts","checkIsGCE","undefined","jsonContent","cachedCredential","_cachedProjectId","projectId","keyFilename","keyFile","scopes","credentials","clientOptions","isGCE","getProjectId","callback","getProjectIdAsync","then","r","Promise","resolve","_getDefaultProjectIdPromise","reject","getProductionProjectId","getFileProjectId","getDefaultServiceProjectId","getGCEProjectId","Error","e","getApplicationDefault","optionsOrCallback","options","getApplicationDefaultAsync","credential","_tryGetApplicationCredentialsFromEnvironmentVariable","JWT","_tryGetApplicationCredentialsFromWellKnownFile","_checkIsGCE","message","Compute","isAvailable","credentialsPath","process","env","length","_getApplicationCredentialsFromFilePath","location","_isWindows","home","join","existsSync","client","filePath","realpathSync","lstatSync","isFile","err","readStream","createReadStream","fromStream","fromJSON","json","type","UserRefreshClient","_cacheClientFromJSON","inputStream","fromStreamAsync","s","setEncoding","on","chunk","data","JSON","parse","fromAPIKey","apiKey","sys","platform","substring","toLowerCase","exec","stdout","stderr","configuration","properties","core","project","creds","getClient","getCredentials","getCredentialsAsync","client_email","private_key","instance","property","params","recursive","default","email","stream","getIdTokenClient","targetAudience","IdTokenClient","idTokenProvider","getAccessToken","token","getRequestHeaders","url","authorizeRequest","uri","headers","assign","request","getEnv","sign","crypto","createCrypto","key","res","method","payload","encodeBase64StringUtf8","signedBlob","DefaultTransporter"],"mappings":"AAAA,a,CACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,UAAR,GAAqBF,OAAO,CAACG,mBAAR,GAA8B,KAAK,CAAxD;;AACA,MAAMC,eAAe,GAAGC,OAAO,CAAC,eAAD,CAA/B;;AACA,MAAMC,EAAE,GAAGD,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAME,WAAW,GAAGF,OAAO,CAAC,cAAD,CAA3B;;AACA,MAAMG,EAAE,GAAGH,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMI,IAAI,GAAGJ,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMK,QAAQ,GAAGL,OAAO,CAAC,kBAAD,CAAxB;;AACA,MAAMM,cAAc,GAAGN,OAAO,CAAC,iBAAD,CAA9B;;AACA,MAAMO,eAAe,GAAGP,OAAO,CAAC,iBAAD,CAA/B;;AACA,MAAMQ,eAAe,GAAGR,OAAO,CAAC,iBAAD,CAA/B;;AACA,MAAMS,WAAW,GAAGT,OAAO,CAAC,aAAD,CAA3B;;AACA,MAAMU,WAAW,GAAGV,OAAO,CAAC,aAAD,CAA3B;;AACA,MAAMW,eAAe,GAAGX,OAAO,CAAC,iBAAD,CAA/B;;AACAL,OAAO,CAACG,mBAAR,GAA8B,0EAA9B;;AACA,IAAID,UAAU;AAAG;AAAc,CAAC,MAAM;AAClC,QAAMA,UAAN,CAAiB;AACbe,IAAAA,WAAW,CAACC,IAAD,EAAO;AACd;;;;;AAKA,WAAKC,UAAL,GAAkBC,SAAlB,CANc,CAOd;;AACA,WAAKC,WAAL,GAAmB,IAAnB;AACA,WAAKC,gBAAL,GAAwB,IAAxB;AACAJ,MAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACA,WAAKK,gBAAL,GAAwBL,IAAI,CAACM,SAAL,IAAkB,IAA1C;AACA,WAAKC,WAAL,GAAmBP,IAAI,CAACO,WAAL,IAAoBP,IAAI,CAACQ,OAA5C;AACA,WAAKC,MAAL,GAAcT,IAAI,CAACS,MAAnB;AACA,WAAKN,WAAL,GAAmBH,IAAI,CAACU,WAAL,IAAoB,IAAvC;AACA,WAAKC,aAAL,GAAqBX,IAAI,CAACW,aAA1B;AACH,KAjBY,CAkBb;AACA;;;AACA,QAAIC,KAAJ,GAAY;AACR,aAAO,KAAKX,UAAZ;AACH;;AACDY,IAAAA,YAAY,CAACC,QAAD,EAAW;AACnB,UAAIA,QAAJ,EAAc;AACV,aAAKC,iBAAL,GAAyBC,IAAzB,CAA8BC,CAAC,IAAIH,QAAQ,CAAC,IAAD,EAAOG,CAAP,CAA3C,EAAsDH,QAAtD;AACH,OAFD,MAGK;AACD,eAAO,KAAKC,iBAAL,EAAP;AACH;AACJ;;AACDA,IAAAA,iBAAiB,GAAG;AAChB,UAAI,KAAKV,gBAAT,EAA2B;AACvB,eAAOa,OAAO,CAACC,OAAR,CAAgB,KAAKd,gBAArB,CAAP;AACH,OAHe,CAIhB;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAI,CAAC,KAAKe,2BAAV,EAAuC;AACnC;AACA;AACA,aAAKA,2BAAL,GAAmC,IAAIF,OAAJ,EACnC;AACA,eAAOC,OAAP,EAAgBE,MAAhB,KAA2B;AACvB,cAAI;AACA,kBAAMf,SAAS,GAAG,KAAKgB,sBAAL,OACb,MAAM,KAAKC,gBAAL,EADO,MAEb,MAAM,KAAKC,0BAAL,EAFO,MAGb,MAAM,KAAKC,eAAL,EAHO,CAAlB;AAIA,iBAAKpB,gBAAL,GAAwBC,SAAxB;;AACA,gBAAI,CAACA,SAAL,EAAgB;AACZ,oBAAM,IAAIoB,KAAJ,CAAU,iEACZ,+DADY,GAEZ,8DAFE,CAAN;AAGH;;AACDP,YAAAA,OAAO,CAACb,SAAD,CAAP;AACH,WAZD,CAaA,OAAOqB,CAAP,EAAU;AACNN,YAAAA,MAAM,CAACM,CAAD,CAAN;AACH;AACJ,SAnBkC,CAAnC;AAoBH;;AACD,aAAO,KAAKP,2BAAZ;AACH;;AACDQ,IAAAA,qBAAqB,CAACC,iBAAiB,GAAG,EAArB,EAAyBf,QAAzB,EAAmC;AACpD,UAAIgB,OAAJ;;AACA,UAAI,OAAOD,iBAAP,KAA6B,UAAjC,EAA6C;AACzCf,QAAAA,QAAQ,GAAGe,iBAAX;AACH,OAFD,MAGK;AACDC,QAAAA,OAAO,GAAGD,iBAAV;AACH;;AACD,UAAIf,QAAJ,EAAc;AACV,aAAKiB,0BAAL,CAAgCD,OAAhC,EAAyCd,IAAzC,CAA8CC,CAAC,IAAIH,QAAQ,CAAC,IAAD,EAAOG,CAAC,CAACe,UAAT,EAAqBf,CAAC,CAACX,SAAvB,CAA3D,EAA8FQ,QAA9F;AACH,OAFD,MAGK;AACD,eAAO,KAAKiB,0BAAL,CAAgCD,OAAhC,CAAP;AACH;AACJ;;AACD,UAAMC,0BAAN,CAAiCD,OAAO,GAAG,EAA3C,EAA+C;AAC3C;AACA,UAAI,KAAK1B,gBAAT,EAA2B;AACvB,eAAO;AACH4B,UAAAA,UAAU,EAAE,KAAK5B,gBADd;AAEHE,UAAAA,SAAS,EAAE,MAAM,KAAKS,iBAAL;AAFd,SAAP;AAIH;;AACD,UAAIiB,UAAJ;AACA,UAAI1B,SAAJ,CAT2C,CAU3C;AACA;AACA;;AACA0B,MAAAA,UAAU,GAAG,MAAM,KAAKC,oDAAL,CAA0DH,OAA1D,CAAnB;;AACA,UAAIE,UAAJ,EAAgB;AACZ,YAAIA,UAAU,YAAYnC,WAAW,CAACqC,GAAtC,EAA2C;AACvCF,UAAAA,UAAU,CAACvB,MAAX,GAAoB,KAAKA,MAAzB;AACH;;AACD,aAAKL,gBAAL,GAAwB4B,UAAxB;AACA1B,QAAAA,SAAS,GAAG,MAAM,KAAKO,YAAL,EAAlB;AACA,eAAO;AAAEmB,UAAAA,UAAF;AAAc1B,UAAAA;AAAd,SAAP;AACH,OArB0C,CAsB3C;;;AACA0B,MAAAA,UAAU,GAAG,MAAM,KAAKG,8CAAL,CAAoDL,OAApD,CAAnB;;AACA,UAAIE,UAAJ,EAAgB;AACZ,YAAIA,UAAU,YAAYnC,WAAW,CAACqC,GAAtC,EAA2C;AACvCF,UAAAA,UAAU,CAACvB,MAAX,GAAoB,KAAKA,MAAzB;AACH;;AACD,aAAKL,gBAAL,GAAwB4B,UAAxB;AACA1B,QAAAA,SAAS,GAAG,MAAM,KAAKO,YAAL,EAAlB;AACA,eAAO;AAAEmB,UAAAA,UAAF;AAAc1B,UAAAA;AAAd,SAAP;AACH,OA/B0C,CAgC3C;;;AACA,UAAIM,KAAJ;;AACA,UAAI;AACAA,QAAAA,KAAK,GAAG,MAAM,KAAKwB,WAAL,EAAd;AACH,OAFD,CAGA,OAAOT,CAAP,EAAU;AACNA,QAAAA,CAAC,CAACU,OAAF,GAAa,uDAAsDV,CAAC,CAACU,OAAQ,EAA7E;AACA,cAAMV,CAAN;AACH;;AACD,UAAI,CAACf,KAAL,EAAY;AACR;AACA,cAAM,IAAIc,KAAJ,CAAU,sIAAV,CAAN;AACH,OA5C0C,CA6C3C;AACA;;;AACAI,MAAAA,OAAO,CAACrB,MAAR,GAAiB,KAAKA,MAAtB;AACA,WAAKL,gBAAL,GAAwB,IAAIV,eAAe,CAAC4C,OAApB,CAA4BR,OAA5B,CAAxB;AACAxB,MAAAA,SAAS,GAAG,MAAM,KAAKO,YAAL,EAAlB;AACA,aAAO;AAAEP,QAAAA,SAAF;AAAa0B,QAAAA,UAAU,EAAE,KAAK5B;AAA9B,OAAP;AACH;AACD;;;;;;;AAKA,UAAMgC,WAAN,GAAoB;AAChB,UAAI,KAAKnC,UAAL,KAAoBC,SAAxB,EAAmC;AAC/B,aAAKD,UAAL,GAAkB,MAAMZ,WAAW,CAACkD,WAAZ,EAAxB;AACH;;AACD,aAAO,KAAKtC,UAAZ;AACH;AACD;;;;;;;AAKA,UAAMgC,oDAAN,CAA2DH,OAA3D,EAAoE;AAChE,YAAMU,eAAe,GAAGC,OAAO,CAACC,GAAR,CAAY,gCAAZ,KACpBD,OAAO,CAACC,GAAR,CAAY,gCAAZ,CADJ;;AAEA,UAAI,CAACF,eAAD,IAAoBA,eAAe,CAACG,MAAhB,KAA2B,CAAnD,EAAsD;AAClD,eAAO,IAAP;AACH;;AACD,UAAI;AACA,eAAO,KAAKC,sCAAL,CAA4CJ,eAA5C,EAA6DV,OAA7D,CAAP;AACH,OAFD,CAGA,OAAOH,CAAP,EAAU;AACNA,QAAAA,CAAC,CAACU,OAAF,GAAa,4GAA2GV,CAAC,CAACU,OAAQ,EAAlI;AACA,cAAMV,CAAN;AACH;AACJ;AACD;;;;;;;AAKA,UAAMQ,8CAAN,CAAqDL,OAArD,EAA8D;AAC1D;AACA,UAAIe,QAAQ,GAAG,IAAf;;AACA,UAAI,KAAKC,UAAL,EAAJ,EAAuB;AACnB;AACAD,QAAAA,QAAQ,GAAGJ,OAAO,CAACC,GAAR,CAAY,SAAZ,CAAX;AACH,OAHD,MAIK;AACD;AACA,cAAMK,IAAI,GAAGN,OAAO,CAACC,GAAR,CAAY,MAAZ,CAAb;;AACA,YAAIK,IAAJ,EAAU;AACNF,UAAAA,QAAQ,GAAGtD,IAAI,CAACyD,IAAL,CAAUD,IAAV,EAAgB,SAAhB,CAAX;AACH;AACJ,OAbyD,CAc1D;;;AACA,UAAIF,QAAJ,EAAc;AACVA,QAAAA,QAAQ,GAAGtD,IAAI,CAACyD,IAAL,CAAUH,QAAV,EAAoB,QAApB,EAA8B,sCAA9B,CAAX;;AACA,YAAI,CAACzD,EAAE,CAAC6D,UAAH,CAAcJ,QAAd,CAAL,EAA8B;AAC1BA,UAAAA,QAAQ,GAAG,IAAX;AACH;AACJ,OApByD,CAqB1D;;;AACA,UAAI,CAACA,QAAL,EAAe;AACX,eAAO,IAAP;AACH,OAxByD,CAyB1D;;;AACA,YAAMK,MAAM,GAAG,MAAM,KAAKN,sCAAL,CAA4CC,QAA5C,EAAsDf,OAAtD,CAArB;AACA,aAAOoB,MAAP;AACH;AACD;;;;;;;;AAMA,UAAMN,sCAAN,CAA6CO,QAA7C,EAAuDrB,OAAO,GAAG,EAAjE,EAAqE;AACjE;AACA,UAAI,CAACqB,QAAD,IAAaA,QAAQ,CAACR,MAAT,KAAoB,CAArC,EAAwC;AACpC,cAAM,IAAIjB,KAAJ,CAAU,2BAAV,CAAN;AACH,OAJgE,CAKjE;AACA;;;AACA,UAAI;AACA;AACA;AACAyB,QAAAA,QAAQ,GAAG/D,EAAE,CAACgE,YAAH,CAAgBD,QAAhB,CAAX;;AACA,YAAI,CAAC/D,EAAE,CAACiE,SAAH,CAAaF,QAAb,EAAuBG,MAAvB,EAAL,EAAsC;AAClC,gBAAM,IAAI5B,KAAJ,EAAN;AACH;AACJ,OAPD,CAQA,OAAO6B,GAAP,EAAY;AACRA,QAAAA,GAAG,CAAClB,OAAJ,GAAe,eAAcc,QAAS,yCAAwCI,GAAG,CAAClB,OAAQ,EAA1F;AACA,cAAMkB,GAAN;AACH,OAlBgE,CAmBjE;;;AACA,YAAMC,UAAU,GAAGpE,EAAE,CAACqE,gBAAH,CAAoBN,QAApB,CAAnB;AACA,aAAO,KAAKO,UAAL,CAAgBF,UAAhB,EAA4B1B,OAA5B,CAAP;AACH;AACD;;;;;;;;AAMA6B,IAAAA,QAAQ,CAACC,IAAD,EAAO9B,OAAP,EAAgB;AACpB,UAAIoB,MAAJ;;AACA,UAAI,CAACU,IAAL,EAAW;AACP,cAAM,IAAIlC,KAAJ,CAAU,iEAAV,CAAN;AACH;;AACDI,MAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AACA,UAAI8B,IAAI,CAACC,IAAL,KAAc,iBAAlB,EAAqC;AACjCX,QAAAA,MAAM,GAAG,IAAIpD,eAAe,CAACgE,iBAApB,CAAsChC,OAAtC,CAAT;AACH,OAFD,MAGK;AACDA,QAAAA,OAAO,CAACrB,MAAR,GAAiB,KAAKA,MAAtB;AACAyC,QAAAA,MAAM,GAAG,IAAIrD,WAAW,CAACqC,GAAhB,CAAoBJ,OAApB,CAAT;AACH;;AACDoB,MAAAA,MAAM,CAACS,QAAP,CAAgBC,IAAhB;AACA,aAAOV,MAAP;AACH;AACD;;;;;;;;;AAOAa,IAAAA,oBAAoB,CAACH,IAAD,EAAO9B,OAAP,EAAgB;AAChC,UAAIoB,MAAJ,CADgC,CAEhC;;AACApB,MAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AACA,UAAI8B,IAAI,CAACC,IAAL,KAAc,iBAAlB,EAAqC;AACjCX,QAAAA,MAAM,GAAG,IAAIpD,eAAe,CAACgE,iBAApB,CAAsChC,OAAtC,CAAT;AACH,OAFD,MAGK;AACDA,QAAAA,OAAO,CAACrB,MAAR,GAAiB,KAAKA,MAAtB;AACAyC,QAAAA,MAAM,GAAG,IAAIrD,WAAW,CAACqC,GAAhB,CAAoBJ,OAApB,CAAT;AACH;;AACDoB,MAAAA,MAAM,CAACS,QAAP,CAAgBC,IAAhB,EAXgC,CAYhC;;AACA,WAAKzD,WAAL,GAAmByD,IAAnB;AACA,WAAKxD,gBAAL,GAAwB8C,MAAxB;AACA,aAAO,KAAK9C,gBAAZ;AACH;;AACDsD,IAAAA,UAAU,CAACM,WAAD,EAAcnC,iBAAiB,GAAG,EAAlC,EAAsCf,QAAtC,EAAgD;AACtD,UAAIgB,OAAO,GAAG,EAAd;;AACA,UAAI,OAAOD,iBAAP,KAA6B,UAAjC,EAA6C;AACzCf,QAAAA,QAAQ,GAAGe,iBAAX;AACH,OAFD,MAGK;AACDC,QAAAA,OAAO,GAAGD,iBAAV;AACH;;AACD,UAAIf,QAAJ,EAAc;AACV,aAAKmD,eAAL,CAAqBD,WAArB,EAAkClC,OAAlC,EAA2Cd,IAA3C,CAAgDC,CAAC,IAAIH,QAAQ,CAAC,IAAD,EAAOG,CAAP,CAA7D,EAAwEH,QAAxE;AACH,OAFD,MAGK;AACD,eAAO,KAAKmD,eAAL,CAAqBD,WAArB,EAAkClC,OAAlC,CAAP;AACH;AACJ;;AACDmC,IAAAA,eAAe,CAACD,WAAD,EAAclC,OAAd,EAAuB;AAClC,aAAO,IAAIZ,OAAJ,CAAY,CAACC,OAAD,EAAUE,MAAV,KAAqB;AACpC,YAAI,CAAC2C,WAAL,EAAkB;AACd,gBAAM,IAAItC,KAAJ,CAAU,4DAAV,CAAN;AACH;;AACD,YAAIwC,CAAC,GAAG,EAAR;AACAF,QAAAA,WAAW,CACNG,WADL,CACiB,MADjB,EAEKC,EAFL,CAEQ,OAFR,EAEiB/C,MAFjB,EAGK+C,EAHL,CAGQ,MAHR,EAGgBC,KAAK,IAAKH,CAAC,IAAIG,KAH/B,EAIKD,EAJL,CAIQ,KAJR,EAIe,MAAM;AACjB,cAAI;AACA,kBAAME,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWN,CAAX,CAAb;;AACA,kBAAMjD,CAAC,GAAG,KAAK8C,oBAAL,CAA0BO,IAA1B,EAAgCxC,OAAhC,CAAV;;AACA,mBAAOX,OAAO,CAACF,CAAD,CAAd;AACH,WAJD,CAKA,OAAOsC,GAAP,EAAY;AACR,mBAAOlC,MAAM,CAACkC,GAAD,CAAb;AACH;AACJ,SAbD;AAcH,OAnBM,CAAP;AAoBH;AACD;;;;;;;;AAMAkB,IAAAA,UAAU,CAACC,MAAD,EAAS5C,OAAT,EAAkB;AACxBA,MAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,YAAMoB,MAAM,GAAG,IAAIrD,WAAW,CAACqC,GAAhB,CAAoBJ,OAApB,CAAf;AACAoB,MAAAA,MAAM,CAACuB,UAAP,CAAkBC,MAAlB;AACA,aAAOxB,MAAP;AACH;AACD;;;;;;AAIAJ,IAAAA,UAAU,GAAG;AACT,YAAM6B,GAAG,GAAGrF,EAAE,CAACsF,QAAH,EAAZ;;AACA,UAAID,GAAG,IAAIA,GAAG,CAAChC,MAAJ,IAAc,CAAzB,EAA4B;AACxB,YAAIgC,GAAG,CAACE,SAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoBC,WAApB,OAAsC,KAA1C,EAAiD;AAC7C,iBAAO,IAAP;AACH;AACJ;;AACD,aAAO,KAAP;AACH;AACD;;;;;AAGA,UAAMtD,0BAAN,GAAmC;AAC/B,aAAO,IAAIN,OAAJ,CAAYC,OAAO,IAAI;AAC1BjC,QAAAA,eAAe,CAAC6F,IAAhB,CAAqB,2CAArB,EAAkE,CAACxB,GAAD,EAAMyB,MAAN,EAAcC,MAAd,KAAyB;AACvF,cAAI,CAAC1B,GAAD,IAAQyB,MAAZ,EAAoB;AAChB,gBAAI;AACA,oBAAM1E,SAAS,GAAGiE,IAAI,CAACC,KAAL,CAAWQ,MAAX,EAAmBE,aAAnB,CAAiCC,UAAjC,CAA4CC,IAA5C,CACbC,OADL;AAEAlE,cAAAA,OAAO,CAACb,SAAD,CAAP;AACA;AACH,aALD,CAMA,OAAOqB,CAAP,EAAU,CACN;AACH;AACJ;;AACDR,UAAAA,OAAO,CAAC,IAAD,CAAP;AACH,SAbD;AAcH,OAfM,CAAP;AAgBH;AACD;;;;;;AAIAG,IAAAA,sBAAsB,GAAG;AACrB,aAAQmB,OAAO,CAACC,GAAR,CAAY,gBAAZ,KACJD,OAAO,CAACC,GAAR,CAAY,sBAAZ,CADI,IAEJD,OAAO,CAACC,GAAR,CAAY,gBAAZ,CAFI,IAGJD,OAAO,CAACC,GAAR,CAAY,sBAAZ,CAHJ;AAIH;AACD;;;;;;AAIA,UAAMnB,gBAAN,GAAyB;AACrB,UAAI,KAAKnB,gBAAT,EAA2B;AACvB;AACA,eAAO,KAAKA,gBAAL,CAAsBE,SAA7B;AACH,OAJoB,CAKrB;;;AACA,UAAI,KAAKC,WAAT,EAAsB;AAClB,cAAM+E,KAAK,GAAG,MAAM,KAAKC,SAAL,EAApB;;AACA,YAAID,KAAK,IAAIA,KAAK,CAAChF,SAAnB,EAA8B;AAC1B,iBAAOgF,KAAK,CAAChF,SAAb;AACH;AACJ,OAXoB,CAYrB;;;AACA,YAAMW,CAAC,GAAG,MAAM,KAAKgB,oDAAL,EAAhB;;AACA,UAAIhB,CAAJ,EAAO;AACH,eAAOA,CAAC,CAACX,SAAT;AACH,OAFD,MAGK;AACD,eAAO,IAAP;AACH;AACJ;AACD;;;;;AAGA,UAAMmB,eAAN,GAAwB;AACpB,UAAI;AACA,cAAMR,CAAC,GAAG,MAAM5B,WAAW,CAACgG,OAAZ,CAAoB,YAApB,CAAhB;AACA,eAAOpE,CAAP;AACH,OAHD,CAIA,OAAOU,CAAP,EAAU;AACN;AACA,eAAO,IAAP;AACH;AACJ;;AACD6D,IAAAA,cAAc,CAAC1E,QAAD,EAAW;AACrB,UAAIA,QAAJ,EAAc;AACV,aAAK2E,mBAAL,GAA2BzE,IAA3B,CAAgCC,CAAC,IAAIH,QAAQ,CAAC,IAAD,EAAOG,CAAP,CAA7C,EAAwDH,QAAxD;AACH,OAFD,MAGK;AACD,eAAO,KAAK2E,mBAAL,EAAP;AACH;AACJ;;AACD,UAAMA,mBAAN,GAA4B;AACxB,YAAM,KAAKF,SAAL,EAAN;;AACA,UAAI,KAAKpF,WAAT,EAAsB;AAClB,cAAM6B,UAAU,GAAG;AACf0D,UAAAA,YAAY,EAAE,KAAKvF,WAAL,CAAiBuF,YADhB;AAEfC,UAAAA,WAAW,EAAE,KAAKxF,WAAL,CAAiBwF;AAFf,SAAnB;AAIA,eAAO3D,UAAP;AACH;;AACD,YAAMpB,KAAK,GAAG,MAAM,KAAKwB,WAAL,EAApB;;AACA,UAAI,CAACxB,KAAL,EAAY;AACR,cAAM,IAAIc,KAAJ,CAAU,gBAAV,CAAN;AACH,OAZuB,CAaxB;AACA;AACA;AACA;;;AACA,YAAM4C,IAAI,GAAG,MAAMjF,WAAW,CAACuG,QAAZ,CAAqB;AACpCC,QAAAA,QAAQ,EAAE,mBAD0B;AAEpCC,QAAAA,MAAM,EAAE;AAAEC,UAAAA,SAAS,EAAE;AAAb;AAF4B,OAArB,CAAnB;;AAIA,UAAI,CAACzB,IAAD,IAAS,CAACA,IAAI,CAAC0B,OAAf,IAA0B,CAAC1B,IAAI,CAAC0B,OAAL,CAAaC,KAA5C,EAAmD;AAC/C,cAAM,IAAIvE,KAAJ,CAAU,+BAAV,CAAN;AACH;;AACD,aAAO;AAAEgE,QAAAA,YAAY,EAAEpB,IAAI,CAAC0B,OAAL,CAAaC;AAA7B,OAAP;AACH;AACD;;;;;;AAIA,UAAMV,SAAN,CAAgBzD,OAAhB,EAAyB;AACrB,UAAIA,OAAJ,EAAa;AACT,cAAM,IAAIJ,KAAJ,CAAU,wFAAV,CAAN;AACH;;AACD,UAAI,CAAC,KAAKtB,gBAAV,EAA4B;AACxB,YAAI,KAAKD,WAAT,EAAsB;AAClB,eAAK4D,oBAAL,CAA0B,KAAK5D,WAA/B,EAA4C,KAAKQ,aAAjD;AACH,SAFD,MAGK,IAAI,KAAKJ,WAAT,EAAsB;AACvB,gBAAM4C,QAAQ,GAAG5D,IAAI,CAAC4B,OAAL,CAAa,KAAKZ,WAAlB,CAAjB;AACA,gBAAM2F,MAAM,GAAG9G,EAAE,CAACqE,gBAAH,CAAoBN,QAApB,CAAf;AACA,gBAAM,KAAKc,eAAL,CAAqBiC,MAArB,EAA6B,KAAKvF,aAAlC,CAAN;AACH,SAJI,MAKA;AACD,gBAAM,KAAKoB,0BAAL,CAAgC,KAAKpB,aAArC,CAAN;AACH;AACJ;;AACD,aAAO,KAAKP,gBAAZ;AACH;AACD;;;;;;;AAKA,UAAM+F,gBAAN,CAAuBC,cAAvB,EAAuC;AACnC,YAAMlD,MAAM,GAAG,MAAM,KAAKqC,SAAL,EAArB;;AACA,UAAI,EAAE,kBAAkBrC,MAApB,CAAJ,EAAiC;AAC7B,cAAM,IAAIxB,KAAJ,CAAU,+JAAV,CAAN;AACH;;AACD,aAAO,IAAI/B,eAAe,CAAC0G,aAApB,CAAkC;AAAED,QAAAA,cAAF;AAAkBE,QAAAA,eAAe,EAAEpD;AAAnC,OAAlC,CAAP;AACH;AACD;;;;;;AAIA,UAAMqD,cAAN,GAAuB;AACnB,YAAMrD,MAAM,GAAG,MAAM,KAAKqC,SAAL,EAArB;AACA,aAAO,CAAC,MAAMrC,MAAM,CAACqD,cAAP,EAAP,EAAgCC,KAAvC;AACH;AACD;;;;;;AAIA,UAAMC,iBAAN,CAAwBC,GAAxB,EAA6B;AACzB,YAAMxD,MAAM,GAAG,MAAM,KAAKqC,SAAL,EAArB;AACA,aAAOrC,MAAM,CAACuD,iBAAP,CAAyBC,GAAzB,CAAP;AACH;AACD;;;;;;;AAKA,UAAMC,gBAAN,CAAuB3G,IAAvB,EAA6B;AACzBA,MAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACA,YAAM0G,GAAG,GAAG1G,IAAI,CAAC0G,GAAL,IAAY1G,IAAI,CAAC4G,GAA7B;AACA,YAAM1D,MAAM,GAAG,MAAM,KAAKqC,SAAL,EAArB;AACA,YAAMsB,OAAO,GAAG,MAAM3D,MAAM,CAACuD,iBAAP,CAAyBC,GAAzB,CAAtB;AACA1G,MAAAA,IAAI,CAAC6G,OAAL,GAAejI,MAAM,CAACkI,MAAP,CAAc9G,IAAI,CAAC6G,OAAL,IAAgB,EAA9B,EAAkCA,OAAlC,CAAf;AACA,aAAO7G,IAAP;AACH;AACD;;;;;AAKA;;;AACA,UAAM+G,OAAN,CAAc/G,IAAd,EAAoB;AAChB,YAAMkD,MAAM,GAAG,MAAM,KAAKqC,SAAL,EAArB;AACA,aAAOrC,MAAM,CAAC6D,OAAP,CAAe/G,IAAf,CAAP;AACH;AACD;;;;;AAGAgH,IAAAA,MAAM,GAAG;AACL,aAAOpH,WAAW,CAACoH,MAAZ,EAAP;AACH;AACD;;;;;;;AAKA,UAAMC,IAAN,CAAW3C,IAAX,EAAiB;AACb,YAAMpB,MAAM,GAAG,MAAM,KAAKqC,SAAL,EAArB;AACA,YAAM2B,MAAM,GAAG1H,QAAQ,CAAC2H,YAAT,EAAf;;AACA,UAAIjE,MAAM,YAAYrD,WAAW,CAACqC,GAA9B,IAAqCgB,MAAM,CAACkE,GAAhD,EAAqD;AACjD,cAAMH,IAAI,GAAG,MAAMC,MAAM,CAACD,IAAP,CAAY/D,MAAM,CAACkE,GAAnB,EAAwB9C,IAAxB,CAAnB;AACA,eAAO2C,IAAP;AACH;;AACD,YAAM3G,SAAS,GAAG,MAAM,KAAKO,YAAL,EAAxB;;AACA,UAAI,CAACP,SAAL,EAAgB;AACZ,cAAM,IAAIoB,KAAJ,CAAU,wCAAV,CAAN;AACH;;AACD,YAAM4D,KAAK,GAAG,MAAM,KAAKE,cAAL,EAApB;;AACA,UAAI,CAACF,KAAK,CAACI,YAAX,EAAyB;AACrB,cAAM,IAAIhE,KAAJ,CAAU,0CAAV,CAAN;AACH;;AACD,YAAMgF,GAAG,GAAI,uEAAsEpB,KAAK,CAACI,YAAa,WAAtG;AACA,YAAM2B,GAAG,GAAG,MAAM,KAAKN,OAAL,CAAa;AAC3BO,QAAAA,MAAM,EAAE,MADmB;AAE3BZ,QAAAA,GAF2B;AAG3BpC,QAAAA,IAAI,EAAE;AACFiD,UAAAA,OAAO,EAAEL,MAAM,CAACM,sBAAP,CAA8BlD,IAA9B;AADP;AAHqB,OAAb,CAAlB;AAOA,aAAO+C,GAAG,CAAC/C,IAAJ,CAASmD,UAAhB;AACH;;AAniBY;AAqiBjB;;;;;AAGAzI,EAAAA,UAAU,CAAC0I,kBAAX,GAAgCjI,cAAc,CAACiI,kBAA/C;AACA,SAAO1I,UAAP;AACH,CA3iB8B,GAA/B;;AA4iBAF,OAAO,CAACE,UAAR,GAAqBA,UAArB","sourcesContent":["\"use strict\";\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GoogleAuth = exports.CLOUD_SDK_CLIENT_ID = void 0;\nconst child_process_1 = require(\"child_process\");\nconst fs = require(\"fs\");\nconst gcpMetadata = require(\"gcp-metadata\");\nconst os = require(\"os\");\nconst path = require(\"path\");\nconst crypto_1 = require(\"../crypto/crypto\");\nconst transporters_1 = require(\"../transporters\");\nconst computeclient_1 = require(\"./computeclient\");\nconst idtokenclient_1 = require(\"./idtokenclient\");\nconst envDetect_1 = require(\"./envDetect\");\nconst jwtclient_1 = require(\"./jwtclient\");\nconst refreshclient_1 = require(\"./refreshclient\");\nexports.CLOUD_SDK_CLIENT_ID = '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';\nlet GoogleAuth = /** @class */ (() => {\n    class GoogleAuth {\n        constructor(opts) {\n            /**\n             * Caches a value indicating whether the auth layer is running on Google\n             * Compute Engine.\n             * @private\n             */\n            this.checkIsGCE = undefined;\n            // To save the contents of the JSON credential file\n            this.jsonContent = null;\n            this.cachedCredential = null;\n            opts = opts || {};\n            this._cachedProjectId = opts.projectId || null;\n            this.keyFilename = opts.keyFilename || opts.keyFile;\n            this.scopes = opts.scopes;\n            this.jsonContent = opts.credentials || null;\n            this.clientOptions = opts.clientOptions;\n        }\n        // Note:  this properly is only public to satisify unit tests.\n        // https://github.com/Microsoft/TypeScript/issues/5228\n        get isGCE() {\n            return this.checkIsGCE;\n        }\n        getProjectId(callback) {\n            if (callback) {\n                this.getProjectIdAsync().then(r => callback(null, r), callback);\n            }\n            else {\n                return this.getProjectIdAsync();\n            }\n        }\n        getProjectIdAsync() {\n            if (this._cachedProjectId) {\n                return Promise.resolve(this._cachedProjectId);\n            }\n            // In implicit case, supports three environments. In order of precedence,\n            // the implicit environments are:\n            // - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n            // - GOOGLE_APPLICATION_CREDENTIALS JSON file\n            // - Cloud SDK: `gcloud config config-helper --format json`\n            // - GCE project ID from metadata server)\n            if (!this._getDefaultProjectIdPromise) {\n                // TODO: refactor the below code so that it doesn't mix and match\n                // promises and async/await.\n                this._getDefaultProjectIdPromise = new Promise(\n                // eslint-disable-next-line no-async-promise-executor\n                async (resolve, reject) => {\n                    try {\n                        const projectId = this.getProductionProjectId() ||\n                            (await this.getFileProjectId()) ||\n                            (await this.getDefaultServiceProjectId()) ||\n                            (await this.getGCEProjectId());\n                        this._cachedProjectId = projectId;\n                        if (!projectId) {\n                            throw new Error('Unable to detect a Project Id in the current environment. \\n' +\n                                'To learn more about authentication and Google APIs, visit: \\n' +\n                                'https://cloud.google.com/docs/authentication/getting-started');\n                        }\n                        resolve(projectId);\n                    }\n                    catch (e) {\n                        reject(e);\n                    }\n                });\n            }\n            return this._getDefaultProjectIdPromise;\n        }\n        getApplicationDefault(optionsOrCallback = {}, callback) {\n            let options;\n            if (typeof optionsOrCallback === 'function') {\n                callback = optionsOrCallback;\n            }\n            else {\n                options = optionsOrCallback;\n            }\n            if (callback) {\n                this.getApplicationDefaultAsync(options).then(r => callback(null, r.credential, r.projectId), callback);\n            }\n            else {\n                return this.getApplicationDefaultAsync(options);\n            }\n        }\n        async getApplicationDefaultAsync(options = {}) {\n            // If we've already got a cached credential, just return it.\n            if (this.cachedCredential) {\n                return {\n                    credential: this.cachedCredential,\n                    projectId: await this.getProjectIdAsync(),\n                };\n            }\n            let credential;\n            let projectId;\n            // Check for the existence of a local environment variable pointing to the\n            // location of the credential file. This is typically used in local\n            // developer scenarios.\n            credential = await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);\n            if (credential) {\n                if (credential instanceof jwtclient_1.JWT) {\n                    credential.scopes = this.scopes;\n                }\n                this.cachedCredential = credential;\n                projectId = await this.getProjectId();\n                return { credential, projectId };\n            }\n            // Look in the well-known credential file location.\n            credential = await this._tryGetApplicationCredentialsFromWellKnownFile(options);\n            if (credential) {\n                if (credential instanceof jwtclient_1.JWT) {\n                    credential.scopes = this.scopes;\n                }\n                this.cachedCredential = credential;\n                projectId = await this.getProjectId();\n                return { credential, projectId };\n            }\n            // Determine if we're running on GCE.\n            let isGCE;\n            try {\n                isGCE = await this._checkIsGCE();\n            }\n            catch (e) {\n                e.message = `Unexpected error determining execution environment: ${e.message}`;\n                throw e;\n            }\n            if (!isGCE) {\n                // We failed to find the default credentials. Bail out with an error.\n                throw new Error('Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.');\n            }\n            // For GCE, just return a default ComputeClient. It will take care of\n            // the rest.\n            options.scopes = this.scopes;\n            this.cachedCredential = new computeclient_1.Compute(options);\n            projectId = await this.getProjectId();\n            return { projectId, credential: this.cachedCredential };\n        }\n        /**\n         * Determines whether the auth layer is running on Google Compute Engine.\n         * @returns A promise that resolves with the boolean.\n         * @api private\n         */\n        async _checkIsGCE() {\n            if (this.checkIsGCE === undefined) {\n                this.checkIsGCE = await gcpMetadata.isAvailable();\n            }\n            return this.checkIsGCE;\n        }\n        /**\n         * Attempts to load default credentials from the environment variable path..\n         * @returns Promise that resolves with the OAuth2Client or null.\n         * @api private\n         */\n        async _tryGetApplicationCredentialsFromEnvironmentVariable(options) {\n            const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'] ||\n                process.env['google_application_credentials'];\n            if (!credentialsPath || credentialsPath.length === 0) {\n                return null;\n            }\n            try {\n                return this._getApplicationCredentialsFromFilePath(credentialsPath, options);\n            }\n            catch (e) {\n                e.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e.message}`;\n                throw e;\n            }\n        }\n        /**\n         * Attempts to load default credentials from a well-known file location\n         * @return Promise that resolves with the OAuth2Client or null.\n         * @api private\n         */\n        async _tryGetApplicationCredentialsFromWellKnownFile(options) {\n            // First, figure out the location of the file, depending upon the OS type.\n            let location = null;\n            if (this._isWindows()) {\n                // Windows\n                location = process.env['APPDATA'];\n            }\n            else {\n                // Linux or Mac\n                const home = process.env['HOME'];\n                if (home) {\n                    location = path.join(home, '.config');\n                }\n            }\n            // If we found the root path, expand it.\n            if (location) {\n                location = path.join(location, 'gcloud', 'application_default_credentials.json');\n                if (!fs.existsSync(location)) {\n                    location = null;\n                }\n            }\n            // The file does not exist.\n            if (!location) {\n                return null;\n            }\n            // The file seems to exist. Try to use it.\n            const client = await this._getApplicationCredentialsFromFilePath(location, options);\n            return client;\n        }\n        /**\n         * Attempts to load default credentials from a file at the given path..\n         * @param filePath The path to the file to read.\n         * @returns Promise that resolves with the OAuth2Client\n         * @api private\n         */\n        async _getApplicationCredentialsFromFilePath(filePath, options = {}) {\n            // Make sure the path looks like a string.\n            if (!filePath || filePath.length === 0) {\n                throw new Error('The file path is invalid.');\n            }\n            // Make sure there is a file at the path. lstatSync will throw if there is\n            // nothing there.\n            try {\n                // Resolve path to actual file in case of symlink. Expect a thrown error\n                // if not resolvable.\n                filePath = fs.realpathSync(filePath);\n                if (!fs.lstatSync(filePath).isFile()) {\n                    throw new Error();\n                }\n            }\n            catch (err) {\n                err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n                throw err;\n            }\n            // Now open a read stream on the file, and parse it.\n            const readStream = fs.createReadStream(filePath);\n            return this.fromStream(readStream, options);\n        }\n        /**\n         * Create a credentials instance using the given input options.\n         * @param json The input object.\n         * @param options The JWT or UserRefresh options for the client\n         * @returns JWT or UserRefresh Client with data\n         */\n        fromJSON(json, options) {\n            let client;\n            if (!json) {\n                throw new Error('Must pass in a JSON object containing the Google auth settings.');\n            }\n            options = options || {};\n            if (json.type === 'authorized_user') {\n                client = new refreshclient_1.UserRefreshClient(options);\n            }\n            else {\n                options.scopes = this.scopes;\n                client = new jwtclient_1.JWT(options);\n            }\n            client.fromJSON(json);\n            return client;\n        }\n        /**\n         * Return a JWT or UserRefreshClient from JavaScript object, caching both the\n         * object used to instantiate and the client.\n         * @param json The input object.\n         * @param options The JWT or UserRefresh options for the client\n         * @returns JWT or UserRefresh Client with data\n         */\n        _cacheClientFromJSON(json, options) {\n            let client;\n            // create either a UserRefreshClient or JWT client.\n            options = options || {};\n            if (json.type === 'authorized_user') {\n                client = new refreshclient_1.UserRefreshClient(options);\n            }\n            else {\n                options.scopes = this.scopes;\n                client = new jwtclient_1.JWT(options);\n            }\n            client.fromJSON(json);\n            // cache both raw data used to instantiate client and client itself.\n            this.jsonContent = json;\n            this.cachedCredential = client;\n            return this.cachedCredential;\n        }\n        fromStream(inputStream, optionsOrCallback = {}, callback) {\n            let options = {};\n            if (typeof optionsOrCallback === 'function') {\n                callback = optionsOrCallback;\n            }\n            else {\n                options = optionsOrCallback;\n            }\n            if (callback) {\n                this.fromStreamAsync(inputStream, options).then(r => callback(null, r), callback);\n            }\n            else {\n                return this.fromStreamAsync(inputStream, options);\n            }\n        }\n        fromStreamAsync(inputStream, options) {\n            return new Promise((resolve, reject) => {\n                if (!inputStream) {\n                    throw new Error('Must pass in a stream containing the Google auth settings.');\n                }\n                let s = '';\n                inputStream\n                    .setEncoding('utf8')\n                    .on('error', reject)\n                    .on('data', chunk => (s += chunk))\n                    .on('end', () => {\n                    try {\n                        const data = JSON.parse(s);\n                        const r = this._cacheClientFromJSON(data, options);\n                        return resolve(r);\n                    }\n                    catch (err) {\n                        return reject(err);\n                    }\n                });\n            });\n        }\n        /**\n         * Create a credentials instance using the given API key string.\n         * @param apiKey The API key string\n         * @param options An optional options object.\n         * @returns A JWT loaded from the key\n         */\n        fromAPIKey(apiKey, options) {\n            options = options || {};\n            const client = new jwtclient_1.JWT(options);\n            client.fromAPIKey(apiKey);\n            return client;\n        }\n        /**\n         * Determines whether the current operating system is Windows.\n         * @api private\n         */\n        _isWindows() {\n            const sys = os.platform();\n            if (sys && sys.length >= 3) {\n                if (sys.substring(0, 3).toLowerCase() === 'win') {\n                    return true;\n                }\n            }\n            return false;\n        }\n        /**\n         * Run the Google Cloud SDK command that prints the default project ID\n         */\n        async getDefaultServiceProjectId() {\n            return new Promise(resolve => {\n                child_process_1.exec('gcloud config config-helper --format json', (err, stdout, stderr) => {\n                    if (!err && stdout) {\n                        try {\n                            const projectId = JSON.parse(stdout).configuration.properties.core\n                                .project;\n                            resolve(projectId);\n                            return;\n                        }\n                        catch (e) {\n                            // ignore errors\n                        }\n                    }\n                    resolve(null);\n                });\n            });\n        }\n        /**\n         * Loads the project id from environment variables.\n         * @api private\n         */\n        getProductionProjectId() {\n            return (process.env['GCLOUD_PROJECT'] ||\n                process.env['GOOGLE_CLOUD_PROJECT'] ||\n                process.env['gcloud_project'] ||\n                process.env['google_cloud_project']);\n        }\n        /**\n         * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\n         * @api private\n         */\n        async getFileProjectId() {\n            if (this.cachedCredential) {\n                // Try to read the project ID from the cached credentials file\n                return this.cachedCredential.projectId;\n            }\n            // Ensure the projectId is loaded from the keyFile if available.\n            if (this.keyFilename) {\n                const creds = await this.getClient();\n                if (creds && creds.projectId) {\n                    return creds.projectId;\n                }\n            }\n            // Try to load a credentials file and read its project ID\n            const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();\n            if (r) {\n                return r.projectId;\n            }\n            else {\n                return null;\n            }\n        }\n        /**\n         * Gets the Compute Engine project ID if it can be inferred.\n         */\n        async getGCEProjectId() {\n            try {\n                const r = await gcpMetadata.project('project-id');\n                return r;\n            }\n            catch (e) {\n                // Ignore any errors\n                return null;\n            }\n        }\n        getCredentials(callback) {\n            if (callback) {\n                this.getCredentialsAsync().then(r => callback(null, r), callback);\n            }\n            else {\n                return this.getCredentialsAsync();\n            }\n        }\n        async getCredentialsAsync() {\n            await this.getClient();\n            if (this.jsonContent) {\n                const credential = {\n                    client_email: this.jsonContent.client_email,\n                    private_key: this.jsonContent.private_key,\n                };\n                return credential;\n            }\n            const isGCE = await this._checkIsGCE();\n            if (!isGCE) {\n                throw new Error('Unknown error.');\n            }\n            // For GCE, return the service account details from the metadata server\n            // NOTE: The trailing '/' at the end of service-accounts/ is very important!\n            // The GCF metadata server doesn't respect querystring params if this / is\n            // not included.\n            const data = await gcpMetadata.instance({\n                property: 'service-accounts/',\n                params: { recursive: 'true' },\n            });\n            if (!data || !data.default || !data.default.email) {\n                throw new Error('Failure from metadata server.');\n            }\n            return { client_email: data.default.email };\n        }\n        /**\n         * Automatically obtain a client based on the provided configuration.  If no\n         * options were passed, use Application Default Credentials.\n         */\n        async getClient(options) {\n            if (options) {\n                throw new Error('Passing options to getClient is forbidden in v5.0.0. Use new GoogleAuth(opts) instead.');\n            }\n            if (!this.cachedCredential) {\n                if (this.jsonContent) {\n                    this._cacheClientFromJSON(this.jsonContent, this.clientOptions);\n                }\n                else if (this.keyFilename) {\n                    const filePath = path.resolve(this.keyFilename);\n                    const stream = fs.createReadStream(filePath);\n                    await this.fromStreamAsync(stream, this.clientOptions);\n                }\n                else {\n                    await this.getApplicationDefaultAsync(this.clientOptions);\n                }\n            }\n            return this.cachedCredential;\n        }\n        /**\n         * Creates a client which will fetch an ID token for authorization.\n         * @param targetAudience the audience for the fetched ID token.\n         * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.\n         */\n        async getIdTokenClient(targetAudience) {\n            const client = await this.getClient();\n            if (!('fetchIdToken' in client)) {\n                throw new Error('Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.');\n            }\n            return new idtokenclient_1.IdTokenClient({ targetAudience, idTokenProvider: client });\n        }\n        /**\n         * Automatically obtain application default credentials, and return\n         * an access token for making requests.\n         */\n        async getAccessToken() {\n            const client = await this.getClient();\n            return (await client.getAccessToken()).token;\n        }\n        /**\n         * Obtain the HTTP headers that will provide authorization for a given\n         * request.\n         */\n        async getRequestHeaders(url) {\n            const client = await this.getClient();\n            return client.getRequestHeaders(url);\n        }\n        /**\n         * Obtain credentials for a request, then attach the appropriate headers to\n         * the request options.\n         * @param opts Axios or Request options on which to attach the headers\n         */\n        async authorizeRequest(opts) {\n            opts = opts || {};\n            const url = opts.url || opts.uri;\n            const client = await this.getClient();\n            const headers = await client.getRequestHeaders(url);\n            opts.headers = Object.assign(opts.headers || {}, headers);\n            return opts;\n        }\n        /**\n         * Automatically obtain application default credentials, and make an\n         * HTTP request using the given options.\n         * @param opts Axios request options for the HTTP request.\n         */\n        // tslint:disable-next-line no-any\n        async request(opts) {\n            const client = await this.getClient();\n            return client.request(opts);\n        }\n        /**\n         * Determine the compute environment in which the code is running.\n         */\n        getEnv() {\n            return envDetect_1.getEnv();\n        }\n        /**\n         * Sign the given data with the current private key, or go out\n         * to the IAM API to sign it.\n         * @param data The data to be signed.\n         */\n        async sign(data) {\n            const client = await this.getClient();\n            const crypto = crypto_1.createCrypto();\n            if (client instanceof jwtclient_1.JWT && client.key) {\n                const sign = await crypto.sign(client.key, data);\n                return sign;\n            }\n            const projectId = await this.getProjectId();\n            if (!projectId) {\n                throw new Error('Cannot sign data without a project ID.');\n            }\n            const creds = await this.getCredentials();\n            if (!creds.client_email) {\n                throw new Error('Cannot sign data without `client_email`.');\n            }\n            const url = `https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/${creds.client_email}:signBlob`;\n            const res = await this.request({\n                method: 'POST',\n                url,\n                data: {\n                    payload: crypto.encodeBase64StringUtf8(data),\n                },\n            });\n            return res.data.signedBlob;\n        }\n    }\n    /**\n     * Export DefaultTransporter as a static property of the class.\n     */\n    GoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;\n    return GoogleAuth;\n})();\nexports.GoogleAuth = GoogleAuth;\n//# sourceMappingURL=googleauth.js.map"]},"metadata":{},"sourceType":"script"}