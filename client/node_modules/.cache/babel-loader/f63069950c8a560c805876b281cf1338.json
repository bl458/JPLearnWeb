{"ast":null,"code":"import { ROMANIZATION_SYSTEM, getStrType, patchTokens, isHiragana, isKatakana, isKana, isKanji, isJapanese, hasHiragana, hasKatakana, hasKana, hasKanji, hasJapanese, toRawHiragana, toRawKatakana, toRawRomaji, kanaToHiragna, kanaToKatakana, kanaToRomaji } from \"./util\";\n/**\n * Kuroshiro Class\n */\n\nclass Kuroshiro {\n  /**\n   * Constructor\n   * @constructs Kuroshiro\n   */\n  constructor() {\n    this._analyzer = null;\n  }\n  /**\n   * Initialize Kuroshiro\n   * @memberOf Kuroshiro\n   * @instance\n   * @returns {Promise} Promise object represents the result of initialization\n   */\n\n\n  async init(analyzer) {\n    if (!analyzer || typeof analyzer !== \"object\" || typeof analyzer.init !== \"function\" || typeof analyzer.parse !== \"function\") {\n      throw new Error(\"Invalid initialization parameter.\");\n    } else if (this._analyzer == null) {\n      try {\n        await analyzer.init();\n        this._analyzer = analyzer;\n      } catch (err) {\n        throw err;\n      }\n    } else {\n      throw new Error(\"Kuroshiro has already been initialized.\");\n    }\n  }\n  /**\n   * Convert given string to target syllabary with options available\n   * @memberOf Kuroshiro\n   * @instance\n   * @param {string} str Given String\n   * @param {Object} [options] Settings Object\n   * @param {string} [options.to=\"hiragana\"] Target syllabary [\"hiragana\"|\"katakana\"|\"romaji\"]\n   * @param {string} [options.mode=\"normal\"] Convert mode [\"normal\"|\"spaced\"|\"okurigana\"|\"furigana\"]\n   * @param {string} [options.romajiSystem=\"hepburn\"] Romanization System [\"nippon\"|\"passport\"|\"hepburn\"]\n   * @param {string} [options.delimiter_start=\"(\"] Delimiter(Start)\n   * @param {string} [options.delimiter_end=\")\"] Delimiter(End)\n   * @returns {Promise} Promise object represents the result of conversion\n   */\n\n\n  async convert(str, options) {\n    options = options || {};\n    options.to = options.to || \"hiragana\";\n    options.mode = options.mode || \"normal\";\n    options.romajiSystem = options.romajiSystem || ROMANIZATION_SYSTEM.HEPBURN;\n    options.delimiter_start = options.delimiter_start || \"(\";\n    options.delimiter_end = options.delimiter_end || \")\";\n    str = str || \"\";\n\n    if ([\"hiragana\", \"katakana\", \"romaji\"].indexOf(options.to) === -1) {\n      throw new Error(\"Invalid Target Syllabary.\");\n    }\n\n    if ([\"normal\", \"spaced\", \"okurigana\", \"furigana\"].indexOf(options.mode) === -1) {\n      throw new Error(\"Invalid Conversion Mode.\");\n    }\n\n    const ROMAJI_SYSTEMS = Object.keys(ROMANIZATION_SYSTEM).map(e => ROMANIZATION_SYSTEM[e]);\n\n    if (ROMAJI_SYSTEMS.indexOf(options.romajiSystem) === -1) {\n      throw new Error(\"Invalid Romanization System.\");\n    }\n\n    const rawTokens = await this._analyzer.parse(str);\n    const tokens = patchTokens(rawTokens);\n\n    if (options.mode === \"normal\" || options.mode === \"spaced\") {\n      switch (options.to) {\n        case \"katakana\":\n          if (options.mode === \"normal\") {\n            return tokens.map(token => token.reading).join(\"\");\n          }\n\n          return tokens.map(token => token.reading).join(\" \");\n\n        case \"romaji\":\n          const romajiConv = token => {\n            let preToken;\n\n            if (hasJapanese(token.surface_form)) {\n              preToken = token.pronunciation || token.reading;\n            } else {\n              preToken = token.surface_form;\n            }\n\n            return toRawRomaji(preToken, options.romajiSystem);\n          };\n\n          if (options.mode === \"normal\") {\n            return tokens.map(romajiConv).join(\"\");\n          }\n\n          return tokens.map(romajiConv).join(\" \");\n\n        case \"hiragana\":\n          for (let hi = 0; hi < tokens.length; hi++) {\n            if (hasKanji(tokens[hi].surface_form)) {\n              if (!hasKatakana(tokens[hi].surface_form)) {\n                tokens[hi].reading = toRawHiragana(tokens[hi].reading);\n              } else {\n                // handle katakana-kanji-mixed tokens\n                tokens[hi].reading = toRawHiragana(tokens[hi].reading);\n                let tmp = \"\";\n                let hpattern = \"\";\n\n                for (let hc = 0; hc < tokens[hi].surface_form.length; hc++) {\n                  if (isKanji(tokens[hi].surface_form[hc])) {\n                    hpattern += \"(.*)\";\n                  } else {\n                    hpattern += isKatakana(tokens[hi].surface_form[hc]) ? toRawHiragana(tokens[hi].surface_form[hc]) : tokens[hi].surface_form[hc];\n                  }\n                }\n\n                const hreg = new RegExp(hpattern);\n                const hmatches = hreg.exec(tokens[hi].reading);\n\n                if (hmatches) {\n                  let pickKJ = 0;\n\n                  for (let hc1 = 0; hc1 < tokens[hi].surface_form.length; hc1++) {\n                    if (isKanji(tokens[hi].surface_form[hc1])) {\n                      tmp += hmatches[pickKJ + 1];\n                      pickKJ++;\n                    } else {\n                      tmp += tokens[hi].surface_form[hc1];\n                    }\n                  }\n\n                  tokens[hi].reading = tmp;\n                }\n              }\n            } else {\n              tokens[hi].reading = tokens[hi].surface_form;\n            }\n          }\n\n          if (options.mode === \"normal\") {\n            return tokens.map(token => token.reading).join(\"\");\n          }\n\n          return tokens.map(token => token.reading).join(\" \");\n\n        default:\n          throw new Error(\"Unknown option.to param\");\n      }\n    } else if (options.mode === \"okurigana\" || options.mode === \"furigana\") {\n      const notations = []; // [basic, basic_type[1=kanji,2=kana,3=others], notation, pronunciation]\n\n      for (let i = 0; i < tokens.length; i++) {\n        const strType = getStrType(tokens[i].surface_form);\n\n        switch (strType) {\n          case 0:\n            notations.push([tokens[i].surface_form, 1, toRawHiragana(tokens[i].reading), tokens[i].pronunciation || tokens[i].reading]);\n            break;\n\n          case 1:\n            let pattern = \"\";\n            let isLastTokenKanji = false;\n            const subs = []; // recognize kanjis and group them\n\n            for (let c = 0; c < tokens[i].surface_form.length; c++) {\n              if (isKanji(tokens[i].surface_form[c])) {\n                if (!isLastTokenKanji) {\n                  // ignore successive kanji tokens (#10)\n                  isLastTokenKanji = true;\n                  pattern += \"(.*)\";\n                  subs.push(tokens[i].surface_form[c]);\n                } else {\n                  subs[subs.length - 1] += tokens[i].surface_form[c];\n                }\n              } else {\n                isLastTokenKanji = false;\n                subs.push(tokens[i].surface_form[c]);\n                pattern += isKatakana(tokens[i].surface_form[c]) ? toRawHiragana(tokens[i].surface_form[c]) : tokens[i].surface_form[c];\n              }\n            }\n\n            const reg = new RegExp(`^${pattern}$`);\n            const matches = reg.exec(toRawHiragana(tokens[i].reading));\n\n            if (matches) {\n              let pickKanji = 1;\n\n              for (let c1 = 0; c1 < subs.length; c1++) {\n                if (isKanji(subs[c1][0])) {\n                  notations.push([subs[c1], 1, matches[pickKanji], toRawKatakana(matches[pickKanji])]);\n                  pickKanji += 1;\n                } else {\n                  notations.push([subs[c1], 2, toRawHiragana(subs[c1]), toRawKatakana(subs[c1])]);\n                }\n              }\n            } else {\n              notations.push([tokens[i].surface_form, 1, toRawHiragana(tokens[i].reading), tokens[i].pronunciation || tokens[i].reading]);\n            }\n\n            break;\n\n          case 2:\n            for (let c2 = 0; c2 < tokens[i].surface_form.length; c2++) {\n              notations.push([tokens[i].surface_form[c2], 2, toRawHiragana(tokens[i].reading[c2]), tokens[i].pronunciation && tokens[i].pronunciation[c2] || tokens[i].reading[c2]]);\n            }\n\n            break;\n\n          case 3:\n            for (let c3 = 0; c3 < tokens[i].surface_form.length; c3++) {\n              notations.push([tokens[i].surface_form[c3], 3, tokens[i].surface_form[c3], tokens[i].surface_form[c3]]);\n            }\n\n            break;\n\n          default:\n            throw new Error(\"Unknown strType\");\n        }\n      }\n\n      let result = \"\";\n\n      switch (options.to) {\n        case \"katakana\":\n          if (options.mode === \"okurigana\") {\n            for (let n0 = 0; n0 < notations.length; n0++) {\n              if (notations[n0][1] !== 1) {\n                result += notations[n0][0];\n              } else {\n                result += notations[n0][0] + options.delimiter_start + toRawKatakana(notations[n0][2]) + options.delimiter_end;\n              }\n            }\n          } else {\n            // furigana\n            for (let n1 = 0; n1 < notations.length; n1++) {\n              if (notations[n1][1] !== 1) {\n                result += notations[n1][0];\n              } else {\n                result += `<ruby>${notations[n1][0]}<rp>${options.delimiter_start}</rp><rt>${toRawKatakana(notations[n1][2])}</rt><rp>${options.delimiter_end}</rp></ruby>`;\n              }\n            }\n          }\n\n          return result;\n\n        case \"romaji\":\n          if (options.mode === \"okurigana\") {\n            for (let n2 = 0; n2 < notations.length; n2++) {\n              if (notations[n2][1] !== 1) {\n                result += notations[n2][0];\n              } else {\n                result += notations[n2][0] + options.delimiter_start + toRawRomaji(notations[n2][3], options.romajiSystem) + options.delimiter_end;\n              }\n            }\n          } else {\n            // furigana\n            result += \"<ruby>\";\n\n            for (let n3 = 0; n3 < notations.length; n3++) {\n              result += `${notations[n3][0]}<rp>${options.delimiter_start}</rp><rt>${toRawRomaji(notations[n3][3], options.romajiSystem)}</rt><rp>${options.delimiter_end}</rp>`;\n            }\n\n            result += \"</ruby>\";\n          }\n\n          return result;\n\n        case \"hiragana\":\n          if (options.mode === \"okurigana\") {\n            for (let n4 = 0; n4 < notations.length; n4++) {\n              if (notations[n4][1] !== 1) {\n                result += notations[n4][0];\n              } else {\n                result += notations[n4][0] + options.delimiter_start + notations[n4][2] + options.delimiter_end;\n              }\n            }\n          } else {\n            // furigana\n            for (let n5 = 0; n5 < notations.length; n5++) {\n              if (notations[n5][1] !== 1) {\n                result += notations[n5][0];\n              } else {\n                result += `<ruby>${notations[n5][0]}<rp>${options.delimiter_start}</rp><rt>${notations[n5][2]}</rt><rp>${options.delimiter_end}</rp></ruby>`;\n              }\n            }\n          }\n\n          return result;\n\n        default:\n          throw new Error(\"Invalid Target Syllabary.\");\n      }\n    }\n  }\n\n}\n\nconst Util = {\n  isHiragana,\n  isKatakana,\n  isKana,\n  isKanji,\n  isJapanese,\n  hasHiragana,\n  hasKatakana,\n  hasKana,\n  hasKanji,\n  hasJapanese,\n  kanaToHiragna,\n  kanaToKatakana,\n  kanaToRomaji\n};\nKuroshiro.Util = Util;\nexport default Kuroshiro;","map":{"version":3,"sources":["/home/byungchan/Projects/react/JapaneseQuiz/client/node_modules/kuroshiro/src/core.js"],"names":["ROMANIZATION_SYSTEM","getStrType","patchTokens","isHiragana","isKatakana","isKana","isKanji","isJapanese","hasHiragana","hasKatakana","hasKana","hasKanji","hasJapanese","toRawHiragana","toRawKatakana","toRawRomaji","kanaToHiragna","kanaToKatakana","kanaToRomaji","Kuroshiro","constructor","_analyzer","init","analyzer","parse","Error","err","convert","str","options","to","mode","romajiSystem","HEPBURN","delimiter_start","delimiter_end","indexOf","ROMAJI_SYSTEMS","Object","keys","map","e","rawTokens","tokens","token","reading","join","romajiConv","preToken","surface_form","pronunciation","hi","length","tmp","hpattern","hc","hreg","RegExp","hmatches","exec","pickKJ","hc1","notations","i","strType","push","pattern","isLastTokenKanji","subs","c","reg","matches","pickKanji","c1","c2","c3","result","n0","n1","n2","n3","n4","n5","Util"],"mappings":"AAAA,SACIA,mBADJ,EAEIC,UAFJ,EAGIC,WAHJ,EAIIC,UAJJ,EAKIC,UALJ,EAMIC,MANJ,EAOIC,OAPJ,EAQIC,UARJ,EASIC,WATJ,EAUIC,WAVJ,EAWIC,OAXJ,EAYIC,QAZJ,EAaIC,WAbJ,EAcIC,aAdJ,EAeIC,aAfJ,EAgBIC,WAhBJ,EAiBIC,aAjBJ,EAkBIC,cAlBJ,EAmBIC,YAnBJ,QAoBO,QApBP;AAsBA;;;;AAGA,MAAMC,SAAN,CAAgB;AACZ;;;;AAIAC,EAAAA,WAAW,GAAG;AACV,SAAKC,SAAL,GAAiB,IAAjB;AACH;AAED;;;;;;;;AAMA,QAAMC,IAAN,CAAWC,QAAX,EAAqB;AACjB,QAAI,CAACA,QAAD,IAAa,OAAOA,QAAP,KAAoB,QAAjC,IAA6C,OAAOA,QAAQ,CAACD,IAAhB,KAAyB,UAAtE,IAAoF,OAAOC,QAAQ,CAACC,KAAhB,KAA0B,UAAlH,EAA8H;AAC1H,YAAM,IAAIC,KAAJ,CAAU,mCAAV,CAAN;AACH,KAFD,MAGK,IAAI,KAAKJ,SAAL,IAAkB,IAAtB,EAA4B;AAC7B,UAAI;AACA,cAAME,QAAQ,CAACD,IAAT,EAAN;AACA,aAAKD,SAAL,GAAiBE,QAAjB;AACH,OAHD,CAIA,OAAOG,GAAP,EAAY;AACR,cAAMA,GAAN;AACH;AACJ,KARI,MASA;AACD,YAAM,IAAID,KAAJ,CAAU,yCAAV,CAAN;AACH;AACJ;AAED;;;;;;;;;;;;;;;AAaA,QAAME,OAAN,CAAcC,GAAd,EAAmBC,OAAnB,EAA4B;AACxBA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACAA,IAAAA,OAAO,CAACC,EAAR,GAAaD,OAAO,CAACC,EAAR,IAAc,UAA3B;AACAD,IAAAA,OAAO,CAACE,IAAR,GAAeF,OAAO,CAACE,IAAR,IAAgB,QAA/B;AACAF,IAAAA,OAAO,CAACG,YAAR,GAAuBH,OAAO,CAACG,YAAR,IAAwBhC,mBAAmB,CAACiC,OAAnE;AACAJ,IAAAA,OAAO,CAACK,eAAR,GAA0BL,OAAO,CAACK,eAAR,IAA2B,GAArD;AACAL,IAAAA,OAAO,CAACM,aAAR,GAAwBN,OAAO,CAACM,aAAR,IAAyB,GAAjD;AACAP,IAAAA,GAAG,GAAGA,GAAG,IAAI,EAAb;;AAEA,QAAI,CAAC,UAAD,EAAa,UAAb,EAAyB,QAAzB,EAAmCQ,OAAnC,CAA2CP,OAAO,CAACC,EAAnD,MAA2D,CAAC,CAAhE,EAAmE;AAC/D,YAAM,IAAIL,KAAJ,CAAU,2BAAV,CAAN;AACH;;AAED,QAAI,CAAC,QAAD,EAAW,QAAX,EAAqB,WAArB,EAAkC,UAAlC,EAA8CW,OAA9C,CAAsDP,OAAO,CAACE,IAA9D,MAAwE,CAAC,CAA7E,EAAgF;AAC5E,YAAM,IAAIN,KAAJ,CAAU,0BAAV,CAAN;AACH;;AAED,UAAMY,cAAc,GAAGC,MAAM,CAACC,IAAP,CAAYvC,mBAAZ,EAAiCwC,GAAjC,CAAqCC,CAAC,IAAIzC,mBAAmB,CAACyC,CAAD,CAA7D,CAAvB;;AACA,QAAIJ,cAAc,CAACD,OAAf,CAAuBP,OAAO,CAACG,YAA/B,MAAiD,CAAC,CAAtD,EAAyD;AACrD,YAAM,IAAIP,KAAJ,CAAU,8BAAV,CAAN;AACH;;AAED,UAAMiB,SAAS,GAAG,MAAM,KAAKrB,SAAL,CAAeG,KAAf,CAAqBI,GAArB,CAAxB;AACA,UAAMe,MAAM,GAAGzC,WAAW,CAACwC,SAAD,CAA1B;;AAEA,QAAIb,OAAO,CAACE,IAAR,KAAiB,QAAjB,IAA6BF,OAAO,CAACE,IAAR,KAAiB,QAAlD,EAA4D;AACxD,cAAQF,OAAO,CAACC,EAAhB;AACI,aAAK,UAAL;AACI,cAAID,OAAO,CAACE,IAAR,KAAiB,QAArB,EAA+B;AAC3B,mBAAOY,MAAM,CAACH,GAAP,CAAWI,KAAK,IAAIA,KAAK,CAACC,OAA1B,EAAmCC,IAAnC,CAAwC,EAAxC,CAAP;AACH;;AACD,iBAAOH,MAAM,CAACH,GAAP,CAAWI,KAAK,IAAIA,KAAK,CAACC,OAA1B,EAAmCC,IAAnC,CAAwC,GAAxC,CAAP;;AACJ,aAAK,QAAL;AACI,gBAAMC,UAAU,GAAIH,KAAD,IAAW;AAC1B,gBAAII,QAAJ;;AACA,gBAAIpC,WAAW,CAACgC,KAAK,CAACK,YAAP,CAAf,EAAqC;AACjCD,cAAAA,QAAQ,GAAGJ,KAAK,CAACM,aAAN,IAAuBN,KAAK,CAACC,OAAxC;AACH,aAFD,MAGK;AACDG,cAAAA,QAAQ,GAAGJ,KAAK,CAACK,YAAjB;AACH;;AACD,mBAAOlC,WAAW,CAACiC,QAAD,EAAWnB,OAAO,CAACG,YAAnB,CAAlB;AACH,WATD;;AAUA,cAAIH,OAAO,CAACE,IAAR,KAAiB,QAArB,EAA+B;AAC3B,mBAAOY,MAAM,CAACH,GAAP,CAAWO,UAAX,EAAuBD,IAAvB,CAA4B,EAA5B,CAAP;AACH;;AACD,iBAAOH,MAAM,CAACH,GAAP,CAAWO,UAAX,EAAuBD,IAAvB,CAA4B,GAA5B,CAAP;;AACJ,aAAK,UAAL;AACI,eAAK,IAAIK,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGR,MAAM,CAACS,MAA7B,EAAqCD,EAAE,EAAvC,EAA2C;AACvC,gBAAIxC,QAAQ,CAACgC,MAAM,CAACQ,EAAD,CAAN,CAAWF,YAAZ,CAAZ,EAAuC;AACnC,kBAAI,CAACxC,WAAW,CAACkC,MAAM,CAACQ,EAAD,CAAN,CAAWF,YAAZ,CAAhB,EAA2C;AACvCN,gBAAAA,MAAM,CAACQ,EAAD,CAAN,CAAWN,OAAX,GAAqBhC,aAAa,CAAC8B,MAAM,CAACQ,EAAD,CAAN,CAAWN,OAAZ,CAAlC;AACH,eAFD,MAGK;AACD;AACAF,gBAAAA,MAAM,CAACQ,EAAD,CAAN,CAAWN,OAAX,GAAqBhC,aAAa,CAAC8B,MAAM,CAACQ,EAAD,CAAN,CAAWN,OAAZ,CAAlC;AACA,oBAAIQ,GAAG,GAAG,EAAV;AACA,oBAAIC,QAAQ,GAAG,EAAf;;AACA,qBAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGZ,MAAM,CAACQ,EAAD,CAAN,CAAWF,YAAX,CAAwBG,MAA9C,EAAsDG,EAAE,EAAxD,EAA4D;AACxD,sBAAIjD,OAAO,CAACqC,MAAM,CAACQ,EAAD,CAAN,CAAWF,YAAX,CAAwBM,EAAxB,CAAD,CAAX,EAA0C;AACtCD,oBAAAA,QAAQ,IAAI,MAAZ;AACH,mBAFD,MAGK;AACDA,oBAAAA,QAAQ,IAAIlD,UAAU,CAACuC,MAAM,CAACQ,EAAD,CAAN,CAAWF,YAAX,CAAwBM,EAAxB,CAAD,CAAV,GAA0C1C,aAAa,CAAC8B,MAAM,CAACQ,EAAD,CAAN,CAAWF,YAAX,CAAwBM,EAAxB,CAAD,CAAvD,GAAuFZ,MAAM,CAACQ,EAAD,CAAN,CAAWF,YAAX,CAAwBM,EAAxB,CAAnG;AACH;AACJ;;AACD,sBAAMC,IAAI,GAAG,IAAIC,MAAJ,CAAWH,QAAX,CAAb;AACA,sBAAMI,QAAQ,GAAGF,IAAI,CAACG,IAAL,CAAUhB,MAAM,CAACQ,EAAD,CAAN,CAAWN,OAArB,CAAjB;;AACA,oBAAIa,QAAJ,EAAc;AACV,sBAAIE,MAAM,GAAG,CAAb;;AACA,uBAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGlB,MAAM,CAACQ,EAAD,CAAN,CAAWF,YAAX,CAAwBG,MAAhD,EAAwDS,GAAG,EAA3D,EAA+D;AAC3D,wBAAIvD,OAAO,CAACqC,MAAM,CAACQ,EAAD,CAAN,CAAWF,YAAX,CAAwBY,GAAxB,CAAD,CAAX,EAA2C;AACvCR,sBAAAA,GAAG,IAAIK,QAAQ,CAACE,MAAM,GAAG,CAAV,CAAf;AACAA,sBAAAA,MAAM;AACT,qBAHD,MAIK;AACDP,sBAAAA,GAAG,IAAIV,MAAM,CAACQ,EAAD,CAAN,CAAWF,YAAX,CAAwBY,GAAxB,CAAP;AACH;AACJ;;AACDlB,kBAAAA,MAAM,CAACQ,EAAD,CAAN,CAAWN,OAAX,GAAqBQ,GAArB;AACH;AACJ;AACJ,aAjCD,MAkCK;AACDV,cAAAA,MAAM,CAACQ,EAAD,CAAN,CAAWN,OAAX,GAAqBF,MAAM,CAACQ,EAAD,CAAN,CAAWF,YAAhC;AACH;AACJ;;AACD,cAAIpB,OAAO,CAACE,IAAR,KAAiB,QAArB,EAA+B;AAC3B,mBAAOY,MAAM,CAACH,GAAP,CAAWI,KAAK,IAAIA,KAAK,CAACC,OAA1B,EAAmCC,IAAnC,CAAwC,EAAxC,CAAP;AACH;;AACD,iBAAOH,MAAM,CAACH,GAAP,CAAWI,KAAK,IAAIA,KAAK,CAACC,OAA1B,EAAmCC,IAAnC,CAAwC,GAAxC,CAAP;;AACJ;AACI,gBAAM,IAAIrB,KAAJ,CAAU,yBAAV,CAAN;AAlER;AAoEH,KArED,MAsEK,IAAII,OAAO,CAACE,IAAR,KAAiB,WAAjB,IAAgCF,OAAO,CAACE,IAAR,KAAiB,UAArD,EAAiE;AAClE,YAAM+B,SAAS,GAAG,EAAlB,CADkE,CAC5C;;AACtB,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpB,MAAM,CAACS,MAA3B,EAAmCW,CAAC,EAApC,EAAwC;AACpC,cAAMC,OAAO,GAAG/D,UAAU,CAAC0C,MAAM,CAACoB,CAAD,CAAN,CAAUd,YAAX,CAA1B;;AACA,gBAAQe,OAAR;AACI,eAAK,CAAL;AACIF,YAAAA,SAAS,CAACG,IAAV,CAAe,CAACtB,MAAM,CAACoB,CAAD,CAAN,CAAUd,YAAX,EAAyB,CAAzB,EAA4BpC,aAAa,CAAC8B,MAAM,CAACoB,CAAD,CAAN,CAAUlB,OAAX,CAAzC,EAA8DF,MAAM,CAACoB,CAAD,CAAN,CAAUb,aAAV,IAA2BP,MAAM,CAACoB,CAAD,CAAN,CAAUlB,OAAnG,CAAf;AACA;;AACJ,eAAK,CAAL;AACI,gBAAIqB,OAAO,GAAG,EAAd;AACA,gBAAIC,gBAAgB,GAAG,KAAvB;AACA,kBAAMC,IAAI,GAAG,EAAb,CAHJ,CAGqB;;AACjB,iBAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1B,MAAM,CAACoB,CAAD,CAAN,CAAUd,YAAV,CAAuBG,MAA3C,EAAmDiB,CAAC,EAApD,EAAwD;AACpD,kBAAI/D,OAAO,CAACqC,MAAM,CAACoB,CAAD,CAAN,CAAUd,YAAV,CAAuBoB,CAAvB,CAAD,CAAX,EAAwC;AACpC,oBAAI,CAACF,gBAAL,EAAuB;AAAE;AACrBA,kBAAAA,gBAAgB,GAAG,IAAnB;AACAD,kBAAAA,OAAO,IAAI,MAAX;AACAE,kBAAAA,IAAI,CAACH,IAAL,CAAUtB,MAAM,CAACoB,CAAD,CAAN,CAAUd,YAAV,CAAuBoB,CAAvB,CAAV;AACH,iBAJD,MAKK;AACDD,kBAAAA,IAAI,CAACA,IAAI,CAAChB,MAAL,GAAc,CAAf,CAAJ,IAAyBT,MAAM,CAACoB,CAAD,CAAN,CAAUd,YAAV,CAAuBoB,CAAvB,CAAzB;AACH;AACJ,eATD,MAUK;AACDF,gBAAAA,gBAAgB,GAAG,KAAnB;AACAC,gBAAAA,IAAI,CAACH,IAAL,CAAUtB,MAAM,CAACoB,CAAD,CAAN,CAAUd,YAAV,CAAuBoB,CAAvB,CAAV;AACAH,gBAAAA,OAAO,IAAI9D,UAAU,CAACuC,MAAM,CAACoB,CAAD,CAAN,CAAUd,YAAV,CAAuBoB,CAAvB,CAAD,CAAV,GAAwCxD,aAAa,CAAC8B,MAAM,CAACoB,CAAD,CAAN,CAAUd,YAAV,CAAuBoB,CAAvB,CAAD,CAArD,GAAmF1B,MAAM,CAACoB,CAAD,CAAN,CAAUd,YAAV,CAAuBoB,CAAvB,CAA9F;AACH;AACJ;;AACD,kBAAMC,GAAG,GAAG,IAAIb,MAAJ,CAAY,IAAGS,OAAQ,GAAvB,CAAZ;AACA,kBAAMK,OAAO,GAAGD,GAAG,CAACX,IAAJ,CAAS9C,aAAa,CAAC8B,MAAM,CAACoB,CAAD,CAAN,CAAUlB,OAAX,CAAtB,CAAhB;;AACA,gBAAI0B,OAAJ,EAAa;AACT,kBAAIC,SAAS,GAAG,CAAhB;;AACA,mBAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGL,IAAI,CAAChB,MAA3B,EAAmCqB,EAAE,EAArC,EAAyC;AACrC,oBAAInE,OAAO,CAAC8D,IAAI,CAACK,EAAD,CAAJ,CAAS,CAAT,CAAD,CAAX,EAA0B;AACtBX,kBAAAA,SAAS,CAACG,IAAV,CAAe,CAACG,IAAI,CAACK,EAAD,CAAL,EAAW,CAAX,EAAcF,OAAO,CAACC,SAAD,CAArB,EAAkC1D,aAAa,CAACyD,OAAO,CAACC,SAAD,CAAR,CAA/C,CAAf;AACAA,kBAAAA,SAAS,IAAI,CAAb;AACH,iBAHD,MAIK;AACDV,kBAAAA,SAAS,CAACG,IAAV,CAAe,CAACG,IAAI,CAACK,EAAD,CAAL,EAAW,CAAX,EAAc5D,aAAa,CAACuD,IAAI,CAACK,EAAD,CAAL,CAA3B,EAAuC3D,aAAa,CAACsD,IAAI,CAACK,EAAD,CAAL,CAApD,CAAf;AACH;AACJ;AACJ,aAXD,MAYK;AACDX,cAAAA,SAAS,CAACG,IAAV,CAAe,CAACtB,MAAM,CAACoB,CAAD,CAAN,CAAUd,YAAX,EAAyB,CAAzB,EAA4BpC,aAAa,CAAC8B,MAAM,CAACoB,CAAD,CAAN,CAAUlB,OAAX,CAAzC,EAA8DF,MAAM,CAACoB,CAAD,CAAN,CAAUb,aAAV,IAA2BP,MAAM,CAACoB,CAAD,CAAN,CAAUlB,OAAnG,CAAf;AACH;;AACD;;AACJ,eAAK,CAAL;AACI,iBAAK,IAAI6B,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAG/B,MAAM,CAACoB,CAAD,CAAN,CAAUd,YAAV,CAAuBG,MAA7C,EAAqDsB,EAAE,EAAvD,EAA2D;AACvDZ,cAAAA,SAAS,CAACG,IAAV,CAAe,CAACtB,MAAM,CAACoB,CAAD,CAAN,CAAUd,YAAV,CAAuByB,EAAvB,CAAD,EAA6B,CAA7B,EAAgC7D,aAAa,CAAC8B,MAAM,CAACoB,CAAD,CAAN,CAAUlB,OAAV,CAAkB6B,EAAlB,CAAD,CAA7C,EAAuE/B,MAAM,CAACoB,CAAD,CAAN,CAAUb,aAAV,IAA2BP,MAAM,CAACoB,CAAD,CAAN,CAAUb,aAAV,CAAwBwB,EAAxB,CAA5B,IAA4D/B,MAAM,CAACoB,CAAD,CAAN,CAAUlB,OAAV,CAAkB6B,EAAlB,CAAlI,CAAf;AACH;;AACD;;AACJ,eAAK,CAAL;AACI,iBAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGhC,MAAM,CAACoB,CAAD,CAAN,CAAUd,YAAV,CAAuBG,MAA7C,EAAqDuB,EAAE,EAAvD,EAA2D;AACvDb,cAAAA,SAAS,CAACG,IAAV,CAAe,CAACtB,MAAM,CAACoB,CAAD,CAAN,CAAUd,YAAV,CAAuB0B,EAAvB,CAAD,EAA6B,CAA7B,EAAgChC,MAAM,CAACoB,CAAD,CAAN,CAAUd,YAAV,CAAuB0B,EAAvB,CAAhC,EAA4DhC,MAAM,CAACoB,CAAD,CAAN,CAAUd,YAAV,CAAuB0B,EAAvB,CAA5D,CAAf;AACH;;AACD;;AACJ;AACI,kBAAM,IAAIlD,KAAJ,CAAU,iBAAV,CAAN;AAtDR;AAwDH;;AACD,UAAImD,MAAM,GAAG,EAAb;;AACA,cAAQ/C,OAAO,CAACC,EAAhB;AACI,aAAK,UAAL;AACI,cAAID,OAAO,CAACE,IAAR,KAAiB,WAArB,EAAkC;AAC9B,iBAAK,IAAI8C,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGf,SAAS,CAACV,MAAhC,EAAwCyB,EAAE,EAA1C,EAA8C;AAC1C,kBAAIf,SAAS,CAACe,EAAD,CAAT,CAAc,CAAd,MAAqB,CAAzB,EAA4B;AACxBD,gBAAAA,MAAM,IAAId,SAAS,CAACe,EAAD,CAAT,CAAc,CAAd,CAAV;AACH,eAFD,MAGK;AACDD,gBAAAA,MAAM,IAAId,SAAS,CAACe,EAAD,CAAT,CAAc,CAAd,IAAmBhD,OAAO,CAACK,eAA3B,GAA6CpB,aAAa,CAACgD,SAAS,CAACe,EAAD,CAAT,CAAc,CAAd,CAAD,CAA1D,GAA+EhD,OAAO,CAACM,aAAjG;AACH;AACJ;AACJ,WATD,MAUK;AAAE;AACH,iBAAK,IAAI2C,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGhB,SAAS,CAACV,MAAhC,EAAwC0B,EAAE,EAA1C,EAA8C;AAC1C,kBAAIhB,SAAS,CAACgB,EAAD,CAAT,CAAc,CAAd,MAAqB,CAAzB,EAA4B;AACxBF,gBAAAA,MAAM,IAAId,SAAS,CAACgB,EAAD,CAAT,CAAc,CAAd,CAAV;AACH,eAFD,MAGK;AACDF,gBAAAA,MAAM,IAAK,SAAQd,SAAS,CAACgB,EAAD,CAAT,CAAc,CAAd,CAAiB,OAAMjD,OAAO,CAACK,eAAgB,YAAWpB,aAAa,CAACgD,SAAS,CAACgB,EAAD,CAAT,CAAc,CAAd,CAAD,CAAmB,YAAWjD,OAAO,CAACM,aAAc,cAA9I;AACH;AACJ;AACJ;;AACD,iBAAOyC,MAAP;;AACJ,aAAK,QAAL;AACI,cAAI/C,OAAO,CAACE,IAAR,KAAiB,WAArB,EAAkC;AAC9B,iBAAK,IAAIgD,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGjB,SAAS,CAACV,MAAhC,EAAwC2B,EAAE,EAA1C,EAA8C;AAC1C,kBAAIjB,SAAS,CAACiB,EAAD,CAAT,CAAc,CAAd,MAAqB,CAAzB,EAA4B;AACxBH,gBAAAA,MAAM,IAAId,SAAS,CAACiB,EAAD,CAAT,CAAc,CAAd,CAAV;AACH,eAFD,MAGK;AACDH,gBAAAA,MAAM,IAAId,SAAS,CAACiB,EAAD,CAAT,CAAc,CAAd,IAAmBlD,OAAO,CAACK,eAA3B,GAA6CnB,WAAW,CAAC+C,SAAS,CAACiB,EAAD,CAAT,CAAc,CAAd,CAAD,EAAmBlD,OAAO,CAACG,YAA3B,CAAxD,GAAmGH,OAAO,CAACM,aAArH;AACH;AACJ;AACJ,WATD,MAUK;AAAE;AACHyC,YAAAA,MAAM,IAAI,QAAV;;AACA,iBAAK,IAAII,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGlB,SAAS,CAACV,MAAhC,EAAwC4B,EAAE,EAA1C,EAA8C;AAC1CJ,cAAAA,MAAM,IAAK,GAAEd,SAAS,CAACkB,EAAD,CAAT,CAAc,CAAd,CAAiB,OAAMnD,OAAO,CAACK,eAAgB,YAAWnB,WAAW,CAAC+C,SAAS,CAACkB,EAAD,CAAT,CAAc,CAAd,CAAD,EAAmBnD,OAAO,CAACG,YAA3B,CAAyC,YAAWH,OAAO,CAACM,aAAc,OAA5J;AACH;;AACDyC,YAAAA,MAAM,IAAI,SAAV;AACH;;AACD,iBAAOA,MAAP;;AACJ,aAAK,UAAL;AACI,cAAI/C,OAAO,CAACE,IAAR,KAAiB,WAArB,EAAkC;AAC9B,iBAAK,IAAIkD,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGnB,SAAS,CAACV,MAAhC,EAAwC6B,EAAE,EAA1C,EAA8C;AAC1C,kBAAInB,SAAS,CAACmB,EAAD,CAAT,CAAc,CAAd,MAAqB,CAAzB,EAA4B;AACxBL,gBAAAA,MAAM,IAAId,SAAS,CAACmB,EAAD,CAAT,CAAc,CAAd,CAAV;AACH,eAFD,MAGK;AACDL,gBAAAA,MAAM,IAAId,SAAS,CAACmB,EAAD,CAAT,CAAc,CAAd,IAAmBpD,OAAO,CAACK,eAA3B,GAA6C4B,SAAS,CAACmB,EAAD,CAAT,CAAc,CAAd,CAA7C,GAAgEpD,OAAO,CAACM,aAAlF;AACH;AACJ;AACJ,WATD,MAUK;AAAE;AACH,iBAAK,IAAI+C,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGpB,SAAS,CAACV,MAAhC,EAAwC8B,EAAE,EAA1C,EAA8C;AAC1C,kBAAIpB,SAAS,CAACoB,EAAD,CAAT,CAAc,CAAd,MAAqB,CAAzB,EAA4B;AACxBN,gBAAAA,MAAM,IAAId,SAAS,CAACoB,EAAD,CAAT,CAAc,CAAd,CAAV;AACH,eAFD,MAGK;AACDN,gBAAAA,MAAM,IAAK,SAAQd,SAAS,CAACoB,EAAD,CAAT,CAAc,CAAd,CAAiB,OAAMrD,OAAO,CAACK,eAAgB,YAAW4B,SAAS,CAACoB,EAAD,CAAT,CAAc,CAAd,CAAiB,YAAWrD,OAAO,CAACM,aAAc,cAA/H;AACH;AACJ;AACJ;;AACD,iBAAOyC,MAAP;;AACJ;AACI,gBAAM,IAAInD,KAAJ,CAAU,2BAAV,CAAN;AAjER;AAmEH;AACJ;;AA/QW;;AAkRhB,MAAM0D,IAAI,GAAG;AACThF,EAAAA,UADS;AAETC,EAAAA,UAFS;AAGTC,EAAAA,MAHS;AAITC,EAAAA,OAJS;AAKTC,EAAAA,UALS;AAMTC,EAAAA,WANS;AAOTC,EAAAA,WAPS;AAQTC,EAAAA,OARS;AASTC,EAAAA,QATS;AAUTC,EAAAA,WAVS;AAWTI,EAAAA,aAXS;AAYTC,EAAAA,cAZS;AAaTC,EAAAA;AAbS,CAAb;AAgBAC,SAAS,CAACgE,IAAV,GAAiBA,IAAjB;AAEA,eAAehE,SAAf","sourcesContent":["import {\n    ROMANIZATION_SYSTEM,\n    getStrType,\n    patchTokens,\n    isHiragana,\n    isKatakana,\n    isKana,\n    isKanji,\n    isJapanese,\n    hasHiragana,\n    hasKatakana,\n    hasKana,\n    hasKanji,\n    hasJapanese,\n    toRawHiragana,\n    toRawKatakana,\n    toRawRomaji,\n    kanaToHiragna,\n    kanaToKatakana,\n    kanaToRomaji\n} from \"./util\";\n\n/**\n * Kuroshiro Class\n */\nclass Kuroshiro {\n    /**\n     * Constructor\n     * @constructs Kuroshiro\n     */\n    constructor() {\n        this._analyzer = null;\n    }\n\n    /**\n     * Initialize Kuroshiro\n     * @memberOf Kuroshiro\n     * @instance\n     * @returns {Promise} Promise object represents the result of initialization\n     */\n    async init(analyzer) {\n        if (!analyzer || typeof analyzer !== \"object\" || typeof analyzer.init !== \"function\" || typeof analyzer.parse !== \"function\") {\n            throw new Error(\"Invalid initialization parameter.\");\n        }\n        else if (this._analyzer == null) {\n            try {\n                await analyzer.init();\n                this._analyzer = analyzer;\n            }\n            catch (err) {\n                throw err;\n            }\n        }\n        else {\n            throw new Error(\"Kuroshiro has already been initialized.\");\n        }\n    }\n\n    /**\n     * Convert given string to target syllabary with options available\n     * @memberOf Kuroshiro\n     * @instance\n     * @param {string} str Given String\n     * @param {Object} [options] Settings Object\n     * @param {string} [options.to=\"hiragana\"] Target syllabary [\"hiragana\"|\"katakana\"|\"romaji\"]\n     * @param {string} [options.mode=\"normal\"] Convert mode [\"normal\"|\"spaced\"|\"okurigana\"|\"furigana\"]\n     * @param {string} [options.romajiSystem=\"hepburn\"] Romanization System [\"nippon\"|\"passport\"|\"hepburn\"]\n     * @param {string} [options.delimiter_start=\"(\"] Delimiter(Start)\n     * @param {string} [options.delimiter_end=\")\"] Delimiter(End)\n     * @returns {Promise} Promise object represents the result of conversion\n     */\n    async convert(str, options) {\n        options = options || {};\n        options.to = options.to || \"hiragana\";\n        options.mode = options.mode || \"normal\";\n        options.romajiSystem = options.romajiSystem || ROMANIZATION_SYSTEM.HEPBURN;\n        options.delimiter_start = options.delimiter_start || \"(\";\n        options.delimiter_end = options.delimiter_end || \")\";\n        str = str || \"\";\n\n        if ([\"hiragana\", \"katakana\", \"romaji\"].indexOf(options.to) === -1) {\n            throw new Error(\"Invalid Target Syllabary.\");\n        }\n\n        if ([\"normal\", \"spaced\", \"okurigana\", \"furigana\"].indexOf(options.mode) === -1) {\n            throw new Error(\"Invalid Conversion Mode.\");\n        }\n\n        const ROMAJI_SYSTEMS = Object.keys(ROMANIZATION_SYSTEM).map(e => ROMANIZATION_SYSTEM[e]);\n        if (ROMAJI_SYSTEMS.indexOf(options.romajiSystem) === -1) {\n            throw new Error(\"Invalid Romanization System.\");\n        }\n\n        const rawTokens = await this._analyzer.parse(str);\n        const tokens = patchTokens(rawTokens);\n\n        if (options.mode === \"normal\" || options.mode === \"spaced\") {\n            switch (options.to) {\n                case \"katakana\":\n                    if (options.mode === \"normal\") {\n                        return tokens.map(token => token.reading).join(\"\");\n                    }\n                    return tokens.map(token => token.reading).join(\" \");\n                case \"romaji\":\n                    const romajiConv = (token) => {\n                        let preToken;\n                        if (hasJapanese(token.surface_form)) {\n                            preToken = token.pronunciation || token.reading;\n                        }\n                        else {\n                            preToken = token.surface_form;\n                        }\n                        return toRawRomaji(preToken, options.romajiSystem);\n                    };\n                    if (options.mode === \"normal\") {\n                        return tokens.map(romajiConv).join(\"\");\n                    }\n                    return tokens.map(romajiConv).join(\" \");\n                case \"hiragana\":\n                    for (let hi = 0; hi < tokens.length; hi++) {\n                        if (hasKanji(tokens[hi].surface_form)) {\n                            if (!hasKatakana(tokens[hi].surface_form)) {\n                                tokens[hi].reading = toRawHiragana(tokens[hi].reading);\n                            }\n                            else {\n                                // handle katakana-kanji-mixed tokens\n                                tokens[hi].reading = toRawHiragana(tokens[hi].reading);\n                                let tmp = \"\";\n                                let hpattern = \"\";\n                                for (let hc = 0; hc < tokens[hi].surface_form.length; hc++) {\n                                    if (isKanji(tokens[hi].surface_form[hc])) {\n                                        hpattern += \"(.*)\";\n                                    }\n                                    else {\n                                        hpattern += isKatakana(tokens[hi].surface_form[hc]) ? toRawHiragana(tokens[hi].surface_form[hc]) : tokens[hi].surface_form[hc];\n                                    }\n                                }\n                                const hreg = new RegExp(hpattern);\n                                const hmatches = hreg.exec(tokens[hi].reading);\n                                if (hmatches) {\n                                    let pickKJ = 0;\n                                    for (let hc1 = 0; hc1 < tokens[hi].surface_form.length; hc1++) {\n                                        if (isKanji(tokens[hi].surface_form[hc1])) {\n                                            tmp += hmatches[pickKJ + 1];\n                                            pickKJ++;\n                                        }\n                                        else {\n                                            tmp += tokens[hi].surface_form[hc1];\n                                        }\n                                    }\n                                    tokens[hi].reading = tmp;\n                                }\n                            }\n                        }\n                        else {\n                            tokens[hi].reading = tokens[hi].surface_form;\n                        }\n                    }\n                    if (options.mode === \"normal\") {\n                        return tokens.map(token => token.reading).join(\"\");\n                    }\n                    return tokens.map(token => token.reading).join(\" \");\n                default:\n                    throw new Error(\"Unknown option.to param\");\n            }\n        }\n        else if (options.mode === \"okurigana\" || options.mode === \"furigana\") {\n            const notations = []; // [basic, basic_type[1=kanji,2=kana,3=others], notation, pronunciation]\n            for (let i = 0; i < tokens.length; i++) {\n                const strType = getStrType(tokens[i].surface_form);\n                switch (strType) {\n                    case 0:\n                        notations.push([tokens[i].surface_form, 1, toRawHiragana(tokens[i].reading), tokens[i].pronunciation || tokens[i].reading]);\n                        break;\n                    case 1:\n                        let pattern = \"\";\n                        let isLastTokenKanji = false;\n                        const subs = []; // recognize kanjis and group them\n                        for (let c = 0; c < tokens[i].surface_form.length; c++) {\n                            if (isKanji(tokens[i].surface_form[c])) {\n                                if (!isLastTokenKanji) { // ignore successive kanji tokens (#10)\n                                    isLastTokenKanji = true;\n                                    pattern += \"(.*)\";\n                                    subs.push(tokens[i].surface_form[c]);\n                                }\n                                else {\n                                    subs[subs.length - 1] += tokens[i].surface_form[c];\n                                }\n                            }\n                            else {\n                                isLastTokenKanji = false;\n                                subs.push(tokens[i].surface_form[c]);\n                                pattern += isKatakana(tokens[i].surface_form[c]) ? toRawHiragana(tokens[i].surface_form[c]) : tokens[i].surface_form[c];\n                            }\n                        }\n                        const reg = new RegExp(`^${pattern}$`);\n                        const matches = reg.exec(toRawHiragana(tokens[i].reading));\n                        if (matches) {\n                            let pickKanji = 1;\n                            for (let c1 = 0; c1 < subs.length; c1++) {\n                                if (isKanji(subs[c1][0])) {\n                                    notations.push([subs[c1], 1, matches[pickKanji], toRawKatakana(matches[pickKanji])]);\n                                    pickKanji += 1;\n                                }\n                                else {\n                                    notations.push([subs[c1], 2, toRawHiragana(subs[c1]), toRawKatakana(subs[c1])]);\n                                }\n                            }\n                        }\n                        else {\n                            notations.push([tokens[i].surface_form, 1, toRawHiragana(tokens[i].reading), tokens[i].pronunciation || tokens[i].reading]);\n                        }\n                        break;\n                    case 2:\n                        for (let c2 = 0; c2 < tokens[i].surface_form.length; c2++) {\n                            notations.push([tokens[i].surface_form[c2], 2, toRawHiragana(tokens[i].reading[c2]), (tokens[i].pronunciation && tokens[i].pronunciation[c2]) || tokens[i].reading[c2]]);\n                        }\n                        break;\n                    case 3:\n                        for (let c3 = 0; c3 < tokens[i].surface_form.length; c3++) {\n                            notations.push([tokens[i].surface_form[c3], 3, tokens[i].surface_form[c3], tokens[i].surface_form[c3]]);\n                        }\n                        break;\n                    default:\n                        throw new Error(\"Unknown strType\");\n                }\n            }\n            let result = \"\";\n            switch (options.to) {\n                case \"katakana\":\n                    if (options.mode === \"okurigana\") {\n                        for (let n0 = 0; n0 < notations.length; n0++) {\n                            if (notations[n0][1] !== 1) {\n                                result += notations[n0][0];\n                            }\n                            else {\n                                result += notations[n0][0] + options.delimiter_start + toRawKatakana(notations[n0][2]) + options.delimiter_end;\n                            }\n                        }\n                    }\n                    else { // furigana\n                        for (let n1 = 0; n1 < notations.length; n1++) {\n                            if (notations[n1][1] !== 1) {\n                                result += notations[n1][0];\n                            }\n                            else {\n                                result += `<ruby>${notations[n1][0]}<rp>${options.delimiter_start}</rp><rt>${toRawKatakana(notations[n1][2])}</rt><rp>${options.delimiter_end}</rp></ruby>`;\n                            }\n                        }\n                    }\n                    return result;\n                case \"romaji\":\n                    if (options.mode === \"okurigana\") {\n                        for (let n2 = 0; n2 < notations.length; n2++) {\n                            if (notations[n2][1] !== 1) {\n                                result += notations[n2][0];\n                            }\n                            else {\n                                result += notations[n2][0] + options.delimiter_start + toRawRomaji(notations[n2][3], options.romajiSystem) + options.delimiter_end;\n                            }\n                        }\n                    }\n                    else { // furigana\n                        result += \"<ruby>\";\n                        for (let n3 = 0; n3 < notations.length; n3++) {\n                            result += `${notations[n3][0]}<rp>${options.delimiter_start}</rp><rt>${toRawRomaji(notations[n3][3], options.romajiSystem)}</rt><rp>${options.delimiter_end}</rp>`;\n                        }\n                        result += \"</ruby>\";\n                    }\n                    return result;\n                case \"hiragana\":\n                    if (options.mode === \"okurigana\") {\n                        for (let n4 = 0; n4 < notations.length; n4++) {\n                            if (notations[n4][1] !== 1) {\n                                result += notations[n4][0];\n                            }\n                            else {\n                                result += notations[n4][0] + options.delimiter_start + notations[n4][2] + options.delimiter_end;\n                            }\n                        }\n                    }\n                    else { // furigana\n                        for (let n5 = 0; n5 < notations.length; n5++) {\n                            if (notations[n5][1] !== 1) {\n                                result += notations[n5][0];\n                            }\n                            else {\n                                result += `<ruby>${notations[n5][0]}<rp>${options.delimiter_start}</rp><rt>${notations[n5][2]}</rt><rp>${options.delimiter_end}</rp></ruby>`;\n                            }\n                        }\n                    }\n                    return result;\n                default:\n                    throw new Error(\"Invalid Target Syllabary.\");\n            }\n        }\n    }\n}\n\nconst Util = {\n    isHiragana,\n    isKatakana,\n    isKana,\n    isKanji,\n    isJapanese,\n    hasHiragana,\n    hasKatakana,\n    hasKana,\n    hasKanji,\n    hasJapanese,\n    kanaToHiragna,\n    kanaToKatakana,\n    kanaToRomaji\n};\n\nKuroshiro.Util = Util;\n\nexport default Kuroshiro;\n"]},"metadata":{},"sourceType":"module"}